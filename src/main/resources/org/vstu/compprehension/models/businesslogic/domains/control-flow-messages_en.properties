
# actions ordering question preamble
ORDER_question_prompt = <p>Press the actions of the algorithm in the order they are evaluated. Activate actions with play<img src = "https://icons.bootstrap-4.ru/assets/icons/play-fill.svg" alt = "Play" width = "18"> and stop<img src = "https://icons.bootstrap-4.ru/assets/icons/stop-fill.svg" alt = "Stop" width = "16"> buttons.</p>


# trace line templates

text.trace.template.nth_time = 1-th time
html.trace.template.nth_time = <span class="number">1-th</span> time

text.trace.program.started = program began
html.trace.program.started = <span class = "program">program</span> <span class = "keyword">began</span>

text.trace.program.finished = program ended
html.trace.program.finished = <span class = "program">program</span> <span class = "keyword">ended</span>

text.trace.stmt.performed = statement ${name} executed ${nth_time}
html.trace.stmt.performed = <span class="action">statement</span> <span class="variable">${name}</span> <span class="keyword">executed</span> ${nth_time}

text.trace.expr.performed = condition ${name} evaluated ${nth_time} - ${value}
html.trace.expr.performed = <span class="struct">condition</span> <span class="variable">${name}</span> <span class="keyword">evaluated</span> ${nth_time} - <span class="atom">${value}</span>

text.trace.loop.started = loop ${name} began ${nth_time}
html.trace.loop.started = <span class="struct">loop</span> <span class="variable">${name}</span> <span class="keyword">began</span> ${nth_time}

text.trace.loop.finished = loop ${name} ended ${nth_time}
html.trace.loop.finished = <span class="struct">loop</span> <span class="variable">${name}</span> <span class="keyword">ended</span> ${nth_time}

text.trace.iteration.started = iteration ${n} of loop ${name} began
html.trace.iteration.started = <span class="struct">iteration</span> <span class="number">${n}</span> <span class="struct">of</span> <span class="struct">loop</span> <span class="variable">${name}</span> <span class="keyword">began</span>

text.trace.iteration.finished = iteration ${n} of loop ${name} ended
html.trace.iteration.finished = <span class="struct">iteration</span> <span class="number">${n}</span> <span class="struct">of</span> <span class="struct">loop</span> <span class="variable">${name}</span> <span class="keyword">ended</span>

text.trace.alternative.started = alternative ${name} began ${nth_time}
html.trace.alternative.started = <span class="struct">alternative</span> <span class="variable">${name}</span> <span class="keyword">began</span> ${nth_time}

text.trace.alternative.finished = alternative ${name} ended ${nth_time}
html.trace.alternative.finished = <span class="struct">alternative</span> <span class="variable">${name}</span> <span class="keyword">ended</span> ${nth_time}


# if & else-if look identical

text.trace.if.started = branch of condition (${cond.name}) began ${nth_time}
html.trace.if.started = <span class="struct">branch</span> <span class="struct">of</span> <span class="struct">condition</span> (<span class="variable">${cond.name}</span>) <span class="keyword">began</span> ${nth_time}
text.trace.if.finished = branch of condition (${cond.name}) ended ${nth_time}
html.trace.if.finished = <span class="struct">branch</span> <span class="struct">of</span> <span class="struct">condition</span> (<span class="variable">${cond.name}</span>) <span class="keyword">ended</span> ${nth_time}

text.trace.else-if.started = branch of condition (${cond.name}) began ${nth_time}
html.trace.else-if.started = <span class="struct">branch</span> <span class="struct">of</span> <span class="struct">condition</span> (<span class="variable">${cond.name}</span>) <span class="keyword">began</span> ${nth_time}
text.trace.else-if.finished = branch of condition (${cond.name}) ended ${nth_time}
html.trace.else-if.finished = <span class="struct">branch</span> <span class="struct">of</span> <span class="struct">condition</span> (<span class="variable">${cond.name}</span>) <span class="keyword">ended</span> ${nth_time}


text.trace.else.started = branch ELSE of ${parent.name} began ${nth_time}
html.trace.else.started = <span class="struct">branch</span> <span class="keyword">ELSE</span> <span class="struct">of</span> <span class="variable">${parent.name}</span> <span class="keyword">began</span> ${nth_time}

text.trace.else.finished = branch ELSE of ${parent.name} ended ${nth_time}
html.trace.else.finished = <span class="struct">branch</span> <span class="keyword">ELSE</span> <span class="struct">of</span> <span class="variable">${parent.name}</span> <span class="keyword">ended</span> ${nth_time}


# mistake explanation templates

UpcomingNeighbour = Why did you skip ${MISSING} ?
NotNeighbour = Why did you execute ${EXTRA} ?
WrongCondNeighbour = Why did you execute ${A}, when the condition ${COND} is ${TrueFalse} ?
SKIP___MisplacedBefore = ${A} is a part of ${B} so ${A} can't be executed before ${B} starts.
SKIP___MisplacedAfter = ${B} is a part of ${A} so ${B} can't be executed after ${A} ends.
CorrespondingEndMismatched = Bad trace: ${BEGIN} ended as ${A}.
EndedDeeper = An action ends only when all its nested actions have ended, so ${A} cannot end until ${INNER} ends as ${INNER} is a part of ${A}.
EndedShallower = Action ${A} can't end ${BEGIN} as ${BEGIN} contains ${A}.
WrongContext = ${A} can't be executed inside of ${CONTEXT} because ${A} is not a direct part of ${CONTEXT}.
OneLevelShallower = ${A} cannot be executed within ${CONTEXT} because ${A} is an element of ${PARENT}, so start ${PARENT} first.
TooEarlyInSequence = A sequence executes its nested actions in order, so ${A} cannot be executed before ${MISSING}.
TooLateInSequence = A sequence executes its nested actions in order, so ${A} cannot be executed after ${PREVIOUS}.
SequenceFinishedTooEarly = A sequence always executes all its actions. The sequence ${A} cannot finish until actions: ${list-MISSING} are executed.
SequenceFinishedNotInOrder = Sequence ${A} cannot end until it starts.
DuplicateOfAct = A sequence executes each its action once, so each execution of ${PARENT} can contain only one execution of ${A}.
NoFirstCondition = A selection statement evaluates its conditions in order until the first true condition. Selection statement ${ALT} should start with evaluating its first condition ${REQUIRED_COND}.
BranchNotNextToCondition = Selection statement executes its branch only if the branch condition is true. Selection statement ${ALT} can execute the branch ${UNEXPECTED_BRANCH} right after condition ${REQUIRED_COND} only.
ElseBranchNotNextToLastCondition = A selection statement executes its "ELSE" branch only if all its conditions are false. Selection statement ${ALT} cannot execute the branch "ELSE" until its condition ${REQUIRED_COND} is evaluated.
ElseBranchAfterTrueCondition = A selection statement executes its "ELSE" branch only if all its conditions are false. Selection statement ${ALT} must not execute its branch "ELSE" since condition ${LATEST_ALT_COND} is true.
CondtionNotNextToPrevCondition = A selection statement evaluates its conditions in order up to the first true condition. Selection statement ${ALT} can evaluate its condition ${CURRENT_ALT_COND} right after the condition ${REQUIRED_COND} only, if ${REQUIRED_COND} is false.
ConditionTooEarly = A selection statement evaluates its conditions in order up to the first true condition. Selection statement ${ALT} cannot evaluate its condition ${CURRENT_ALT_COND} until the condition ${REQUIRED_COND} is evaluated.
ConditionTooLate = A selection statement evaluates its conditions in order up to the first true condition. Selection statement ${ALT} should evaluate its condition ${CURRENT_ALT_COND} earlier, right after condition ${REQUIRED_COND} is evaluated.
ConditionAfterBranch = A selection statement executes no more than one alternative action and finishes. Selection statement ${ALT} must not evaluate its condition ${UNEXPECTED_ALT_COND} because the branch ${BRANCH} was executed.
DuplicateOfCondition = A selection statement evaluates its conditions in order up to the first true condition. Selection statement ${ALT} must not evaluate its condition ${CURRENT_ALT_COND} twice.
NoNextCondition = A selection statement evaluates its conditions in order up to the first true condition. Selection statement ${ALT} should evaluate its condition ${EXPECTED_ALT_COND} next because the condition ${LATEST_ALT_COND} is false.
BranchOfFalseCondition = A selection statement executes its branch only if its condition is true. Selection statement ${ALT} must not execute the branch ${UNEXPECTED_BRANCH} because its condition ${LATEST_ALT_COND} is false.
AnotherExtraBranch = A selection statement executes only one branch. Selection statement ${ALT} must not start its branch ${UNEXPECTED_BRANCH} because the branch ${BRANCH} was executed.
BranchWithoutCondition = A selection statement executes its branch when the branch condition evaluates to true. Selection statement ${ALT} must not execute the branch ${UNEXPECTED_BRANCH} without evaluating its condition ${REQUIRED_COND} first.
NoBranchWhenConditionIsTrue = A selection statement executes its branch when the corresponding condition is true. Selection statement ${ALT} must execute the branch ${EXPECTED_BRANCH} because its condition ${LATEST_ALT_COND} is true.
LastFalseNoEnd = When all conditions of a selection statement are false and "ELSE" branch does not exist, the selection does nothing. Selection statement ${ALT} does not have an 'else' branch so it must finish because its condition(s) ${ALT_COND} is/are false.
AlternativeEndAfterTrueCondition = When a condition of a selection statement evaluates to true, the selection executes the corresponding branch. Selection statement ${ALT} should not finish until the branch of successful condition ${LATEST_ALT_COND} is executed.
NoAlternativeEndAfterBranch = A selection statement finishes after executing one branch. Selection statement ${ALT} executed its branch ${BRANCH} and should finish.
LastConditionIsFalseButNoElse = A selection statement executes its "ELSE" branch only if all conditions are false. Selection statement ${ALT} must execute its branch "ELSE" because the condition(s) ${list-ALT_COND} evaluated to false.
NoIterationAfterSuccessfulCondition = A ${kind_of_loop} loop continues if its condition is true: its new iteration must begin. A new iteration of the loop ${LOOP} must begin because its condition ${LOOP_COND} is true.
LoopEndAfterSuccessfulCondition = A ${kind_of_loop} loop continues if its condition is true: its new iteration must begin. It's too early to finish the loop ${LOOP} because its condition ${LOOP_COND} is true.
NoLoopEndAfterFailedCondition = A ${kind_of_loop}  loop ends when its condition becomes false. As the condition ${LOOP_COND} is false, the loop ${LOOP} must end.
LoopEndsWithoutCondition = The finish of a loop is determined by its condition. Since the condition ${LOOP_COND} is not evaluated yet, the loop ${LOOP} must not end.
LoopStartIsNotCondition = A ${kind_of_loop} loop is a pre-test loop. So the loop ${LOOP} should start by evaluating its condition ${LOOP_COND}.
LoopStartIsNotIteration = A DO loop is a post-test loop. Therefore, loop ${LOOP} should begin with an iteration.
LoopContinuedAfterFailedCondition = A loop ends when its condition becomes false. Since condition ${LOOP_COND} is false, loop ${LOOP} cannot continue.
IterationAfterFailedCondition = A loop ends when its condition becomes false. Since condition ${LOOP_COND} is false, the iteration of loop ${LOOP} cannot start.
NoConditionAfterIteration = After an iteration of ${kind_of_loop} loop, its condition must be evaluated to determine whether to continue the loop or finish it. After an iteration of loop ${LOOP}, its condition ${LOOP_COND} should be evaluated.
NoConditionBetweenIterations = After an iteration of ${kind_of_loop} loop, it is to determine whether the loop continues or ends. Before proceeding to the next iteration of loop ${LOOP}, its condition ${LOOP_COND} should be evaluated.
LoopStartsNotWithInit = A FOR loop starts from initializing its variable. Begin loop ${LOOP} from executing its initialization ${B}.
InitNotAtLoopStart = The initialization of a FOR loop is executed once at the beginning of the loop. Initialization ${B} should not be executed after ${A}.
NoConditionAfterForInit = A FOR loop is a pre-test loop, so it should evaluate its condition before its first iteration. Condition ${B} should be evaluated after initialization ${A}.
IterationAfterForInit = A FOR loop is a pre-test loop, it won't start an iteration if its condition is false at the beginning. After initialization ${A} condition ${B} should be evaluated.
NoUpdateAfterIteration = A FOR loop has an advancement that updates the loop variable before next iteration. After iteration of loop ${A}, its advancement ${B} should be executed.
UpdateNotAfterIteration = The FOR loop has an advancement that updates the loop variable. The advancement ${B} should only be executed after the iteration of loop ${A}.
ForConditionAfterIteration = A FOR loop has an advancement that updates the loop variable before the loop condition is evaluated. After iteration of loop ${A} its advancement ${B} should be executed.
NoConditionAfterForUpdate = The FOR loop has an increment command that updates the loop variable before the loop condition is evaluated. After the update command ${A} the condition ${B} should be evaluated.
NoForeachUpdateAfterSuccessfulCondition = The FOREACH loop traverses a collection or iterates over an iterator and proceeds to the next element is one exists. Since the check for the next element is successful (the condition is true), the next element should be retrieved and the iteration of the ${B} loop should begin.
ForeachUpdateNotAfterSuccessfulCondition = The FOREACH loop traverses a collection or iterator and must go to the next element immediately after checking for the next element. The ${B} loop should go to the next element right after a successful check for the next element.
NoIterationAfterForeachUpdate = The FOREACH loop traverses a collection or iterator and must start a new iteration after moving to the next element. Immediately after the advance to the next element, the iteration of the ${B} loop should begin.
IterationNotAfterForeachUpdate = The FOREACH loop traverses a collection or iterator, and should start a new iteration immediately after moving to the next element. Right after the advance to the next element the iteration of the ${B} loop should start.


# correct step explanation templates

SequenceBegin = Sequence executes its statements in their order, so for sequence ${SEQ}, its statement ${INNER} should be executed first.
SequenceNext = Sequence executes its statements in their order, so in sequence ${SEQ}, its statement ${PREVIOUS} should be followed by statement ${NEXT}.
SequenceEnd = Sequence executes its actions exactly once per run, so sequence ${SEQ} finishes after all its actions completed.
AltBegin = A selection statement starts with evaluating its first condition, so selection ${ALT} should start with evaluating its condition ${ALT_COND}.
AltBranchBegin = A selection statement executes its branch when corresponding condition is true. As condition ${ALT_COND} is true, branch ${BRANCH} should begin.
NextAltCondition = A selection statement evaluates its consequent condition when current condition is false. As condition ${ALT_COND} is false, condition ${NEXT_COND} should be evaluated.
AltElseBranchBegin = A selection statement executes its ELSE branch when all of its conditions are false. As condition ${ALT_COND} is false, selection ${ALT} should execute its ELSE branch.
AltEndAllFalse = A selection statement finishes when all of its conditions are false and the ELSE branch is absent. Selection ${ALT} should finish.
AltEndAfterBranch = A selection statement executes at most one of its branches at a time. Selection statement branch has executed, and now selection statement ${ALT} should end.
PreCondLoopBegin =  A WHILE loop (as a pre-test loop) evaluates its condition before its iteration begins. As ${LOOP} loop is a WHILE loop, its condition ${LOOP_COND} should be evaluated in the beginning of the loop.
PostCondLoopBegin = A DO-WHILE loop (as a post-test loop) evaluates its condition after its iteration ends. As ${LOOP} loop is a DO-WHILE loop, its iteration should begin in the beginning of the loop.
IterationBeginOnTrueCond = A ${kind_of_loop} loop continues under the true condition. As loop condition ${LOOP_COND} is true, the iteration of loop ${LOOP} should start.
IterationBeginOnFalseCond = The loop exit condition is false, and now the iteration should start because the loop ${DO_UNTIL} continues under the false condition. (~)
LoopEndOnFalseCond = A ${kind_of_loop} loop finishes when condition is false. As loop condition ${LOOP_COND} is false, loop ${LOOP} should end.
NormalLoopEnd = The loop exit condition is true, and now the loop should end because the loop ${DO_UNTIL} stops under the true condition (~)
LoopCondBeginAfterIteration = A loop evaluates its condition once its iteration completed. As iteration of ${LOOP} loop finished, loop condition ${LOOP_COND} should be evaluated.
