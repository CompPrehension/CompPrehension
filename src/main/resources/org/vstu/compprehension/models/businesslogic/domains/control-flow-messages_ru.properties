
# actions ordering question preamble
ORDER_question_prompt = <p>Нажмите на действия алгоритма в том порядке, в котором они выполнятся. Активируйте действия при помощи кнопок play<img src = "https://icons.bootstrap-4.ru/assets/icons/play-fill.svg" alt = "Play" width = "18"> (начать/выполнить) и stop<img src = "https://icons.bootstrap-4.ru/assets/icons/stop-fill.svg" alt = "Stop" width = "16"> (закончить).</p>


# trace line templates

text.trace.template.nth_time = {0,number,integer}-й раз
html.trace.template.nth_time = <span class="number">{0,number,integer}-й</span> раз

text.trace.program.started = началась программа
html.trace.program.started = <span class="keyword">началась</span> <span class="program">программа</span>

text.trace.program.finished = закончилась программа
html.trace.program.finished = <span class="keyword">закончилась</span> <span class="program">программа</span>

text.trace.stmt.performed = действие ${name} выполнилось ${nth_time}
html.trace.stmt.performed = <span class="action">действие</span> <span class="variable">${name}</span> <span class="keyword">выполнилось</span> ${nth_time}

text.trace.expr.performed = условие ${name} выполнилось ${nth_time} - ${value}
html.trace.expr.performed = <span class="struct">условие</span> <span class="variable">${name}</span> <span class="keyword">выполнилось</span> ${nth_time} - <span class="atom">${value}</span>

value.invalid = не вычислено
value.bool.1 = истина
value.bool.0 = ложь

text.trace.loop.started = начался цикл ${name} ${nth_time}
html.trace.loop.started = <span class="keyword">начался</span> <span class="struct">цикл</span> <span class="variable">${name}</span> ${nth_time}

text.trace.loop.finished = закончился цикл ${name} ${nth_time}
html.trace.loop.finished = <span class="keyword">закончился</span> <span class="struct">цикл</span> <span class="variable">${name}</span> ${nth_time}

text.trace.iteration.started = началась итерация ${n} цикла ${parent.name}
html.trace.iteration.started = <span class="keyword">началась</span> <span class="struct">итерация</span> <span class="number">${n}</span> <span class="struct">цикла</span> <span class="variable">${parent.name}</span>

text.trace.iteration.finished = закончилась итерация ${n} цикла ${parent.name}
html.trace.iteration.finished = <span class="keyword">закончилась</span> <span class="struct">итерация</span> <span class="number">${n}</span> <span class="struct">цикла</span> <span class="variable">${parent.name}</span>


text.trace.alternative.started = началась развилка ${name} ${nth_time}
html.trace.alternative.started = <span class="keyword">началась</span> <span class="struct">развилка</span> <span class="variable">${name}</span> ${nth_time}

text.trace.alternative.finished = закончилась развилка ${name} ${nth_time}
html.trace.alternative.finished = <span class="keyword">закончилась</span> <span class="struct">развилка</span> <span class="variable">${name}</span> ${nth_time}


# if & else-if look identical

text.trace.if.started = ветка развилки c условием ${cond.name} началась ${nth_time}
# ветка условия развилки (cnd2) началась 1-й раз
html.trace.if.started = <span class="struct">ветка развилки c условием</span> <span class="variable">${cond.name}</span> <span class="keyword">началась</span> ${nth_time}
text.trace.if.finished = ветка развилки c условием ${cond.name} закончилась ${nth_time}
# ветка условия развилки (cnd2) закончилась 1-й раз
html.trace.if.finished = <span class="struct">ветка развилки c условием</span> <span class="variable">${cond.name}</span> <span class="keyword">закончилась</span> ${nth_time}

text.trace.else-if.started = ветка развилки c условием ${cond.name} началась ${nth_time}
# ветка условия развилки (cnd2) началась 2-й раз
html.trace.else-if.started = <span class="struct">ветка развилки c условием</span> <span class="variable">${cond.name}</span> <span class="keyword">началась</span> ${nth_time}
text.trace.else-if.finished = ветка развилки c условием ${cond.name} закончилась ${nth_time}
# ветка условия развилки (cnd2) закончилась 2-й раз
html.trace.else-if.finished = <span class="struct">ветка развилки c условием</span> <span class="variable">${cond.name}</span> <span class="keyword">закончилась</span> ${nth_time}


text.trace.else.started = ветка ИНАЧЕ развилки ${parent.name} началась ${nth_time}
html.trace.else.started = <span class="struct">ветка ИНАЧЕ</span> <span class="struct">развилки</span> <span class="variable">${parent.name}</span> <span class="keyword">началась</span> ${nth_time}

text.trace.else.finished = ветка ИНАЧЕ развилки ${parent.name} закончилась ${nth_time}
html.trace.else.finished = <span class="struct">ветка ИНАЧЕ</span> <span class="struct">развилки</span> <span class="variable">${parent.name}</span> <span class="keyword">закончилась</span> ${nth_time}


# mistake explanation templates

UpcomingNeighbour = Почему вы пропустили ${MISSING} ?
NotNeighbour = Почему вы выполнили ${EXTRA} ?
WrongCondNeighbour = Почему вы выполнили ${A}, когда условие ${COND} приняло значение ${TrueFalse} ?
SKIP___MisplacedBefore = ${A} не может выполняться до начала ${B}, потому что ${A} входит в ${B}.
SKIP___MisplacedAfter = ${B} не может выполняться после окончания ${A}, потому что ${B} входит в ${A}.
CorrespondingEndMismatched = Некорректная трасса: ${BEGIN} закончилось как ${A}.
EndedDeeper = Действие не может завершиться до окончания всех вложенных действий, поэтому ${A} не может закончиться до окончания действия ${INNER}, которое входит в ${A}.
EndedShallower = Действие ${A} не может быть окончанием действия ${BEGIN}, которое содержит ${A}.
WrongContext = ${A} не может выполняться в рамках ${CONTEXT}, потому что ${A} не является непосредственной частью ${CONTEXT}.
OneLevelShallower = ${A} не может выполняться в рамках ${CONTEXT}, потому что ${A} является элементом ${PARENT}, начните сначала ${PARENT}.
TooEarlyInSequence = Следование выполняет все свои действия по порядку, поэтому ${A} не может выполняться перед ${MISSING}.
TooLateInSequence = Следование выполняет все свои действия по порядку, поэтому ${A} не может выполняться после ${PREVIOUS}.
SequenceFinishedTooEarly = Следование выполняет все свои действия: нельзя закончить следование ${A} не выполнив действия: ${MISSING}.
SequenceFinishedNotInOrder = Нельзя закончить следование ${A}, не начав его.
DuplicateOfAct = Следование выполняет все свои действия ровно по 1 разу, поэтому во время выполнения действия ${PARENT} действие ${A} должно выполниться ровно один раз.
NoFirstCondition = Развилка проверяет все свои условия по порядку до первого истинного. Поэтому выполнение развилки ${ALT} должно начинаться с проверки её первого условия ${REQUIRED_COND}.
BranchNotNextToCondition = Развилка выполняет ветку, только если условие этой ветки истинно. Ветка ${UNEXPECTED_BRANCH} может начаться только непосредственно после условия ${REQUIRED_COND}.
ElseBranchNotNextToLastCondition = Развилка выполняет ветку "ИНАЧЕ", только если все условия были ложными. Альтернативная ветка "ELSE" не может начаться, пока условие ${REQUIRED_COND} не вычислено.
ElseBranchAfterTrueCondition = Развилка выполняет ветку "ИНАЧЕ", только если все условия были ложными. Альтернативная ветка ("ELSE") не должна начинаться, поскольку условие ${LATEST_ALT_COND} истинно.
CondtionNotNextToPrevCondition = Развилка проверяет свои условия по порядку до первого истинного. При выполнении развилки ${ALT} условие ${CURRENT_ALT_COND} может быть вычислено только сразу после ${REQUIRED_COND}, если условие ${REQUIRED_COND} было ложным.
ConditionTooEarly = Развилка проверяет свои условия по порядку до первого истинного. При выполнении развилки ${ALT} условие ${CURRENT_ALT_COND} рано вычислять, т.к. условие ${REQUIRED_COND} еще не вычислено.
ConditionTooLate = Развилка проверяет свои условия по порядку до первого истинного. При выполнении развилки ${ALT} условие ${CURRENT_ALT_COND} должно было быть вычислено раньше, сразу после условия ${REQUIRED_COND}.
ConditionAfterBranch = Выполнив одну ветку, развилка завершается. При выполнении развилки ${ALT} условие ${UNEXPECTED_ALT_COND} не должно проверяться, потому что ветка ${BRANCH} уже выполнена.
DuplicateOfCondition = Развилка проверяет все условия по порядку до первого истинного. При выполнении развилки ${ALT} условие ${CURRENT_ALT_COND} не должно проверяться повторно.
NoNextCondition = Развилка проверяет все условия по порядку до первого истинного. При выполнении развилки ${ALT} следующим должно проверяться условие ${EXPECTED_ALT_COND}, так как условие ${LATEST_ALT_COND} ложно.
BranchOfFalseCondition = Развилка выполняет ветку, только если ее условие истинно. При выполнении развилки ${ALT} не должна выполниться ветка ${UNEXPECTED_BRANCH}, потому что условие ${LATEST_ALT_COND} ложно.
AnotherExtraBranch = Выполнив одну ветку, развилка завершается. При выполнении развилки ${ALT} ветка ${UNEXPECTED_BRANCH} не должна начаться, потому что ветка ${BRANCH} уже выполнилась.
BranchWithoutCondition = Развилка выполняет ветку, только если условие этой ветки истинно. При выполнении развилки ${ALT} ветка ${UNEXPECTED_BRANCH} не может начаться, потому что условие ${REQUIRED_COND} не вычислено.
NoBranchWhenConditionIsTrue = Развилка выполняет ветку, только если условие этой ветки истинно. При выполнении развилки ${ALT} должна выполниться ветка ${EXPECTED_BRANCH}, потому что условие ${LATEST_ALT_COND} истинно.
LastFalseNoEnd = Если все условия ложны и ветка "ИНАЧЕ" отсутствует, то развилка не выполнит ничего. Развилка ${ALT}  должна завершиться, так как условие(-я) ${ALT_COND} ложно(-ы) и ветка "ИНАЧЕ" отсутствует.
AlternativeEndAfterTrueCondition = Когда вычисленное условие развилки истинно, выполняется сответствующая ветка. Развилка ${ALT} не должна завершиться, пока ветка истинного условия ${LATEST_ALT_COND} не выполнена.
NoAlternativeEndAfterBranch = Развилка завершается, выполнив одну ветку. Развилка ${ALT} выполнила ветку ${BRANCH} и должна завершиться.
LastConditionIsFalseButNoElse = Развилка выполняет ветку "ИНАЧЕ", только если все условия ложны. При выполнении развилки ${ALT} условие(-я) ${ALT_COND} ложно(-ы), поэтому должна выполниться ветка "ИНАЧЕ".
NoIterationAfterSuccessfulCondition = Когда условие продолжения цикла ${kind_of_loop} истинно, цикл должен продолжиться: начинается новая итерация цикла. Поскольку условие ${LOOP_COND} истинно, должна начаться новая итерация цикла ${LOOP}.
LoopEndAfterSuccessfulCondition = Когда условие продолжения цикла истинно, цикл ${kind_of_loop} должен продолжиться: начинается новая итерация цикла. Поэтому, раз условие ${LOOP_COND} истинно, цикл ${LOOP} заканчивать рано.
NoLoopEndAfterFailedCondition = Цикл заканчивается, как только условие продолжения стало ложным. Так как условие ${LOOP_COND} ложно, цикл ${LOOP} должен завершиться.
LoopEndsWithoutCondition = Цикл заканчивается, только если условие продолжения стало ложным. Поэтому цикл ${LOOP} не должен завершиться, пока условие ${LOOP_COND} не вычислено.
LoopStartIsNotCondition = Цикл ${kind_of_loop} является циклом с предусловием. Поэтому начать цикл ${LOOP} следует с проверки условия ${LOOP_COND}.
LoopStartIsNotIteration = Цикл DO является циклом с постусловием. Поэтому цикл ${LOOP} следует начинать с итерации.
LoopContinuedAfterFailedCondition = Цикл заканчивается, когда условие продолжения стало ложным. Цикл ${LOOP} не может продолжиться, потому что условие ${LOOP_COND} ложно.
IterationAfterFailedCondition = Цикл заканчивается, когда условие продолжения стало ложным. Итерация цикла ${LOOP} не может начаться, потому что условие ${LOOP_COND} ложно.
NoConditionAfterIteration = После итерации цикла ${kind_of_loop} нужно решить, продолжать ли цикл или закончить его. Для этого, после итерации цикла ${LOOP} следует вычислить условие ${LOOP_COND}.
NoConditionBetweenIterations = После очередной итерации цикла ${kind_of_loop} нужно решить, продолжать ли цикл или закончить его. Перед тем как перейти к следующей итерации цикла ${LOOP}, нужно вычислить условие ${LOOP_COND}.
LoopStartsNotWithInit = В начале цикла FOR выполняется инициализация. Начните выполнение цикла ${LOOP} с инициализации ${B}.
InitNotAtLoopStart = Инициализация цикла FOR выполняется один раз в начале цикла. После ${A} инициализацию ${B} выполнять не следует.
NoConditionAfterForInit = Цикл FOR является циклом с предусловием, т.е. он должен вычислить условие перед первой итерацией. После инициализации ${A} следует вычислить условие цикла ${B}.
IterationAfterForInit = Цикл FOR является циклом с предусловием; он может не выполнить ни одной итерации если условие сразу ложно. После инициализации ${A} следует вычислить условие цикла ${B}.
NoUpdateAfterIteration = Цикл FOR имеет команду перехода к следующей итерации, которая обычно обновляет значение переменной цикла. После итерации цикла ${A} следует выполнить переход ${B}.
UpdateNotAfterIteration = Переход к следующей итерации выполняется сразу после окончания предыдущей итерации цикла FOR.  Переход ${B} следует выполнять только после конца итерации цикла ${A}.
ForConditionAfterIteration = До проверки условия цикла FOR необходимо выполнить переход к следующей итерации. После итерации цикла ${A} следует выполнить переход ${B}.
NoConditionAfterForUpdate = Цикл FOR проверяет истинность своего условия перед каждой итерацией. После перехода ${A} следует вычислить условие ${B}.
NoForeachUpdateAfterSuccessfulCondition = Цикл FOREACH обходит коллекцию или перебирает итератор, переходя к очередному элементу при его наличии. Так как проверка на следующий элемент успешна (условие истинно), следует получить очередной элемент и начать итерацию цикла ${B}.
ForeachUpdateNotAfterSuccessfulCondition = Цикл FOREACH обходит коллекцию или перебирает итератор, и переходить к следующему элементу должен непосредственно после проверки наличия очередного элемента. В цикле ${B} переход к очередному элементу должен следовать сразу за успешной проверкой на следующий элемент.
NoIterationAfterForeachUpdate = Цикл FOREACH обходит коллекцию или перебирает итератор, и после перехода к очередному элементу должен начинать новую итерацию. Сразу за переходом к очередному элементу должно следовать начало итерации цикла ${B}.
IterationNotAfterForeachUpdate = Цикл FOREACH обходит коллекцию или перебирает итератор, и начинать новую итерацию должен непосредственно после перехода к очередному элементу. Сразу за переходом к очередному элементу должно следовать начало итерации цикла ${B}.
SequenceBegin = Cледование выполняет все свои действия по порядку, поэтому в следовании ${SEQ} первым будет выполнено действие ${INNER}.
SequenceNext = Cледование выполняет все свои действия по порядку, поэтому в следовании ${SEQ} после действия ${PREVIOUS} будет выполнено действие ${NEXT}
SequenceEnd = Следование выполняет все свои действия ровно по одному разу, поэтому после выполнения всех своих действий следование ${SEQ} завершится.
AltBegin = Развилка начинается с проверки первого условия, поэтому выполнение развилки ${ALT} начнется с проверки условия ${ALT_COND}.
AltBranchBegin = Развилка выполняет свою ветку при истинном условии. Поскольку условие ${ALT_COND} истинно, выполняется ветка ${BRANCH}.
NextAltCondition = Развилка проверяет следующее условие, когда текущее ложно. Поскольку условие ${ALT_COND} ложно, проверится условие ${NEXT_COND}.
AltElseBranchBegin = Развилка выполняет ветку ИНАЧЕ, если все ее условия ложны. В данной ситуации развилка ${ALT} выполнит ветку ИНАЧЕ.
AltEndAllFalse = Развилка заканчивается, когда все условия ложны и нет ветки ИНАЧЕ. Развилка ${ALT} должна закончиться.
AltEndAfterBranch = Развилка может выполнить не более одной альтернативной ветки за раз. Ветка альтернативы выполнилась, и теперь развилка ${ALT} должна закончится.
PreCondLoopBegin = В цикле с предусловием (цикл WHILE) условие проверяется перед началом итерации. Цикл ${LOOP} является циклом WHILE, поэтому в начале цикла проверится его условие ${LOOP_COND}. 
PostCondLoopBegin = В цикле с постусловием (цикл DO-WHILE) условие проверяется после окончания итерации. Цикл ${LOOP} является циклом DO-WHILE, поэтому в начале цикла сразу же начнётся его итерация.
IterationBeginOnTrueCond = Цикл ${kind_of_loop} продолжается при истинном условии. Условие продолжения цикла ${LOOP_COND} истинно, и теперь начнётся итерация цикла ${LOOP}.
IterationBeginOnFalseCond = (~) Условие выхода из цикла ложно, и теперь начнётся итерация, потому что цикл ${DO_UNTIL} продолжается при ложном условии
LoopEndOnFalseCond = Цикл ${kind_of_loop} является циклом с предусловием и прерывается при ложном условии. Условие ${LOOP_COND} ложно, и теперь цикл ${LOOP} закончится.
NormalLoopEnd = (~) Условие выхода из цикла истинно, и теперь цикл закончится, потому что цикл ${DO_UNTIL} прерывается при истинном условии
LoopCondBeginAfterIteration = Выполнив итерацию, цикл проверяет своё условие. Итерация цикла ${LOOP} завершилась, и теперь проверится условие цикла ${LOOP_COND}.
