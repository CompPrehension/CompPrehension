
# actions ordering question preamble
ctrlflow_ORDER_question_prompt = <p>Нажмите на действия алгоритма в том порядке, в котором они выполнятся. Активируйте действия при помощи кнопок play<img src = "https://icons.bootstrap-4.ru/assets/icons/play-fill.svg" alt = "Play" width = "18"> (начать/выполнить) и stop<img src = "https://icons.bootstrap-4.ru/assets/icons/stop-fill.svg" alt = "Stop" width = "16"> (закончить).</p>


# trace line templates


ctrlflow_text.trace.template.nth_time = {0,number,integer}-й раз
ctrlflow_html.trace.template.nth_time = <span class="number">{0,number,integer}-й</span> раз

ctrlflow_text.trace.program.started = началась программа
ctrlflow_html.trace.program.started = <span class="keyword">началась</span> <span class="program">программа</span>

ctrlflow_text.trace.program.finished = закончилась программа
ctrlflow_html.trace.program.finished = <span class="keyword">закончилась</span> <span class="program">программа</span>

ctrlflow_text.trace.stmt.performed = действие ${name} выполнилось ${nth_time}
ctrlflow_html.trace.stmt.performed = <span class="action">действие</span> <span class="variable">${name}</span> <span class="keyword">выполнилось</span> ${nth_time}

ctrlflow_text.trace.return_.performed = return выполнилось ${nth_time}
ctrlflow_text.trace.return.performed = return ${return_expr} выполнилось ${nth_time}
ctrlflow_html.trace.return.performed = <span class="keyword">return</span> <span class="variable">${return_expr}</span> <span class="keyword">выполнилось</span> ${nth_time}
ctrlflow_text.trace.break.performed = break выполнился ${nth_time}
ctrlflow_html.trace.break.performed = <span class="keyword">break</span> <span class="keyword">выполнился</span> ${nth_time}
ctrlflow_text.trace.continue.performed = continue выполнилось ${nth_time}
ctrlflow_html.trace.continue.performed = <span class="keyword">continue</span> <span class="keyword">выполнилось</span> ${nth_time}

ctrlflow_text.trace.expr.performed = условие ${name} выполнилось ${nth_time} - ${value}
ctrlflow_html.trace.expr.performed = <span class="struct">условие</span> <span class="variable">${name}</span> <span class="keyword">выполнилось</span> ${nth_time} - <span class="atom">${value}</span>

ctrlflow_value.invalid = не вычислено
ctrlflow_value.bool.1 = истина
ctrlflow_value.bool.0 = ложь

ctrlflow_phase.begin_of = начало
ctrlflow_phase.end_of = конец

ctrlflow_text.global_scope = глобальный код


ctrlflow_text.branch.if = ветка c условием
ctrlflow_text.branch.else-if = ветка c условием
ctrlflow_text.branch.else = ветка ИНАЧЕ развилки
ctrlflow_text.loop-body = тело цикла

ctrlflow_text.phased-branch.if = ветки c условием
ctrlflow_text.phased-branch.else-if = ветки c условием
ctrlflow_text.phased-branch.else = ветки ИНАЧЕ развилки
ctrlflow_text.phased-loop-body = тела цикла


ctrlflow_text.trace.loop.started = начался цикл ${name} ${nth_time}
ctrlflow_html.trace.loop.started = <span class="keyword">начался</span> <span class="struct">цикл</span> <span class="variable">${name}</span> ${nth_time}

ctrlflow_text.trace.loop.finished = закончился цикл ${name} ${nth_time}
ctrlflow_html.trace.loop.finished = <span class="keyword">закончился</span> <span class="struct">цикл</span> <span class="variable">${name}</span> ${nth_time}

ctrlflow_text.trace.iteration.started = началась итерация ${n} цикла ${parent.name}
ctrlflow_html.trace.iteration.started = <span class="keyword">началась</span> <span class="struct">итерация</span> <span class="number">${n}</span> <span class="struct">цикла</span> <span class="variable">${parent.name}</span>

ctrlflow_text.trace.iteration.finished = закончилась итерация ${n} цикла ${parent.name}
ctrlflow_html.trace.iteration.finished = <span class="keyword">закончилась</span> <span class="struct">итерация</span> <span class="number">${n}</span> <span class="struct">цикла</span> <span class="variable">${parent.name}</span>


ctrlflow_text.trace.alternative.started = началась развилка ${name} ${nth_time}
ctrlflow_html.trace.alternative.started = <span class="keyword">началась</span> <span class="struct">развилка</span> <span class="variable">${name}</span> ${nth_time}

ctrlflow_text.trace.alternative.finished = закончилась развилка ${name} ${nth_time}
ctrlflow_html.trace.alternative.finished = <span class="keyword">закончилась</span> <span class="struct">развилка</span> <span class="variable">${name}</span> ${nth_time}


# if & else-if look identical

ctrlflow_text.trace.if.started = ветка развилки c условием ${cond.name} началась ${nth_time}
# ветка условия развилки (cnd2) началась 1-й раз
ctrlflow_html.trace.if.started = <span class="struct">ветка развилки c условием</span> <span class="variable">${cond.name}</span> <span class="keyword">началась</span> ${nth_time}
ctrlflow_text.trace.if.finished = ветка развилки c условием ${cond.name} закончилась ${nth_time}
# ветка условия развилки (cnd2) закончилась 1-й раз
ctrlflow_html.trace.if.finished = <span class="struct">ветка развилки c условием</span> <span class="variable">${cond.name}</span> <span class="keyword">закончилась</span> ${nth_time}

ctrlflow_text.trace.else-if.started = ветка развилки c условием ${cond.name} началась ${nth_time}
# ветка условия развилки (cnd2) началась 2-й раз
ctrlflow_html.trace.else-if.started = <span class="struct">ветка развилки c условием</span> <span class="variable">${cond.name}</span> <span class="keyword">началась</span> ${nth_time}
ctrlflow_text.trace.else-if.finished = ветка развилки c условием ${cond.name} закончилась ${nth_time}
# ветка условия развилки (cnd2) закончилась 2-й раз
ctrlflow_html.trace.else-if.finished = <span class="struct">ветка развилки c условием</span> <span class="variable">${cond.name}</span> <span class="keyword">закончилась</span> ${nth_time}


ctrlflow_text.trace.else.started = ветка ИНАЧЕ развилки ${parent.name} началась ${nth_time}
ctrlflow_html.trace.else.started = <span class="struct">ветка ИНАЧЕ</span> <span class="struct">развилки</span> <span class="variable">${parent.name}</span> <span class="keyword">началась</span> ${nth_time}

ctrlflow_text.trace.else.finished = ветка ИНАЧЕ развилки ${parent.name} закончилась ${nth_time}
ctrlflow_html.trace.else.finished = <span class="struct">ветка ИНАЧЕ</span> <span class="struct">развилки</span> <span class="variable">${parent.name}</span> <span class="keyword">закончилась</span> ${nth_time}


# concepts

ctrlflow_concept.loop = Циклы
ctrlflow_concept.loop_break_continue = Прерывание цикла
ctrlflow_concept.nested_loop = Вложенные циклы
ctrlflow_concept.exprs_in_use = Операции в коде

# the following should look identical in all languages:
ctrlflow_concept.while_loop = WHILE
ctrlflow_concept.do_while_loop = DO-WHILE
ctrlflow_concept.for_loop = FOR
ctrlflow_concept.foreach_loop = FOREACH
ctrlflow_concept.alternative = if
ctrlflow_concept.if = if
ctrlflow_concept.else-if = else-if
ctrlflow_concept.else = else
ctrlflow_concept.return = return
ctrlflow_concept.break = break
ctrlflow_concept.continue = continue

ctrlflow_concept.expr\:pointer = указатели (*&ptr)
ctrlflow_concept.expr\:func_call = вызовы функций
ctrlflow_concept.expr\:explicit_cast = явное приведение типов
ctrlflow_concept.expr\:array = массивы ([])
ctrlflow_concept.expr\:class_member_access = доступ к полю (. ->)


# mistake explanation templates

ctrlflow_UpcomingNeighbour = Почему вы пропустили ${phased-MISSING} ?
ctrlflow_NotNeighbour = Почему вы выполнили ${phased-EXTRA} ?
ctrlflow_WrongCondNeighbour = Почему вы выполнили ${phased-A}, когда условие ${COND} приняло значение ${TrueFalse} ?
ctrlflow_TooEarlyWhenInterrupting = Идёт прерывание действий по ${kind_of_action}. Почему вы пропустили ${phased-MISSING} ?
ctrlflow_UnexpectedWhenInterrupting = Почему вы выполнили ${phased-EXTRA} ? Идёт прерывание действий по ${kind_of_action}.
ctrlflow_IgnoreInterruptingFlow = Почему вы продолжили выполнение до ${phased-EXTRA} ? Идёт прерывание действий по ${kind_of_action}.
ctrlflow_SKIP___MisplacedBefore = ${A} не может выполняться до начала ${B}, потому что ${A} входит в ${B}.
ctrlflow_SKIP___MisplacedAfter = ${B} не может выполняться после окончания ${A}, потому что ${B} входит в ${A}.
ctrlflow_CorrespondingEndMismatched = Некорректная трасса: ${BEGIN} закончилось как ${A}.
ctrlflow_EndedDeeper = Действие не может завершиться до окончания всех вложенных действий, поэтому ${A} не может закончиться до окончания действия ${INNER}, которое входит в ${A}.
ctrlflow_EndedShallower = Действие ${phased-A} не может быть окончанием действия ${BEGIN}, которое содержит ${A}.
ctrlflow_WrongContext = ${A} не может выполняться в рамках ${CONTEXT}, потому что ${A} не является непосредственной частью ${CONTEXT}.
ctrlflow_OneLevelShallower = ${A} не может выполняться в рамках ${CONTEXT}, потому что ${A} является элементом ${PARENT}, начните сначала ${PARENT}.
ctrlflow_TooEarlyInSequence = Следование выполняет все свои действия по порядку, поэтому ${A} не может выполняться перед ${phased-MISSING}.
ctrlflow_TooLateInSequence = Следование выполняет все свои действия по порядку, поэтому ${A} не может выполняться после ${PREVIOUS}.
ctrlflow_SequenceFinishedTooEarly = Следование выполняет все свои действия: нельзя закончить следование ${A} не выполнив действия: ${phased-MISSING}.
ctrlflow_SequenceFinishedNotInOrder = Нельзя закончить следование ${A}, не начав его.
ctrlflow_DuplicateOfAct = Следование выполняет все свои действия ровно по 1 разу, поэтому во время выполнения действия ${PARENT} действие ${A} должно выполниться ровно один раз.
ctrlflow_NoFirstCondition = Развилка проверяет все свои условия по порядку до первого истинного. Поэтому выполнение развилки ${ALT} должно начинаться с проверки её первого условия ${REQUIRED_COND}.
ctrlflow_BranchNotNextToCondition = Развилка выполняет ветку, только если условие этой ветки истинно. Ветка ${UNEXPECTED_BRANCH} может начаться только непосредственно после условия ${REQUIRED_COND}.
ctrlflow_ElseBranchNotNextToLastCondition = Развилка выполняет ветку "ИНАЧЕ", только если все условия были ложными. Альтернативная ветка "ELSE" не может начаться, пока условие ${REQUIRED_COND} не вычислено.
ctrlflow_ElseBranchAfterTrueCondition = Развилка выполняет ветку "ИНАЧЕ", только если все условия были ложными. Альтернативная ветка ("ELSE") не должна начинаться, поскольку условие ${LATEST_ALT_COND} истинно.
ctrlflow_CondtionNotNextToPrevCondition = Развилка проверяет свои условия по порядку до первого истинного. При выполнении развилки ${ALT} условие ${CURRENT_ALT_COND} может быть вычислено только сразу после ${REQUIRED_COND}, если условие ${REQUIRED_COND} было ложным.
ctrlflow_ConditionTooEarly = Развилка проверяет свои условия по порядку до первого истинного. При выполнении развилки ${ALT} условие ${CURRENT_ALT_COND} рано вычислять, т.к. условие ${REQUIRED_COND} еще не вычислено.
ctrlflow_ConditionTooLate = Развилка проверяет свои условия по порядку до первого истинного. При выполнении развилки ${ALT} условие ${CURRENT_ALT_COND} должно было быть вычислено раньше, сразу после условия ${REQUIRED_COND}.
ctrlflow_ConditionAfterBranch = Выполнив одну ветку, развилка завершается. При выполнении развилки ${ALT} условие ${UNEXPECTED_ALT_COND} не должно проверяться, потому что ветка ${BRANCH} уже выполнена.
ctrlflow_DuplicateOfCondition = Развилка проверяет все условия по порядку до первого истинного. При выполнении развилки ${ALT} условие ${CURRENT_ALT_COND} не должно проверяться повторно.
ctrlflow_NoNextCondition = Развилка проверяет все условия по порядку до первого истинного. При выполнении развилки ${ALT} следующим должно проверяться условие ${EXPECTED_ALT_COND}, так как условие ${LATEST_ALT_COND} ложно.
ctrlflow_BranchOfFalseCondition = Развилка выполняет ветку, только если ее условие истинно. При выполнении развилки ${ALT} не должна выполниться ветка ${UNEXPECTED_BRANCH}, потому что условие ${LATEST_ALT_COND} ложно.
ctrlflow_AnotherExtraBranch = Выполнив одну ветку, развилка завершается. При выполнении развилки ${ALT} ветка ${UNEXPECTED_BRANCH} не должна начаться, потому что ветка ${BRANCH} уже выполнилась.
ctrlflow_BranchWithoutCondition = Развилка выполняет ветку, только если условие этой ветки истинно. При выполнении развилки ${ALT} ветка ${UNEXPECTED_BRANCH} не может начаться, потому что условие ${REQUIRED_COND} не вычислено.
ctrlflow_NoBranchWhenConditionIsTrue = Развилка выполняет ветку, только если условие этой ветки истинно. При выполнении развилки ${ALT} должна выполниться ветка ${EXPECTED_BRANCH}, потому что условие ${LATEST_ALT_COND} истинно.
ctrlflow_LastFalseNoEnd = Если все условия ложны и ветка "ИНАЧЕ" отсутствует, то развилка не выполнит ничего. Развилка ${ALT}  должна завершиться, так как условие(-я) ${ALT_COND} ложно(-ы) и ветка "ИНАЧЕ" отсутствует.
ctrlflow_AlternativeEndAfterTrueCondition = Когда вычисленное условие развилки истинно, выполняется сответствующая ветка. Развилка ${ALT} не должна завершиться, пока ветка истинного условия ${LATEST_ALT_COND} не выполнена.
ctrlflow_NoAlternativeEndAfterBranch = Развилка завершается, выполнив одну ветку. Развилка ${ALT} выполнила ветку ${BRANCH} и должна завершиться.
ctrlflow_LastConditionIsFalseButNoElse = Развилка выполняет ветку "ИНАЧЕ", только если все условия ложны. При выполнении развилки ${ALT} условие(-я) ${ALT_COND} ложно(-ы), поэтому должна выполниться ветка "ИНАЧЕ".
ctrlflow_NoIterationAfterSuccessfulCondition = Когда условие продолжения цикла ${kind_of_loop} истинно, цикл должен продолжиться: начинается новая итерация цикла. Поскольку условие ${LOOP_COND} истинно, должна начаться новая итерация цикла ${LOOP}.
ctrlflow_LoopEndAfterSuccessfulCondition = Когда условие продолжения цикла истинно, цикл ${kind_of_loop} должен продолжиться: начинается новая итерация цикла. Поэтому, раз условие ${LOOP_COND} истинно, цикл ${LOOP} заканчивать рано.
ctrlflow_NoLoopEndAfterFailedCondition = Цикл заканчивается, как только условие продолжения стало ложным. Так как условие ${LOOP_COND} ложно, цикл ${LOOP} должен завершиться.
ctrlflow_LoopEndsWithoutCondition = Цикл заканчивается, только если условие продолжения стало ложным. Поэтому цикл ${LOOP} не должен завершиться, пока условие ${LOOP_COND} не вычислено.
ctrlflow_LoopStartIsNotCondition = Цикл ${kind_of_loop} является циклом с предусловием. Поэтому начать цикл ${LOOP} следует с проверки условия ${LOOP_COND}.
ctrlflow_LoopStartIsNotIteration = Цикл DO является циклом с постусловием. Поэтому цикл ${LOOP} следует начинать с итерации.
ctrlflow_LoopContinuedAfterFailedCondition = Цикл заканчивается, когда условие продолжения стало ложным. Цикл ${LOOP} не может продолжиться, потому что условие ${LOOP_COND} ложно.
ctrlflow_IterationAfterFailedCondition = Цикл заканчивается, когда условие продолжения стало ложным. Итерация цикла ${LOOP} не может начаться, потому что условие ${LOOP_COND} ложно.
ctrlflow_NoConditionAfterIteration = После итерации цикла ${kind_of_loop} нужно решить, продолжать ли цикл или закончить его. Для этого, после итерации цикла ${LOOP} следует вычислить условие ${LOOP_COND}.
ctrlflow_NoConditionBetweenIterations = После очередной итерации цикла ${kind_of_loop} нужно решить, продолжать ли цикл или закончить его. Перед тем как перейти к следующей итерации цикла ${LOOP}, нужно вычислить условие ${LOOP_COND}.
ctrlflow_LoopStartsNotWithInit = В начале цикла FOR выполняется инициализация. Начните выполнение цикла ${LOOP} с инициализации ${INIT}.
ctrlflow_InitNotAtLoopStart = Инициализация цикла FOR выполняется один раз в начале цикла. После ${A} инициализацию ${INIT} выполнять не следует.
ctrlflow_NoConditionAfterForInit = Цикл FOR является циклом с предусловием, т.е. он должен вычислить условие перед первой итерацией. После инициализации ${INIT} следует вычислить условие цикла ${LOOP_COND}.
ctrlflow_IterationAfterForInit = Цикл FOR является циклом с предусловием; он может не выполнить ни одной итерации, если условие окажется сразу ложным. После инициализации ${INIT} следует вычислить условие цикла ${LOOP_COND}.
ctrlflow_NoUpdateAfterIteration = Цикл FOR имеет команду перехода к следующей итерации, которая обычно обновляет значение переменной цикла. После итерации цикла ${LOOP} следует выполнить переход ${UPDATE}.
ctrlflow_UpdateNotAfterIteration = Переход к следующей итерации выполняется сразу после окончания предыдущей итерации цикла FOR.  Переход ${UPDATE} следует выполнять только после конца итерации цикла ${LOOP}.
ctrlflow_ForConditionAfterIteration = До проверки условия цикла FOR необходимо выполнить переход к следующей итерации. После итерации цикла ${LOOP} следует выполнить переход ${UPDATE}.
ctrlflow_NoConditionAfterForUpdate = Цикл FOR проверяет истинность своего условия перед каждой итерацией. После перехода ${UPDATE} следует вычислить условие ${LOOP_COND}.
ctrlflow_NoForeachUpdateAfterSuccessfulCondition = Цикл FOREACH обходит коллекцию или перебирает итератор, переходя к очередному элементу при его наличии. Так как проверка на следующий элемент успешна (условие истинно), следует получить очередной элемент и начать итерацию цикла ${B}.
ctrlflow_ForeachUpdateNotAfterSuccessfulCondition = Цикл FOREACH обходит коллекцию или перебирает итератор, и переходить к следующему элементу должен непосредственно после проверки наличия очередного элемента. В цикле ${B} переход к очередному элементу должен следовать сразу за успешной проверкой на следующий элемент.
ctrlflow_NoIterationAfterForeachUpdate = Цикл FOREACH обходит коллекцию или перебирает итератор, и после перехода к очередному элементу должен начинать новую итерацию. Сразу за переходом к очередному элементу должно следовать начало итерации цикла ${B}.
ctrlflow_IterationNotAfterForeachUpdate = Цикл FOREACH обходит коллекцию или перебирает итератор, и начинать новую итерацию должен непосредственно после перехода к очередному элементу. Сразу за переходом к очередному элементу должно следовать начало итерации цикла ${B}.


# correct step explanation templates

ctrlflow_SequenceBegin = Cледование выполняет все свои действия по порядку, поэтому в следовании ${SEQ} первым будет выполнено действие ${INNER}.
ctrlflow_SequenceNext = Cледование выполняет все свои действия по порядку, поэтому в следовании ${SEQ} после действия ${PREVIOUS} будет выполнено действие ${NEXT}
ctrlflow_SequenceEnd = Следование выполняет все свои действия ровно по одному разу, поэтому после выполнения всех своих действий следование ${SEQ} завершится.
ctrlflow_AltBegin = Развилка начинается с проверки первого условия, поэтому выполнение развилки ${ALT} начнется с проверки условия ${ALT_COND}.
ctrlflow_AltBranchBegin = Развилка выполняет свою ветку при истинном условии. Поскольку условие ${ALT_COND} истинно, выполняется ветка ${BRANCH}.
ctrlflow_NextAltCondition = Развилка проверяет следующее условие, когда текущее ложно. Поскольку условие ${ALT_COND} ложно, проверится условие ${NEXT_COND}.
ctrlflow_AltElseBranchBegin = Развилка выполняет ветку ИНАЧЕ, если все ее условия ложны. В данной ситуации развилка ${ALT} выполнит ветку ИНАЧЕ.
ctrlflow_AltEndAllFalse = Развилка заканчивается, когда все условия ложны и нет ветки ИНАЧЕ. Развилка ${ALT} должна закончиться.
ctrlflow_AltEndAfterBranch = Развилка может выполнить не более одной альтернативной ветки за раз. Ветка альтернативы выполнилась, и теперь развилка ${ALT} должна закончится.
ctrlflow_PreCondLoopBegin = В цикле с предусловием (цикл WHILE) условие проверяется перед началом итерации. Цикл ${LOOP} является циклом WHILE, поэтому в начале цикла проверится его условие ${LOOP_COND}.
ctrlflow_PostCondLoopBegin = В цикле с постусловием (цикл DO-WHILE) условие проверяется после окончания итерации. Цикл ${LOOP} является циклом DO-WHILE, поэтому в начале цикла сразу же начнётся его итерация.
ctrlflow_IterationBeginOnTrueCond = Цикл ${kind_of_loop} продолжается при истинном условии. Условие продолжения цикла ${LOOP_COND} истинно, и теперь начнётся итерация цикла ${LOOP}.
ctrlflow_IterationBeginOnFalseCond = (~) Условие выхода из цикла ложно, и теперь начнётся итерация, потому что цикл ${DO_UNTIL} продолжается при ложном условии
ctrlflow_LoopEndOnFalseCond = Цикл ${kind_of_loop} является циклом с предусловием и прерывается при ложном условии. Условие ${LOOP_COND} ложно, и теперь цикл ${LOOP} закончится.
ctrlflow_NormalLoopEnd = (~) Условие выхода из цикла истинно, и теперь цикл закончится, потому что цикл ${DO_UNTIL} прерывается при истинном условии
ctrlflow_LoopCondBeginAfterIteration = Выполнив итерацию, цикл проверяет своё условие. Итерация цикла ${LOOP} завершилась, и теперь проверится условие цикла ${LOOP_COND}.
