<DecisionTree>
    <InputVariables>
        <DecisionTreeVarDecl name="X" type="operator"/>
        <AdditionalVarDecl name="X1" type="token">
            <Expression>
                <GetExtreme extremeVarName="x1" type="token" varName="x_token">
                    <CheckRelationship relationshipName="has">
                        <DecisionTreeVar name="X"/>
                        <Variable name="x_token"/>
                    </CheckRelationship>
                    <CheckRelationship relationshipName="leftOf">
                        <Variable name="x1"/>
                        <Variable name="x_token"/>
                    </CheckRelationship>
                </GetExtreme>
            </Expression>
        </AdditionalVarDecl>
    </InputVariables>
    <ThoughtBranch _EN_description="${X} ${$branchResult == BranchResult:CORRECT ? 'can' : 'cant'} be evaluated next"
                   _EN_error_prefix="${X} cannot be evaluated yet, because "
                   _EN_hint_prefix="${X} can be evaluated, because "
                   _RU_description="${X}[case='и'] ${$branchResult == BranchResult:CORRECT ? '' : 'не'} может выполниться следующим"
                   _RU_error_prefix="${X}[case='и'] не может быть вычислен в настоящее время потому, что "
                   _RU_hint_prefix="${X}[case='и'] может быть вычислен в настоящее время потому, что "
                   _TEMPLATING_ID="1" _alias="main">
        <BranchAggregationNode _EN_asNextStep="We should check if ${X} can be evaluated next."
                               _EN_description="${X} ${$branchResult == BranchResult:CORRECT ? 'can' : 'cant'} be evaluated next"
                               _EN_endingCause="Because one of the operands of ${X} prevents its evaluation"
                               _RU_asNextStep="Необходимо проверить, может ли ${X}[case='и'] выполниться следующим."
                               _RU_description="${X}[case='и'] ${$branchResult == BranchResult:CORRECT ? '' : 'не'} может выполниться следующим"
                               _RU_endingCause="Потому что есть факторы, мешающие дальнейшему вычислению ${X}"
                               _TEMPLATING_ID="2" _alias="main.and" operator="AND">
            <ThoughtBranch
                    _EN_description="inner operand of ${X} ${$branchResult == BranchResult:CORRECT ? 'doesnt require' : 'requires'} further evaluation"
                    _EN_nextStepExplanation="That's incorrect. One should first check if the operator needs inner operand at all."
                    _EN_nextStepQuestion="What is the first step when considering operator's inner operand?"
                    _RU_description="внутренний операнд ${X}[case='р'] ${$branchResult == BranchResult:CORRECT ? 'не' : ''} требует дальнейших вычислений"
                    _RU_nextStepExplanation="Это неверно. Прежде всего необходимо проверить, нужен ли оператору внутренний операнд."
                    _RU_nextStepQuestion="С чего надо начать при рассмотрении внутреннего операнда?" _TEMPLATING_ID="3"
                    _alias="central">
                <QuestionNode _EN_asNextStep="We should check if the operator needs inner operand at all."
                              _EN_endingCause="Because ${X.class()} doesn't need inner operand."
                              _EN_question="How many token does ${X.class()} have?"
                              _RU_asNextStep="Необходимо проверить, нужен ли ${X}[case='д'] внутренний операнд."
                              _RU_endingCause="Потому что ${X.class()} не требует внутреннего операнда"
                              _RU_question="Сколько токенов имеет ${X.class()}[case='и']?" _TEMPLATING_ID="4"
                              _alias="central.isNeeded">
                    <Expression>
                        <GetPropertyValue propertyName="countOfTokens">
                            <DecisionTreeVar name="X"/>
                        </GetPropertyValue>
                    </Expression>
                    <Outcome _EN_explanation="That's incorrect. ${X.class()} has just one token."
                             _EN_nextStepExplanation="That's incorrect. Because ${X.class()} has just one token, it can't have an inner operand at all (only a left and a right one). Therefore, no inner operand to prevent its evaluation."
                             _EN_nextStepQuestion="What is the next reasoning step if we know that ${X.class()} has just one token?"
                             _RU_explanation="Это неверно. ${X.class()}[case='и'] имеет только один токен."
                             _RU_nextStepExplanation="Это неверно. Т.к. ${X.class()}[case='и'] имеет только один токен, а значит, не имеет внутреннего операнда (только левый и правый). Получается, внутренний операнд не может помешать его вычислению."
                             _RU_nextStepQuestion="Какие выводы можно сделать, если ${X.class()}[case='и'] имеет только один токен?"
                             _TEMPLATING_ID="5" value="1">
                        <BranchResultNode _EN_explanation="it has one token and so does not have a central operand."
                                          _RU_explanation="он имеет одну лексему и поэтому не может иметь центрального операнда."
                                          _TEMPLATING_ID="6" _skill="central_operand_needed" value="CORRECT"/>
                    </Outcome>
                    <Outcome _EN_explanation="That's incorrect. ${X.class()} has two tokens."
                             _EN_nextStepExplanation="That's incorrect - ${X.class()} having two tokens means it has an inner operand positioned between them. So we need to find the second token of ${X}, to then find and check the state of the inner operand."
                             _EN_nextStepQuestion="What is the next reasoning step if we know that ${X.class()} has two tokens?"
                             _RU_explanation="Это неверно. ${X.class()}[case='и'] имеет два токена."
                             _RU_nextStepExplanation="Это неверно. Т.к. ${X.class()}[case='и'] имеет два токена, а значит, требует внутренний операнд, необходимо дальнейшее нахождение и рассмотрение данного операнда."
                             _RU_nextStepQuestion="Какой дальнейший шаг можно сделать, если ${X.class()}[case='и'] имеет два токена?"
                             _TEMPLATING_ID="7" value="2">
                        <FindActionNode _EN_asNextStep="We should find the second token of ${X}."
                                        _EN_question="Find the second token of ${X}."
                                        _RU_asNextStep="Необходимо найти второй токен ${X}[case='р']."
                                        _RU_question="Найдите второй токен ${X}[case='р']." _TEMPLATING_ID="8"
                                        _alias="central.findX2">
                            <DecisionTreeVarDecl name="X2" type="token"/>
                            <Expression>
                                <GetByCondition type="token" varName="x2">
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="x2"/>
                                                <Class name="token"/>
                                            </CheckClass>
                                            <CheckRelationship relationshipName="belongsTo">
                                                <Variable name="x2"/>
                                                <DecisionTreeVar name="X"/>
                                            </CheckRelationship>
                                        </LogicalAnd>
                                        <CheckRelationship relationshipName="rightOf">
                                            <Variable name="x2"/>
                                            <DecisionTreeVar name="X1"/>
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </GetByCondition>
                            </Expression>
                            <FindError
                                    _EN_explanation="That's incorrect, because ${$checked} can't be the token of ${X.class()} - tokens of this type are unrelated to ${X.class()}."
                                    _RU_explanation="Это неверно, поскольку ${$checked}[case='и'] не может являться токеном ${X.class()}[case='р'] - он является токеном другого типа."
                                    _TEMPLATING_ID="9" _alias="X2_wrongType" priority="1">
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked"/>
                                                <Class name="token"/>
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                        </LogicalAnd>
                                        <Compare operator="NotEqual">
                                            <GetClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                            </GetClass>
                                            <GetClass>
                                                <DecisionTreeVar name="X"/>
                                            </GetClass>
                                        </Compare>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError _EN_explanation="That's incorrect - ${$checked} is on the wrong side of ${X1}."
                                       _RU_explanation="Это неверно - ${$checked}[case='и'] находится не с той стороны от ${X1}[case='р']."
                                       _TEMPLATING_ID="10" _alias="X2_wrongSide" priority="2">
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked"/>
                                                <Class name="token"/>
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship relationshipName="isBetween">
                                            <DecisionTreeVar name="X1"/>
                                            <DecisionTreeVar name="X2"/>
                                            <Variable name="checked"/>
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError
                                    _EN_explanation="That's incorrect, ${$checked} is too far to be the second token to ${X1}."
                                    _RU_explanation="Это неверно, ${$checked}[case='и'] слишком далеко, чтобы быть парой для ${X1}[case='р']."
                                    _TEMPLATING_ID="11" _alias="X2_tooFar" priority="3">
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked"/>
                                                <Class name="token"/>
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship relationshipName="isBetween">
                                            <DecisionTreeVar name="X2"/>
                                            <DecisionTreeVar name="X1"/>
                                            <Variable name="checked"/>
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError
                                    _EN_explanation="That's incorrect, ${$checked} is too close to be the second token to ${X1}."
                                    _RU_explanation="Это неверно, ${$checked}[case='и'] слишком близко, чтобы быть парой для ${X1}[case='р']."
                                    _TEMPLATING_ID="12" _alias="X2_tooClose" priority="4">
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked"/>
                                                <Class name="token"/>
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship relationshipName="isBetween">
                                            <Variable name="checked"/>
                                            <DecisionTreeVar name="X1"/>
                                            <DecisionTreeVar name="X2"/>
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <Outcome _EN_explanation="second token of ${X} is ${X2}"
                                     _RU_explanation="второй токен ${X}[case='р'] это ${X2}[case='и']"
                                     _TEMPLATING_ID="13" value="true">
                                <QuestionNode
                                        _EN_asNextStep="We should check if there are unevaluated operators between ${X1} and ${X2}."
                                        _EN_endingCause="Because of the presence/absence of unevaluated operators between ${X1} and ${X2}."
                                        _EN_question="Are there unevaluated operators between ${X1} and ${X2}?"
                                        _RU_asNextStep="Необходимо проверить, есть ли внутри ${X}[case='р'] невычисленные операторы."
                                        _RU_endingCause="Из-за наличия/отсутствия внутри ${X} невычисленных операторов."
                                        _RU_question="Есть ли внутри ${X}[case='р'] невычисленные операторы?"
                                        _TEMPLATING_ID="14" _alias="central.isUnevaluated">
                                    <Expression>
                                        <LogicalAnd>
                                            <LogicalOr>
                                                <LogicalNot>
                                                    <GetPropertyValue propertyName="needsOperand">
                                                        <DecisionTreeVar name="X"/>
                                                        <ParamsValues type="ordered">
                                                            <Enum owner="OperandPlacement" value="left"/>
                                                        </ParamsValues>
                                                    </GetPropertyValue>
                                                </LogicalNot>
                                                <LogicalNot>
                                                    <Compare operator="Equal">
                                                        <GetPropertyValue propertyName="state">
                                                            <GetByRelationship relationshipName="hasOperand">
                                                                <DecisionTreeVar name="X"/>
                                                                <ParamsValues type="ordered">
                                                                    <Enum owner="OperandPlacement" value="left"/>
                                                                </ParamsValues>
                                                            </GetByRelationship>
                                                        </GetPropertyValue>
                                                        <Enum owner="state" value="unevaluated"/>
                                                    </Compare>
                                                </LogicalNot>
                                            </LogicalOr>
                                            <ExistenceQuantifier type="operator" varName="i">
                                                <CheckClass>
                                                    <Variable name="i"/>
                                                    <Class name="operator"/>
                                                </CheckClass>
                                                <LogicalAnd>
                                                    <CheckRelationship relationshipName="isBetween">
                                                        <Variable name="i"/>
                                                        <DecisionTreeVar name="X1"/>
                                                        <DecisionTreeVar name="X2"/>
                                                    </CheckRelationship>
                                                    <Compare operator="Equal">
                                                        <GetPropertyValue propertyName="state">
                                                            <Variable name="i"/>
                                                        </GetPropertyValue>
                                                        <Enum owner="state" value="unevaluated"/>
                                                    </Compare>
                                                </LogicalAnd>
                                            </ExistenceQuantifier>
                                        </LogicalAnd>
                                    </Expression>
                                    <Outcome
                                            _EN_explanation="That's incorrect. There are unevaluated operators between ${X1} and ${X2}."
                                            _EN_nextStepExplanation="That's incorrect. Any unevaluated operator between ${X1} and ${X2}, means that the inner operand of ${X} is not fully evaluated. Therefore, it is preventing its further evaluation.."
                                            _EN_nextStepQuestion="What can we conclude if there are unevaluated operators between ${X1} and ${X2}?"
                                            _RU_explanation="Это неверно. Внутри ${X}[case='р'] присутствуют невычисленные операторы."
                                            _RU_nextStepExplanation="Это неверно. Т.к. внутри ${X}[case='р'] присутствуют невычисленные операторы, это значит, что его внутренний операнд не вычислен и мешает дальнейшему вычислению ${X}[case='р']."
                                            _RU_nextStepQuestion="Какие выводы можно сделать, если внутри ${X}[case='р'] присутствуют невычисленные операторы?"
                                            _TEMPLATING_ID="15" value="true">
                                        <BranchResultNode _EN_explanation=" its central operand is not evaluated yet."
                                                          _RU_explanation="еще не вычислен его центральный операнд."
                                                          _TEMPLATING_ID="16" _error="central.isUnevaluated"
                                                          _law="error_base_student_error_in_complex;error_base_student_error_unevaluated_operand;error_base_enclosing_operators"
                                                          _skill="is_central_operand_evaluated" value="ERROR"/>
                                    </Outcome>
                                    <Outcome
                                            _EN_explanation="That's incorrect. There are no unevaluated operators between ${X1} and ${X2}."
                                            _EN_nextStepExplanation="That's incorrect. If all of the operators between ${X1} and ${X2} are evaluated, then the inner operand of ${X} is fully evaluated. Therefore, it is not preventing its further evaluation."
                                            _EN_nextStepQuestion="What can we conclude if there are no unevaluated operators between ${X1} and ${X2}?"
                                            _RU_explanation="Это неверно. Все операторы внутри  ${X}[case='р'] вычислены."
                                            _RU_nextStepExplanation="Это неверно. Т.к. внутри ${X}[case='р'] нет невычисленные операторов, это значит, что его внутренний операнд полностью вычислен и не мешает дальнейшему вычислению ${X}[case='р']."
                                            _RU_nextStepQuestion="Какие выводы можно сделать, если  Все операторы внутри  ${X}[case='р'] вычислены?"
                                            _TEMPLATING_ID="17" value="false">
                                        <BranchResultNode _EN_explanation="its central operand has been evaluated."
                                                          _RU_explanation=" его центральный операнд уже вычислен."
                                                          _TEMPLATING_ID="18" _skill="is_central_operand_evaluated"
                                                          value="CORRECT"/>
                                    </Outcome>
                                </QuestionNode>
                            </Outcome>
                        </FindActionNode>
                    </Outcome>
                </QuestionNode>
            </ThoughtBranch>
            <ThoughtBranch
                    _EN_description="left operand of ${X} ${$branchResult == BranchResult:CORRECT ? 'doesnt require' : 'requires'} further evaluation"
                    _EN_nextStepExplanation="That's incorrect. One should first check if the operator needs left operand at all."
                    _EN_nextStepQuestion="What is the first step when considering operator's left operand?"
                    _RU_description="левый операнд ${X}[case='р'] ${$branchResult == BranchResult:CORRECT ? 'не' : ''} требует дальнейших вычислений"
                    _RU_nextStepExplanation="Это неверно. Прежде всего необходимо проверить, нужен ли оператору левый операнд."
                    _RU_nextStepQuestion="С чего надо начать при рассмотрении левого операнда?" _TEMPLATING_ID="19"
                    _alias="left">
                <QuestionNode _EN_asNextStep="We should check if ${X} needs a left operand."
                              _EN_endingCause="Because ${X} doesn't need a left operand."
                              _EN_question="Does ${X.class()} need a left operand?"
                              _RU_asNextStep="Необходимо проверить, нужен ли ${X}[case='д'] левый операнд."
                              _RU_endingCause="Потому что ${X} не требует левого операнда"
                              _RU_question="Нужен ли ${X.class()}[case='д'] левый операнд?" _TEMPLATING_ID="20"
                              _alias="left.isNeeded">
                    <Expression>
                        <GetPropertyValue propertyName="needsOperand">
                            <DecisionTreeVar name="X"/>
                            <ParamsValues type="ordered">
                                <Enum owner="OperandPlacement" value="left"/>
                            </ParamsValues>
                        </GetPropertyValue>
                    </Expression>
                    <Outcome _EN_explanation="That's incorrect, because ${X.class()} doesn't need a left operand."
                             _EN_nextStepExplanation="That's incorrect. If it doesn't need a left operand, then the left operand can't prevent its further evaluation."
                             _EN_nextStepQuestion="What is the next reasoning step if we know that ${X.class()} doesn't need a left operand?"
                             _RU_explanation="Это неверно. ${X.class()}[case='и'] не имеет (не требует) левого операнда."
                             _RU_nextStepExplanation="Это неверно. Если оператор не имеет левого операнда, то и дальнейших вычислений его левый операнд требовать не может."
                             _RU_nextStepQuestion="Какие выводы можно сделать, если ${X}[case='и'] не требует левого операнда?"
                             _TEMPLATING_ID="21" value="false">
                        <BranchResultNode _EN_explanation="it does not have a left operand"
                                          _RU_explanation="он не имеет левого операнда" _TEMPLATING_ID="22"
                                          _skill="left_operand_needed" value="CORRECT"/>
                    </Outcome>
                    <Outcome _EN_explanation="That's incorrect, because ${X.class()} does require a left operand."
                             _EN_nextStepExplanation="That's incorrect. From here, one should check if there are any operators that should still be evaluated in the left operand, and then reason based on that."
                             _EN_nextStepQuestion="What is the next reasoning step if we know that ${X.class()} needs a left operand?"
                             _RU_explanation="Это неверно. ${X.class()}[case='д'] всегда необходим левый операнд."
                             _RU_nextStepExplanation="Это неверно. Необходимо дальше рассмотреть потенциально конкурирующие с ${X}[case='т'] операторы, и делать выводы исходя из их наличия/отсутствия."
                             _RU_nextStepQuestion="Какие выводы можно сделать, если ${X}[case='д'] нужен левый операнд?"
                             _TEMPLATING_ID="23" value="true">
                        <FindActionNode
                                _EN_asNextStep="We should look for an unevaluated operator that could be in the left operand of ${X}, preventing its further evaluation."
                                _EN_endingCause="Because there are only evaluated operators to the left of ${X}."
                                _EN_question="Find an operator that could be in the left operand of ${X}, preventing its further evaluation?"
                                _RU_asNextStep="Необходимо найти потенциально мешающий оператор слева от ${X}[case='р']"
                                _RU_endingCause="Потому что слева от ${X} находятся только вычисленные операторы"
                                _RU_question="Какой оператор может помешать выполнению ${X}[case='р'] слева?"
                                _TEMPLATING_ID="24" _alias="left.findY">
                            <DecisionTreeVarDecl name="Y1" type="token"/>
                            <Expression>
                                <GetExtreme extremeVarName="y1_ex" type="token" varName="y1">
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <LogicalAnd>
                                                <CheckClass>
                                                    <Variable name="y1"/>
                                                    <Class name="token"/>
                                                </CheckClass>
                                                <CheckRelationship relationshipName="leftOf">
                                                    <Variable name="y1"/>
                                                    <DecisionTreeVar name="X"/>
                                                </CheckRelationship>
                                            </LogicalAnd>
                                            <LogicalAnd>
                                                <CheckClass>
                                                    <GetByRelationship relationshipName="belongsTo">
                                                        <Variable name="y1"/>
                                                    </GetByRelationship>
                                                    <Class name="operator"/>
                                                </CheckClass>
                                                <Compare operator="Equal">
                                                    <GetPropertyValue propertyName="state">
                                                        <GetByRelationship relationshipName="belongsTo">
                                                            <Variable name="y1"/>
                                                        </GetByRelationship>
                                                    </GetPropertyValue>
                                                    <Enum owner="state" value="unevaluated"/>
                                                </Compare>
                                            </LogicalAnd>
                                        </LogicalAnd>
                                        <LogicalNot>
                                            <ExistenceQuantifier type="separator" varName="commaSep">
                                                <CheckRelationship relationshipName="isBetween">
                                                    <Variable name="commaSep"/>
                                                    <Variable name="y1"/>
                                                    <DecisionTreeVar name="X"/>
                                                </CheckRelationship>
                                                <LogicalNot>
                                                    <ExistenceQuantifier type="token" varName="f1">
                                                        <CheckClass>
                                                            <GetByRelationship relationshipName="belongsTo">
                                                                <Variable name="f1"/>
                                                            </GetByRelationship>
                                                            <Class name="operator"/>
                                                        </CheckClass>
                                                        <ExistenceQuantifier type="token" varName="f2">
                                                            <Compare operator="Equal">
                                                                <GetByRelationship relationshipName="belongsTo">
                                                                    <Variable name="f2"/>
                                                                </GetByRelationship>
                                                                <GetByRelationship relationshipName="belongsTo">
                                                                    <Variable name="f1"/>
                                                                </GetByRelationship>
                                                            </Compare>
                                                            <LogicalAnd>
                                                                <LogicalAnd>
                                                                    <CheckRelationship relationshipName="isBetween">
                                                                        <Variable name="commaSep"/>
                                                                        <Variable name="f1"/>
                                                                        <Variable name="f2"/>
                                                                    </CheckRelationship>
                                                                    <CheckRelationship relationshipName="isBetween">
                                                                        <Variable name="f1"/>
                                                                        <Variable name="y1"/>
                                                                        <DecisionTreeVar name="X"/>
                                                                    </CheckRelationship>
                                                                </LogicalAnd>
                                                                <CheckRelationship relationshipName="isBetween">
                                                                    <Variable name="f2"/>
                                                                    <Variable name="y1"/>
                                                                    <DecisionTreeVar name="X"/>
                                                                </CheckRelationship>
                                                            </LogicalAnd>
                                                        </ExistenceQuantifier>
                                                    </ExistenceQuantifier>
                                                </LogicalNot>
                                            </ExistenceQuantifier>
                                        </LogicalNot>
                                    </LogicalAnd>
                                    <CheckRelationship relationshipName="isBetween">
                                        <Variable name="y1_ex"/>
                                        <Variable name="y1"/>
                                        <DecisionTreeVar name="X"/>
                                    </CheckRelationship>
                                </GetExtreme>
                            </Expression>
                            <FindError _EN_explanation="That's incorrect, because ${$checked} is to the right of ${X}."
                                       _RU_explanation="Это неверно, поскольку ${$checked}[case='и'] находится справа от ${X}[case='р']."
                                       _TEMPLATING_ID="25" _alias="Y1_wrongSide" priority="1">
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked"/>
                                                <Class name="token"/>
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship relationshipName="rightOf">
                                            <Variable name="checked"/>
                                            <DecisionTreeVar name="X"/>
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError
                                    _EN_explanation="That's incorrect, as ${$checked} is omitted by an operator with a strict operand order (can you tell which one?), and therefore cannot prevent the evaluation of ${X}."
                                    _RU_explanation="Это неверно, поскольку ${$checked}[case='и'] опускается оператором со строгим порядком операндов (можете сказать, каким?), а значит не может помешать вычислению ${X}[case='р']."
                                    _TEMPLATING_ID="26" _alias="Y1_omitted" priority="2">
                                <Expression>
                                    <LogicalAnd>
                                        <CheckClass>
                                            <Variable name="checked"/>
                                            <Class name="token"/>
                                        </CheckClass>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                            <Compare operator="Equal">
                                                <GetPropertyValue propertyName="state">
                                                    <GetByRelationship relationshipName="belongsTo">
                                                        <Variable name="checked"/>
                                                    </GetByRelationship>
                                                </GetPropertyValue>
                                                <Enum owner="state" value="omitted"/>
                                            </Compare>
                                        </LogicalAnd>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError
                                    _EN_explanation="That's incorrect - ${$checked} is already evaluated and now serves as just an operand, and therefore cannot prevent the evaluation of ${X}."
                                    _RU_explanation="Это неверно - ${$checked}[case='и'] уже вычислен и по сути является операндом, а значит не может помешать вычислению ${X}[case='р']."
                                    _TEMPLATING_ID="27" _alias="Y1_evaluated" priority="3">
                                <Expression>
                                    <LogicalAnd>
                                        <CheckClass>
                                            <Variable name="checked"/>
                                            <Class name="token"/>
                                        </CheckClass>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                            <Compare operator="NotEqual">
                                                <GetPropertyValue propertyName="state">
                                                    <GetByRelationship relationshipName="belongsTo">
                                                        <Variable name="checked"/>
                                                    </GetByRelationship>
                                                </GetPropertyValue>
                                                <Enum owner="state" value="unevaluated"/>
                                            </Compare>
                                        </LogicalAnd>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError
                                    _EN_explanation="That might be true, but there is a fitting operator closer to the ${X} than ${$checked} and it should be considered first."
                                    _RU_explanation="Это неверно, ${$checked}[case='и'] слишком далеко от ${X}[case='р'] чтобы помешать ему."
                                    _TEMPLATING_ID="28" _alias="Y1_tooFar" priority="4">
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked"/>
                                                <Class name="token"/>
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship relationshipName="isBetween">
                                            <DecisionTreeVar name="Y1"/>
                                            <DecisionTreeVar name="X"/>
                                            <Variable name="checked"/>
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <AdditionalVarDecl name="Y" type="operator">
                                <Expression>
                                    <Cast>
                                        <GetByRelationship relationshipName="belongsTo">
                                            <DecisionTreeVar name="Y1"/>
                                        </GetByRelationship>
                                        <Class name="operator"/>
                                    </Cast>
                                </Expression>
                            </AdditionalVarDecl>
                            <Outcome _EN_explanation="there are no unevaluated operators to the left of ${X}"
                                     _EN_nextStepExplanation="That's incorrect. If the expression to the left of the ${X} is already evaluated, then the left operand of ${X} is fully evaluated. Therefore, it is not preventing its further evaluation."
                                     _EN_nextStepQuestion="What is the next reasoning step if we know that there are only evaluated operators to the left of ${X}?"
                                     _RU_explanation="слева от ${X}[case='р'] нет потенциально мешающих операторов"
                                     _RU_nextStepExplanation="Это неверно. Если все выражение слева от ${X}[case='р'] вычислено, значит и его левый операнд вычислен и не мешает вычислению ${X}[case='р']."
                                     _RU_nextStepQuestion="Какие выводы можно сделать, если слева от ${X}[case='р'] находятся только вычисленные операторы?"
                                     _TEMPLATING_ID="29" value="false">
                                <BranchResultNode
                                        _EN_explanation="all operators to the left of it have been already evaluated or omitted."
                                        _RU_explanation="все операторы слева от него уже вычислены или опущены."
                                        _TEMPLATING_ID="30" _skill="left_competing_operator_present" value="CORRECT"/>
                            </Outcome>
                            <Outcome
                                    _EN_explanation="there is a potentially blocking operator to the left of ${X} - it's ${Y}"
                                    _EN_nextStepBranchResult="The one on the ${$branchResult == BranchResult:CORRECT ? 'right' : 'left'} is always evaluated first"
                                    _EN_nextStepExplanation="That's incorrect. One should first determine if parentheses have any effect on the precedence of the two operators."
                                    _EN_nextStepQuestion="How should one determine the order of evaluation between two operators?"
                                    _RU_explanation="слева от ${X}[case='р'] есть потенциально мешающий оператор - это ${Y}[case='и']"
                                    _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'Правый' : 'Левый'} оператор всегда выполняется первым"
                                    _RU_nextStepExplanation="Это неверно. Определение порядка вычислений двух операторов надо начинать с рассмотрения влияния скобок на их приоритет."
                                    _RU_nextStepQuestion="Как определяется порядок вычисления двух конкурирующих операторов?"
                                    _TEMPLATING_ID="31" value="true">
                                <QuestionNode _EN_asNextStep="We should check if ${X} is inside ${Y}"
                                              _EN_endingCause="Because ${X} is inside ${Y}"
                                              _EN_question="Is ${X} inside ${Y}?"
                                              _RU_asNextStep="Необходимо проверить, находится ли ${X}[case='и'] внутри ${Y}[case='р']"
                                              _RU_endingCause="Потому что ${X} находится внутри ${Y}[case='р']"
                                              _RU_question="Верно ли, что ${X}[case='и'] находится внутри ${Y}[case='р']?"
                                              _TEMPLATING_ID="32" _alias="left.isXinY">
                                    <Expression>
                                        <ExistenceQuantifier type="token" varName="y2">
                                            <LogicalAnd>
                                                <LogicalAnd>
                                                    <CheckClass>
                                                        <Variable name="y2"/>
                                                        <Class name="token"/>
                                                    </CheckClass>
                                                    <CheckRelationship relationshipName="belongsTo">
                                                        <Variable name="y2"/>
                                                        <DecisionTreeVar name="Y"/>
                                                    </CheckRelationship>
                                                </LogicalAnd>
                                                <Compare operator="NotEqual">
                                                    <Variable name="y2"/>
                                                    <DecisionTreeVar name="Y1"/>
                                                </Compare>
                                            </LogicalAnd>
                                            <CheckRelationship relationshipName="isBetween">
                                                <DecisionTreeVar name="X"/>
                                                <DecisionTreeVar name="Y1"/>
                                                <Variable name="y2"/>
                                            </CheckRelationship>
                                        </ExistenceQuantifier>
                                    </Expression>
                                    <Outcome _EN_nextStepExplanation="That's incorrect."
                                             _EN_nextStepQuestion="What can we now conclude?"
                                             _RU_nextStepExplanation="Это неверно."
                                             _RU_nextStepQuestion="Какие выводы можно сделать на данном этапе?"
                                             _TEMPLATING_ID="33" value="true">
                                        <BranchResultNode
                                                _EN_explanation="it is wrapped by the closest ${Y} to its left"
                                                _RU_explanation="он заключен в ближайший оператор слева от него - ${Y}[case='и']"
                                                _TEMPLATING_ID="34" _skill="left_operator_enclosed" value="CORRECT"/>
                                    </Outcome>
                                    <Outcome _EN_nextStepExplanation="That's incorrect."
                                             _EN_nextStepQuestion="What can we now conclude?"
                                             _RU_nextStepExplanation="Это неверно."
                                             _RU_nextStepQuestion="Какие выводы можно сделать на данном этапе?"
                                             _TEMPLATING_ID="35" value="false">
                                        <BranchAggregationNode
                                                _EN_asNextStep="We should check if parentheses have any effect on the precedence of the two operators."
                                                _EN_endingCause="Because of the effect of the parentheses"
                                                _EN_question="How do parentheses affect the evaluation of ${X} and ${Y}?"
                                                _RU_asNextStep="Необходимо рассмотреть влияние скобок на взаимодействие между ${X}[case='т'] и ${Y}[case='т']."
                                                _RU_endingCause="Из-за роли скобок в выражении"
                                                _RU_question="Как скобки влияют на взаимодействие между ${X}[case='т'] и ${Y}[case='т']?"
                                                _TEMPLATING_ID="36" _alias="left.predetermining" operator="MUTEX">
                                            <ThoughtBranch
                                                    _EN_description_correct="${X} is inside of parenthesis, and ${Y} is outside of them"
                                                    _EN_description_null="there are no parenthesis that enclose ${X} but not ${Y}"
                                                    _RU_description_correct="${X} находится в скобках, а ${Y} - за их пределами"
                                                    _RU_description_null="не существует скобок, окружающих ${X}, но не окружающих ${Y}[case='в']"
                                                    _TEMPLATING_ID="37" _alias="left.predetermining.2">
                                                <QuestionNode
                                                        _EN_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${X}, но не ${Y}"
                                                        _EN_endingCause="Потому что существуют скобки, окружающие ${X}, но не ${Y}"
                                                        _EN_question="Существуют ли скобки, окружающие ${X}, но не ${Y}?"
                                                        _RU_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${X}[case='и'], но не ${Y}[case='и']"
                                                        _RU_endingCause="Потому что существуют скобки, окружающие ${X}, но не ${Y}"
                                                        _RU_question="Существуют ли скобки, окружающие ${X}[case='и'], но не ${Y}[case='и']?"
                                                        _TEMPLATING_ID="38"
                                                        _alias="left.predetermining.2.isXinParenthesis">
                                                    <Expression>
                                                        <ExistenceQuantifier type="parenthesis" varName="p">
                                                            <CheckClass>
                                                                <Variable name="p"/>
                                                                <Class name="parenthesis"/>
                                                            </CheckClass>
                                                            <ExistenceQuantifier type="token" varName="p1">
                                                                <CheckRelationship relationshipName="belongsTo">
                                                                    <Variable name="p1"/>
                                                                    <Variable name="p"/>
                                                                </CheckRelationship>
                                                                <ExistenceQuantifier type="token" varName="p2">
                                                                    <CheckRelationship relationshipName="belongsTo">
                                                                        <Variable name="p2"/>
                                                                        <Variable name="p"/>
                                                                    </CheckRelationship>
                                                                    <LogicalAnd>
                                                                        <CheckRelationship relationshipName="isBetween">
                                                                            <DecisionTreeVar name="X"/>
                                                                            <Variable name="p1"/>
                                                                            <Variable name="p2"/>
                                                                        </CheckRelationship>
                                                                        <LogicalNot>
                                                                            <CheckRelationship
                                                                                    relationshipName="isBetween">
                                                                                <DecisionTreeVar name="Y"/>
                                                                                <Variable name="p1"/>
                                                                                <Variable name="p2"/>
                                                                            </CheckRelationship>
                                                                        </LogicalNot>
                                                                    </LogicalAnd>
                                                                </ExistenceQuantifier>
                                                            </ExistenceQuantifier>
                                                        </ExistenceQuantifier>
                                                    </Expression>
                                                    <Outcome value="false">
                                                        <BranchResultNode value="NULL"/>
                                                    </Outcome>
                                                    <Outcome value="true">
                                                        <BranchResultNode
                                                                _EN_explanation="it is inside parentheses, while the closest ${Y} to its left lies outside them."
                                                                _RU_explanation="он находится в скобках, а ближайший к нему слева ${Y} находится за их пределами."
                                                                _TEMPLATING_ID="39"
                                                                _skill="is_current_parenthesized_left_not"
                                                                value="CORRECT"/>
                                                    </Outcome>
                                                </QuestionNode>
                                            </ThoughtBranch>
                                            <ThoughtBranch
                                                    _EN_description_error="${Y} is inside of parenthesis, and ${X} is outside of them"
                                                    _EN_description_null="there are no parenthesis that enclose ${Y} but not ${X}"
                                                    _RU_description_error="${Y} находится в скобках, а ${X} - за их пределами"
                                                    _RU_description_null="не существует скобок, окружающих ${Y}, но не окружающих ${X}[case='в']"
                                                    _TEMPLATING_ID="40" _alias="left.predetermining.3">
                                                <QuestionNode
                                                        _EN_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${Y}, но не ${X}"
                                                        _EN_endingCause="Потому что существуют скобки, окружающие ${Y}, но не ${X}"
                                                        _EN_question="Существуют ли скобки, окружающие ${Y}, но не ${X}?"
                                                        _RU_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${Y}[case='и'], но не ${X}[case='в']"
                                                        _RU_endingCause="Потому что существуют скобки, окружающие ${Y}, но не ${X}"
                                                        _RU_question="Существуют ли скобки, окружающие ${Y}[case='и'], но не ${X}[case='в']?"
                                                        _TEMPLATING_ID="41"
                                                        _alias="left.predetermining.3.isYinParenthesis">
                                                    <Expression>
                                                        <ExistenceQuantifier type="parenthesis" varName="p">
                                                            <CheckClass>
                                                                <Variable name="p"/>
                                                                <Class name="parenthesis"/>
                                                            </CheckClass>
                                                            <ExistenceQuantifier type="token" varName="p1">
                                                                <CheckRelationship relationshipName="belongsTo">
                                                                    <Variable name="p1"/>
                                                                    <Variable name="p"/>
                                                                </CheckRelationship>
                                                                <ExistenceQuantifier type="token" varName="p2">
                                                                    <CheckRelationship relationshipName="belongsTo">
                                                                        <Variable name="p2"/>
                                                                        <Variable name="p"/>
                                                                    </CheckRelationship>
                                                                    <LogicalAnd>
                                                                        <CheckRelationship relationshipName="isBetween">
                                                                            <DecisionTreeVar name="Y"/>
                                                                            <Variable name="p1"/>
                                                                            <Variable name="p2"/>
                                                                        </CheckRelationship>
                                                                        <LogicalNot>
                                                                            <CheckRelationship
                                                                                    relationshipName="isBetween">
                                                                                <DecisionTreeVar name="X"/>
                                                                                <Variable name="p1"/>
                                                                                <Variable name="p2"/>
                                                                            </CheckRelationship>
                                                                        </LogicalNot>
                                                                    </LogicalAnd>
                                                                </ExistenceQuantifier>
                                                            </ExistenceQuantifier>
                                                        </ExistenceQuantifier>
                                                    </Expression>
                                                    <Outcome value="false">
                                                        <BranchResultNode value="NULL"/>
                                                    </Outcome>
                                                    <Outcome value="true">
                                                        <BranchResultNode
                                                                _EN_explanation="${Y} on its left must be evaluated first because ${Y} is in parentheses."
                                                                _RU_explanation="сначала должен быть вычислен ${Y} слева от него, так как ${Y} окружен круглыми скобками."
                                                                _TEMPLATING_ID="42" _error="left.parenthesis"
                                                                _law="error_base_student_error_in_complex;error_base_parenthesized_operators"
                                                                _skill="is_left_parenthesized_current_not"
                                                                value="ERROR"/>
                                                    </Outcome>
                                                </QuestionNode>
                                            </ThoughtBranch>
                                            <Outcome
                                                    _EN_nextStepBranchResult="The operator on the ${$branchResult == BranchResult:CORRECT ? 'right' : 'left'} is always evaluated first."
                                                    _EN_nextStepExplanation="That's incorrect. In the absence of parentheses' effect, the order of evaluation is determined by the precedence of the operators - so it should be considered next."
                                                    _EN_nextStepQuestion="In the absence of parentheses' effect, how should one determine the order of evaluation between two operator?"
                                                    _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'Правый' : 'Левый'} оператор всегда выполняется первым"
                                                    _RU_nextStepExplanation="Это неверно. В отсутствии скобок, порядок выполнения стоящих рядом операторов определяется их приоритетом - его и надо рассматривать следующим."
                                                    _RU_nextStepQuestion="В отсутствии влияния скобок, как определяется порядок выполнения стоящих рядом операторов?"
                                                    _TEMPLATING_ID="43" value="NULL">
                                                <QuestionNode
                                                        _EN_asNextStep="We should compare the precedence of ${X.class()} and ${Y.class()}."
                                                        _EN_endingCause="Because of the precedences of ${X.class()} and ${Y.class()}."
                                                        _EN_question="Compare the precedence of ${X.class()} and ${Y.class()}."
                                                        _EN_triviality="The precedence of ${X} and ${Y} is obviously the same, since they are the same operator."
                                                        _RU_asNextStep="Необходимо сравнить приоритеты ${X.class()}[case='р'] и ${Y.class()}[case='р']"
                                                        _RU_endingCause="Из-за соотношения приоритетов ${X.class()}[case='р'] и ${Y.class()}[case='р']"
                                                        _RU_question="Сравните приоритеты ${X.class()}[case='р'] и ${Y.class()}[case='р']"
                                                        _RU_triviality="Приоритеты ${X}[case='р'] и ${Y}[case='р'] очевидно равны, так как это один и тот же оператор."
                                                        _TEMPLATING_ID="44" _alias="left.precedence">
                                                    <Triviality>
                                                        <Compare operator="Equal">
                                                            <GetClass>
                                                                <DecisionTreeVar name="X"/>
                                                            </GetClass>
                                                            <GetClass>
                                                                <DecisionTreeVar name="Y"/>
                                                            </GetClass>
                                                        </Compare>
                                                    </Triviality>
                                                    <Expression>
                                                        <Compare>
                                                            <GetPropertyValue propertyName="precedence">
                                                                <DecisionTreeVar name="X"/>
                                                            </GetPropertyValue>
                                                            <GetPropertyValue propertyName="precedence">
                                                                <DecisionTreeVar name="Y"/>
                                                            </GetPropertyValue>
                                                        </Compare>
                                                    </Expression>
                                                    <Outcome
                                                            _EN_explanation="That's incorrect, because ${X.class()} has higher precedence than ${Y.class()}."
                                                            _EN_nextStepBranchResult="Operator with a ${$branchResult == BranchResult:CORRECT ? 'higher' : 'lower'} precedence is always evaluated first"
                                                            _EN_nextStepExplanation="That's incorrect. The operator with a higher precedence is always evaluated first. Therefore, in this case, the ${X} should be evaluated first, and we can conclude that its left operand does not prevent its evaluation."
                                                            _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have different precedences?"
                                                            _EN_text="${X.class()} has higher precedence."
                                                            _RU_explanation="Это неверно, поскольку ${X.class()}[case='и'] имеет больший приоритет, чем ${Y.class()}[case='и']."
                                                            _RU_nextStepBranchResult="Оператор с ${$branchResult == BranchResult:CORRECT ? 'большим' : 'меньшим'} приоритетом всегда выполняется первым"
                                                            _RU_nextStepExplanation="Это неверно. Оператор с большим приоритетом всегда выполняется первым. Т.к. ${X.class()}[case='и'] имеет больший приоритет, а значит может быть вычислен первым. Получается, левый операнд ${X}[case='и'] не требует дальнейших вычислений."
                                                            _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих разные приоритеты?"
                                                            _RU_text="Приоритет ${X.class()}[case='р'] больше."
                                                            _TEMPLATING_ID="45" value="Comparison:less">
                                                        <BranchResultNode
                                                                _EN_explanation="it has a higher precedence than ${Y}."
                                                                _RU_explanation="он имеет приоритет выше, чем ${Y}[case='в']."
                                                                _TEMPLATING_ID="46"
                                                                _skill="right_competing_to_left_precedence"
                                                                value="CORRECT"/>
                                                    </Outcome>
                                                    <Outcome
                                                            _EN_explanation="That's incorrect, because ${Y.class()} has higher precedence than ${X.class()}."
                                                            _EN_nextStepBranchResult="Operator with a ${$branchResult == BranchResult:CORRECT ? 'lower' : 'higher'} precedence is always evaluated first"
                                                            _EN_nextStepExplanation="That's incorrect. The operator with a higher precedence is always evaluated first. Therefore, in this case, the ${Y} should be evaluated first, and we can conclude that the left operand of ${X} does prevent its evaluation."
                                                            _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have different precedences?"
                                                            _EN_text="${Y.class()} has higher precedence."
                                                            _RU_explanation="Это неверно, поскольку ${Y.class()}[case='и'] имеет больший приоритет, чем ${X.class()}[case='и']."
                                                            _RU_nextStepBranchResult="Оператор с ${$branchResult == BranchResult:CORRECT ? 'меньшим' : 'большим'} приоритетом всегда выполняется первым"
                                                            _RU_nextStepExplanation="Это неверно. Оператор с большим приоритетом всегда выполняется первым. Т.к. ${Y.class()}[case='и'] имеет больший приоритет, он должен быть вычислен первым. Получается, левый операнд ${X}[case='и'] требует дальнейших вычислений."
                                                            _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих разные приоритеты?"
                                                            _RU_text="Приоритет ${Y.class()}[case='р'] больше."
                                                            _TEMPLATING_ID="47" value="Comparison:greater">
                                                        <BranchResultNode
                                                                _EN_explanation="${Y} on its left must be evaluated first because it has a higher precedence."
                                                                _RU_explanation="сначала должен быть вычислен ${Y}[case='и'] слева от него, который имеет более высокий приоритет."
                                                                _TEMPLATING_ID="48" _error="left.precedence"
                                                                _law="error_base_higher_precedence_left"
                                                                _skill="right_competing_to_left_precedence"
                                                                value="ERROR"/>
                                                    </Outcome>
                                                    <Outcome
                                                            _EN_explanation="That's incorrect because ${X.class()} and ${Y.class()} have the same precedence."
                                                            _EN_nextStepBranchResult="The operator on the ${$branchResult == BranchResult:CORRECT ? 'right' : 'left'} is always evaluated first."
                                                            _EN_nextStepExplanation="That's incorrect. The order of evaluation between two operators that have the same precedence is determined by their associativity. Therefore we should next check the associativity of ${X.class()} and ${Y.class()}."
                                                            _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have the same precedence?"
                                                            _EN_text="They have the same precedence."
                                                            _RU_explanation="Это неверно, поскольку приоритеты ${X.class()}[case='р'] и ${Y.class()}[case='р'] одинаковы."
                                                            _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'Правый' : 'Левый'} оператор всегда выполняется первым"
                                                            _RU_nextStepExplanation="Это неверно. Порядок выполнения операторов, имеющих одинаковые приоритеты, задается ассоциативностью, а значит следующим шагом необходимо проверить ассоциативность ${X.class()}[case='р'] и ${Y.class()}[case='р']."
                                                            _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих равные приоритеты?"
                                                            _RU_text="Их приоритеты одинаковы." _TEMPLATING_ID="49"
                                                            value="Comparison:equal">
                                                        <QuestionNode
                                                                _EN_asNextStep="We should check if ${X} needs a right operand."
                                                                _EN_endingCause="Because ${X} doesn't need a right operand."
                                                                _EN_question="Does ${X.class()} need a right operand?"
                                                                _RU_asNextStep="Необходимо проверить, нужен ли ${X}[case='д'] правый операнд."
                                                                _RU_endingCause="Потому что ${X} не требует правого операнда"
                                                                _RU_question="Нужен ли ${X.class()}[case='д'] правый операнд?"
                                                                _TEMPLATING_ID="50" _alias="rightOperandAssoc.isNeeded">
                                                            <Expression>
                                                                <GetPropertyValue propertyName="needsOperand">
                                                                    <DecisionTreeVar name="X"/>
                                                                    <ParamsValues type="ordered">
                                                                        <Enum owner="OperandPlacement" value="right"/>
                                                                    </ParamsValues>
                                                                </GetPropertyValue>
                                                            </Expression>
                                                            <Outcome
                                                                    _EN_explanation="That's incorrect, because ${X.class()} doesn't need a right operand."
                                                                    _EN_nextStepExplanation="That's incorrect. If it doesn't need a right operand, then the right operand can't prevent its further evaluation."
                                                                    _EN_nextStepQuestion="What is the next reasoning step if we know that ${X.class()} doesn't need a right operand?"
                                                                    _RU_explanation="Это неверно. ${X.class()}[case='и'] не имеет (не требует) правого операнда."
                                                                    _RU_nextStepExplanation="Это неверно. Если оператор не имеет правого операнда, то и дальнейших вычислений его правый операнд требовать не может."
                                                                    _RU_nextStepQuestion="Какие выводы можно сделать, если ${X}[case='и'] не требует правого операнда?"
                                                                    _TEMPLATING_ID="51" value="false">
                                                                <BranchResultNode
                                                                        _EN_explanation="${Y} on its left must be evaluated first - these operators have the same precedence, but are evaluated from left to right (have left associativity)."
                                                                        _RU_explanation="имеет одинаковый приоритет с ${Y}[case='т'] и левую ассоциативность (вычисляются слева направо)."
                                                                        _TEMPLATING_ID="52"
                                                                        _skill="associativity_without_right_opposing_operand"
                                                                        value="ERROR"/>
                                                            </Outcome>
                                                            <Outcome
                                                                    _EN_explanation="That's incorrect, because ${X.class()} does require a right operand."
                                                                    _EN_nextStepExplanation="That's incorrect. From here, one should check if there are any operators that should still be evaluated in the right operand, and then reason based on that."
                                                                    _EN_nextStepQuestion="What is the next reasoning step if we know that ${X.class()} needs a right operand?"
                                                                    _RU_explanation="Это неверно. ${X.class()}[case='д'] всегда необходим правый операнд."
                                                                    _RU_nextStepExplanation="Это неверно. Необходимо дальше рассмотреть потенциально конкурирующие с ${X}[case='т'] операторы, и делать выводы исходя из их наличия/отсутствия."
                                                                    _RU_nextStepQuestion="Какие выводы можно сделать, если ${X}[case='д'] нужен правый операнд?"
                                                                    _TEMPLATING_ID="53" value="true">
                                                                <QuestionNode
                                                                        _EN_asNextStep="We should determine the associativity of ${X.class()} and ${Y.class()}"
                                                                        _EN_endingCause="Because of the associativity of ${X.class()} and ${Y.class()}"
                                                                        _EN_question="What's the associativity of ${X.class()} and ${Y.class()}?"
                                                                        _RU_asNextStep="Необходимо проверить, какова ассоциативность ${X.class()}[case='р'] и ${Y.class()}[case='р']"
                                                                        _RU_endingCause="Из-за ассоциативности ${X.class()} и ${Y.class()}"
                                                                        _RU_question="Какова ассоциативность ${X.class()}[case='р'] и ${Y.class()}[case='р']?"
                                                                        _TEMPLATING_ID="54" _alias="left.associativity">
                                                                    <Expression>
                                                                        <GetPropertyValue propertyName="associativity">
                                                                            <DecisionTreeVar name="Y"/>
                                                                        </GetPropertyValue>
                                                                    </Expression>
                                                                    <Outcome
                                                                            _EN_explanation="That's incorrect, because ${X.class()} and ${Y.class()} have left associativity."
                                                                            _EN_nextStepBranchResult="The one on the ${$branchResult == BranchResult:CORRECT ? 'right' : 'left'}"
                                                                            _EN_nextStepExplanation="That's incorrect. Operators that have left associativity evaluate from left to right. Therefore, in this case, ${Y.class()} should be evaluated first, and we can conclude that the left operand of ${X} does prevent its evaluation."
                                                                            _EN_nextStepQuestion="Which of the two nearby operators evaluates first if they have left associativity?"
                                                                            _EN_text="left"
                                                                            _RU_explanation="Это неверно, поскольку ${X.class()}[case='и'] и ${Y.class()}[case='и'] имеют левую ассоциативность."
                                                                            _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'Правый' : 'Левый'}"
                                                                            _RU_nextStepExplanation="Это неверно. При левой ассоциативности операторы выполняются слева направо. В данном случае это значит, ${Y.class()}[case='и'] должен быть вычислен первым. Получается, левый операнд ${X}[case='и'] требует дальнейших вычислений."
                                                                            _RU_nextStepQuestion="Какой из двух рядом стоящих операторов выполнится первым, если операторы имеют левую ассоциативность?"
                                                                            _RU_text="левая" _TEMPLATING_ID="55"
                                                                            value="associativity:left">
                                                                        <BranchResultNode
                                                                                _EN_explanation="${Y} on its left must be evaluated first - these operators have the same precedence, but are evaluated from left to right (have left associativity)."
                                                                                _RU_explanation="имеет одинаковый приоритет с ${Y}[case='т'] и левую ассоциативность (вычисляются слева направо)."
                                                                                _TEMPLATING_ID="56"
                                                                                _error="left.associativity"
                                                                                _law="error_base_same_precedence_left_associativity_left"
                                                                                _skill="right_competing_to_left_associativity"
                                                                                value="ERROR"/>
                                                                    </Outcome>
                                                                    <Outcome
                                                                            _EN_explanation="That's incorrect, because ${X.class()} and ${Y.class()} have right associativity."
                                                                            _EN_nextStepBranchResult="The one on the ${$branchResult == BranchResult:CORRECT ? 'right' : 'left'}"
                                                                            _EN_nextStepExplanation="That's incorrect. Operators that have right associativity evaluate from right to left. Therefore, in this case, ${X.class()} should be evaluated first, anand we can conclude that its left operand does not prevent its evaluation."
                                                                            _EN_nextStepQuestion="Which of the two nearby operators evaluates first if they have right associativity?"
                                                                            _EN_text="right"
                                                                            _RU_explanation="Это неверно, поскольку ${X.class()}[case='и'] и ${Y.class()}[case='и'] имеют правую ассоциативность."
                                                                            _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'Правый' : 'Левый'}"
                                                                            _RU_nextStepExplanation="Это неверно. При правой ассоциативности операторы выполняются справа налево. В данном случае это значит, что ${X.class()}[case='и'] должен быть вычислен первым. Получается, левый операнд ${X}[case='р'] не требует дальнейших вычислений."
                                                                            _RU_nextStepQuestion="Какой из двух рядом стоящих операторов выполнится первым, если операторы имеют правую ассоциативность?"
                                                                            _RU_text="правая" _TEMPLATING_ID="57"
                                                                            value="associativity:right">
                                                                        <BranchResultNode
                                                                                _EN_explanation="it has the same precedence as ${Y} and right associativity."
                                                                                _RU_explanation="имеет одинаковый приоритет с ${Y}[case='т'] и правую ассоциативность (вычисляются справа налево)."
                                                                                _TEMPLATING_ID="58"
                                                                                _skill="right_competing_to_left_associativity"
                                                                                value="CORRECT"/>
                                                                    </Outcome>
                                                                </QuestionNode>
                                                            </Outcome>
                                                        </QuestionNode>
                                                    </Outcome>
                                                </QuestionNode>
                                            </Outcome>
                                        </BranchAggregationNode>
                                    </Outcome>
                                </QuestionNode>
                            </Outcome>
                        </FindActionNode>
                    </Outcome>
                </QuestionNode>
            </ThoughtBranch>
            <ThoughtBranch
                    _EN_description="right operand of ${X} ${$branchResult == BranchResult:CORRECT ? 'doesnt require' : 'requires'} further evaluation"
                    _EN_nextStepExplanation="That's incorrect. One should first check if the operator needs right operand at all."
                    _EN_nextStepQuestion="What is the first step when considering operator's right operand?"
                    _RU_description="правый операнд ${X}[case='р'] ${$branchResult == BranchResult:CORRECT ? 'не' : ''} требует дальнейших вычислений"
                    _RU_nextStepExplanation="Это неверно. Прежде всего необходимо проверить, нужен ли оператору правый операнд."
                    _RU_nextStepQuestion="С чего надо начать при рассмотрении правого операнда?" _TEMPLATING_ID="59"
                    _alias="right">
                <QuestionNode _EN_asNextStep="We should check if ${X} needs a right operand."
                              _EN_endingCause="Because ${X} doesn't need a right operand."
                              _EN_question="Does ${X.class()} need a right operand?"
                              _RU_asNextStep="Необходимо проверить, нужен ли ${X}[case='д'] правый операнд."
                              _RU_endingCause="Потому что ${X} не требует правого операнда"
                              _RU_question="Нужен ли ${X.class()}[case='д'] правый операнд?" _TEMPLATING_ID="60"
                              _alias="right.isNeeded">
                    <Expression>
                        <GetPropertyValue propertyName="needsOperand">
                            <DecisionTreeVar name="X"/>
                            <ParamsValues type="ordered">
                                <Enum owner="OperandPlacement" value="right"/>
                            </ParamsValues>
                        </GetPropertyValue>
                    </Expression>
                    <Outcome _EN_explanation="That's incorrect, because ${X.class()} doesn't need a right operand."
                             _EN_nextStepExplanation="That's incorrect. If it doesn't need a right operand, then the right operand can't prevent its further evaluation."
                             _EN_nextStepQuestion="What is the next reasoning step if we know that ${X.class()} doesn't need a right operand?"
                             _RU_explanation="Это неверно. ${X.class()}[case='и'] не имеет (не требует) правого операнда."
                             _RU_nextStepExplanation="Это неверно. Если оператор не имеет правого операнда, то и дальнейших вычислений его правый операнд требовать не может."
                             _RU_nextStepQuestion="Какие выводы можно сделать, если ${X}[case='и'] не требует правого операнда?"
                             _TEMPLATING_ID="61" value="false">
                        <BranchResultNode _EN_explanation="it does not have a right operand"
                                          _RU_explanation="он не имеет правого операнда" _TEMPLATING_ID="62"
                                          _skill="right_operand_needed" value="CORRECT"/>
                    </Outcome>
                    <Outcome _EN_explanation="That's incorrect, because ${X.class()} does require a right operand."
                             _EN_nextStepExplanation="That's incorrect. From here, one should check if there are any operators that should still be evaluated in the right operand, and then reason based on that."
                             _EN_nextStepQuestion="What is the next reasoning step if we know that ${X.class()} needs a right operand?"
                             _RU_explanation="Это неверно. ${X.class()}[case='д'] всегда необходим правый операнд."
                             _RU_nextStepExplanation="Это неверно. Необходимо дальше рассмотреть потенциально конкурирующие с ${X}[case='т'] операторы, и делать выводы исходя из их наличия/отсутствия."
                             _RU_nextStepQuestion="Какие выводы можно сделать, если ${X}[case='д'] нужен правый операнд?"
                             _TEMPLATING_ID="63" value="true">
                        <FindActionNode
                                _EN_asNextStep="We should look for an unevaluated operator that could be in the right operand of ${X}, preventing its further evaluation."
                                _EN_endingCause="Because there are only evaluated operators to the right of ${X}."
                                _EN_question="Find an operator that could be in the right operand of ${X}, preventing its further evaluation?"
                                _RU_asNextStep="Необходимо найти потенциально мешающий оператор справа от ${X}[case='р']"
                                _RU_endingCause="Потому что справа от ${X} находятся только вычисленные операторы"
                                _RU_question="Какой оператор может помешать выполнению ${X}[case='р'] справа?"
                                _TEMPLATING_ID="64" _alias="right.findZ">
                            <DecisionTreeVarDecl name="Z1" type="token"/>
                            <Expression>
                                <GetExtreme extremeVarName="z1_ex" type="token" varName="z1">
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <LogicalAnd>
                                                <CheckClass>
                                                    <Variable name="z1"/>
                                                    <Class name="token"/>
                                                </CheckClass>
                                                <CheckRelationship relationshipName="rightOf">
                                                    <Variable name="z1"/>
                                                    <DecisionTreeVar name="X"/>
                                                </CheckRelationship>
                                            </LogicalAnd>
                                            <LogicalAnd>
                                                <CheckClass>
                                                    <GetByRelationship relationshipName="belongsTo">
                                                        <Variable name="z1"/>
                                                    </GetByRelationship>
                                                    <Class name="operator"/>
                                                </CheckClass>
                                                <Compare operator="Equal">
                                                    <GetPropertyValue propertyName="state">
                                                        <GetByRelationship relationshipName="belongsTo">
                                                            <Variable name="z1"/>
                                                        </GetByRelationship>
                                                    </GetPropertyValue>
                                                    <Enum owner="state" value="unevaluated"/>
                                                </Compare>
                                            </LogicalAnd>
                                        </LogicalAnd>
                                        <LogicalNot>
                                            <ExistenceQuantifier type="separator" varName="commaSep">
                                                <CheckRelationship relationshipName="isBetween">
                                                    <Variable name="commaSep"/>
                                                    <Variable name="z1"/>
                                                    <DecisionTreeVar name="X"/>
                                                </CheckRelationship>
                                                <LogicalNot>
                                                    <ExistenceQuantifier type="token" varName="f1">
                                                        <CheckClass>
                                                            <GetByRelationship relationshipName="belongsTo">
                                                                <Variable name="f1"/>
                                                            </GetByRelationship>
                                                            <Class name="operator"/>
                                                        </CheckClass>
                                                        <ExistenceQuantifier type="token" varName="f2">
                                                            <Compare operator="Equal">
                                                                <GetByRelationship relationshipName="belongsTo">
                                                                    <Variable name="f2"/>
                                                                </GetByRelationship>
                                                                <GetByRelationship relationshipName="belongsTo">
                                                                    <Variable name="f1"/>
                                                                </GetByRelationship>
                                                            </Compare>
                                                            <LogicalAnd>
                                                                <LogicalAnd>
                                                                    <CheckRelationship relationshipName="isBetween">
                                                                        <Variable name="commaSep"/>
                                                                        <Variable name="f1"/>
                                                                        <Variable name="f2"/>
                                                                    </CheckRelationship>
                                                                    <CheckRelationship relationshipName="isBetween">
                                                                        <Variable name="f1"/>
                                                                        <Variable name="z1"/>
                                                                        <DecisionTreeVar name="X"/>
                                                                    </CheckRelationship>
                                                                </LogicalAnd>
                                                                <CheckRelationship relationshipName="isBetween">
                                                                    <Variable name="f2"/>
                                                                    <Variable name="z1"/>
                                                                    <DecisionTreeVar name="X"/>
                                                                </CheckRelationship>
                                                            </LogicalAnd>
                                                        </ExistenceQuantifier>
                                                    </ExistenceQuantifier>
                                                </LogicalNot>
                                            </ExistenceQuantifier>
                                        </LogicalNot>
                                    </LogicalAnd>
                                    <CheckRelationship relationshipName="isBetween">
                                        <Variable name="z1_ex"/>
                                        <Variable name="z1"/>
                                        <DecisionTreeVar name="X"/>
                                    </CheckRelationship>
                                </GetExtreme>
                            </Expression>
                            <FindError _EN_explanation="That's incorrect, because ${$checked} is to the left of ${X}."
                                       _RU_explanation="Это неверно, поскольку ${$checked}[case='и'] находится слева от ${X}[case='р']."
                                       _TEMPLATING_ID="65" _alias="Z1_wrongSide" priority="1">
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked"/>
                                                <Class name="token"/>
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship relationshipName="leftOf">
                                            <Variable name="checked"/>
                                            <DecisionTreeVar name="X"/>
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError
                                    _EN_explanation="That's incorrect, as ${$checked} is omitted by an operator with a strict operand order (can you tell which one?), and therefore cannot prevent the evaluation of ${X}."
                                    _RU_explanation="Это неверно, поскольку ${$checked}[case='и'] опускается оператором со строгим порядком операндов (можете сказать, каким?), а значит не может помешать вычислению ${X}[case='р']."
                                    _TEMPLATING_ID="66" _alias="Z1_omitted" priority="2">
                                <Expression>
                                    <LogicalAnd>
                                        <CheckClass>
                                            <Variable name="checked"/>
                                            <Class name="token"/>
                                        </CheckClass>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                            <Compare operator="Equal">
                                                <GetPropertyValue propertyName="state">
                                                    <GetByRelationship relationshipName="belongsTo">
                                                        <Variable name="checked"/>
                                                    </GetByRelationship>
                                                </GetPropertyValue>
                                                <Enum owner="state" value="omitted"/>
                                            </Compare>
                                        </LogicalAnd>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError
                                    _EN_explanation="That's incorrect - ${$checked} is already evaluated and now serves as just an operand, and therefore cannot prevent the evaluation of ${X}."
                                    _RU_explanation="Это неверно - ${$checked}[case='и'] уже вычислен и по сути является операндом, а значит не может помешать вычислению ${X}[case='р']."
                                    _TEMPLATING_ID="67" _alias="Z1_evaluated" priority="3">
                                <Expression>
                                    <LogicalAnd>
                                        <CheckClass>
                                            <Variable name="checked"/>
                                            <Class name="token"/>
                                        </CheckClass>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                            <Compare operator="NotEqual">
                                                <GetPropertyValue propertyName="state">
                                                    <GetByRelationship relationshipName="belongsTo">
                                                        <Variable name="checked"/>
                                                    </GetByRelationship>
                                                </GetPropertyValue>
                                                <Enum owner="state" value="unevaluated"/>
                                            </Compare>
                                        </LogicalAnd>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError
                                    _EN_explanation="That might be true, but there is a fitting operator closer to the ${X} than ${$checked} and it should be considered first."
                                    _RU_explanation="Это неверно, ${$checked}[case='и'] слишком далеко от ${X}[case='р'] чтобы помешать ему."
                                    _TEMPLATING_ID="68" _alias="Z1_tooFar" priority="4">
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked"/>
                                                <Class name="token"/>
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship relationshipName="belongsTo">
                                                    <Variable name="checked"/>
                                                </GetByRelationship>
                                                <Class name="operator"/>
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship relationshipName="isBetween">
                                            <DecisionTreeVar name="Z1"/>
                                            <DecisionTreeVar name="X"/>
                                            <Variable name="checked"/>
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <AdditionalVarDecl name="Z" type="operator">
                                <Expression>
                                    <Cast>
                                        <GetByRelationship relationshipName="belongsTo">
                                            <DecisionTreeVar name="Z1"/>
                                        </GetByRelationship>
                                        <Class name="operator"/>
                                    </Cast>
                                </Expression>
                            </AdditionalVarDecl>
                            <Outcome _EN_explanation="there are no unevaluated operators to the right of ${X}"
                                     _EN_nextStepExplanation="That's incorrect. If the expression to the right of the ${X} is already evaluated, then the right operand of ${X} is fully evaluated. Therefore, it is not preventing its further evaluation."
                                     _EN_nextStepQuestion="What is the next reasoning step if we know that there are only evaluated operators to the right of ${X}?"
                                     _RU_explanation="справа от ${X}[case='р'] нет потенциально мешающих операторов"
                                     _RU_nextStepExplanation="Это неверно. Если все выражение справа от ${X}[case='р'] вычислено, значит и его правый операнд вычислен и не мешает вычислению ${X}[case='р']."
                                     _RU_nextStepQuestion="Какие выводы можно сделать, если справа от ${X}[case='р'] находятся только вычисленные операторы?"
                                     _TEMPLATING_ID="69" value="false">
                                <BranchResultNode
                                        _EN_explanation="all operators to the right of it have been already evaluated or omitted."
                                        _RU_explanation="все операторы справа от него уже вычислены или опущены."
                                        _TEMPLATING_ID="70" value="CORRECT"/>
                            </Outcome>
                            <Outcome
                                    _EN_explanation="there is a potentially blocking operator to the right of ${X} - it's ${Z}"
                                    _EN_nextStepBranchResult="The one on the ${$branchResult == BranchResult:CORRECT ? 'left' : 'right'} is always evaluated first"
                                    _EN_nextStepExplanation="That's incorrect. One should first determine if parentheses have any effect on the precedence of the two operators."
                                    _EN_nextStepQuestion="How should one determine the order of evaluation between two operators?"
                                    _RU_explanation="справа от ${X}[case='р'] есть потенциально мешающий оператор - это ${Z}[case='и']"
                                    _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'Левый' : 'Правый'} оператор всегда выполняется первым"
                                    _RU_nextStepExplanation="Это неверно. Определение порядка вычислений двух операторов надо начинать с рассмотрения влияния скобок на их приоритет."
                                    _RU_nextStepQuestion="Как определяется порядок вычисления двух конкурирующих операторов?"
                                    _TEMPLATING_ID="71" value="true">
                                <QuestionNode _EN_asNextStep="We should check if ${X} is inside ${Z}"
                                              _EN_endingCause="Because ${X} is inside ${Z}"
                                              _EN_question="Is ${X} inside ${Z}?"
                                              _RU_asNextStep="Необходимо проверить, находится ли ${X}[case='и'] внутри ${Z}[case='р']"
                                              _RU_endingCause="Потому что ${X} находится внутри ${Z}[case='р']"
                                              _RU_question="Верно ли, что ${X}[case='и'] находится внутри ${Z}[case='р']?"
                                              _TEMPLATING_ID="72" _alias="right.isXinZ">
                                    <Expression>
                                        <ExistenceQuantifier type="token" varName="z2">
                                            <LogicalAnd>
                                                <LogicalAnd>
                                                    <CheckClass>
                                                        <Variable name="z2"/>
                                                        <Class name="token"/>
                                                    </CheckClass>
                                                    <CheckRelationship relationshipName="belongsTo">
                                                        <Variable name="z2"/>
                                                        <DecisionTreeVar name="Z"/>
                                                    </CheckRelationship>
                                                </LogicalAnd>
                                                <Compare operator="NotEqual">
                                                    <Variable name="z2"/>
                                                    <DecisionTreeVar name="Z1"/>
                                                </Compare>
                                            </LogicalAnd>
                                            <CheckRelationship relationshipName="isBetween">
                                                <DecisionTreeVar name="X"/>
                                                <DecisionTreeVar name="Z1"/>
                                                <Variable name="z2"/>
                                            </CheckRelationship>
                                        </ExistenceQuantifier>
                                    </Expression>
                                    <Outcome _EN_nextStepExplanation="That's incorrect."
                                             _EN_nextStepQuestion="What can we now conclude?"
                                             _RU_nextStepExplanation="Это неверно."
                                             _RU_nextStepQuestion="Какие выводы можно сделать на данном этапе?"
                                             _TEMPLATING_ID="73" value="true">
                                        <BranchResultNode
                                                _EN_explanation="it is wrapped by the closest ${Z} to its right"
                                                _RU_explanation="он заключен в ближайший оператор справа от него - ${Z}[case='и']"
                                                _TEMPLATING_ID="74" _skill="right_operator_enclosed" value="CORRECT"/>
                                    </Outcome>
                                    <Outcome _EN_nextStepExplanation="That's incorrect."
                                             _EN_nextStepQuestion="What can we now conclude?"
                                             _RU_nextStepExplanation="Это неверно."
                                             _RU_nextStepQuestion="Какие выводы можно сделать на данном этапе?"
                                             _TEMPLATING_ID="75" value="false">
                                        <BranchAggregationNode
                                                _EN_asNextStep="We should check if parentheses have any effect on the precedence of the two operators."
                                                _EN_endingCause="Because of the effect of the parentheses"
                                                _EN_question="How do parentheses affect the evaluation of ${X} and ${Z}?"
                                                _RU_asNextStep="Необходимо рассмотреть влияние скобок на взаимодействие между ${X}[case='т'] и ${Z}[case='т']."
                                                _RU_endingCause="Из-за роли скобок в выражении"
                                                _RU_question="Как скобки влияют на взаимодействие между ${X}[case='т'] и ${Z}[case='т']?"
                                                _TEMPLATING_ID="76" _alias="right.predetermining" operator="MUTEX">
                                            <ThoughtBranch
                                                    _EN_description_correct="${X} is inside of parenthesis, and ${Z} is outside of them"
                                                    _EN_description_null="there are no parenthesis that enclose ${X} but not ${Z}"
                                                    _RU_description_correct="${X} находится в скобках, а ${Z} - за их пределами"
                                                    _RU_description_null="не существует скобок, окружающих ${X}, но не окружающих ${Z}[case='в']"
                                                    _TEMPLATING_ID="77" _alias="right.predetermining.2">
                                                <QuestionNode
                                                        _RU_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${X}[case='и'], но не ${Z}[case='и']"
                                                        _RU_endingCause="Потому что существуют скобки, окружающие ${X}, но не ${Z}"
                                                        _RU_question="Существуют ли скобки, окружающие ${X}[case='и'], но не ${Z}[case='и']?"
                                                        _TEMPLATING_ID="78"
                                                        _alias="right.predetermining.2.isXinParenthesis">
                                                    <Expression>
                                                        <ExistenceQuantifier type="parenthesis" varName="p">
                                                            <CheckClass>
                                                                <Variable name="p"/>
                                                                <Class name="parenthesis"/>
                                                            </CheckClass>
                                                            <ExistenceQuantifier type="token" varName="p1">
                                                                <CheckRelationship relationshipName="belongsTo">
                                                                    <Variable name="p1"/>
                                                                    <Variable name="p"/>
                                                                </CheckRelationship>
                                                                <ExistenceQuantifier type="token" varName="p2">
                                                                    <CheckRelationship relationshipName="belongsTo">
                                                                        <Variable name="p2"/>
                                                                        <Variable name="p"/>
                                                                    </CheckRelationship>
                                                                    <LogicalAnd>
                                                                        <CheckRelationship relationshipName="isBetween">
                                                                            <DecisionTreeVar name="X"/>
                                                                            <Variable name="p1"/>
                                                                            <Variable name="p2"/>
                                                                        </CheckRelationship>
                                                                        <LogicalNot>
                                                                            <CheckRelationship
                                                                                    relationshipName="isBetween">
                                                                                <DecisionTreeVar name="Z"/>
                                                                                <Variable name="p1"/>
                                                                                <Variable name="p2"/>
                                                                            </CheckRelationship>
                                                                        </LogicalNot>
                                                                    </LogicalAnd>
                                                                </ExistenceQuantifier>
                                                            </ExistenceQuantifier>
                                                        </ExistenceQuantifier>
                                                    </Expression>
                                                    <Outcome value="false">
                                                        <BranchResultNode value="NULL"/>
                                                    </Outcome>
                                                    <Outcome value="true">
                                                        <BranchResultNode
                                                                _EN_explanation="it is inside parentheses, while the closest ${Z} to its right lies outside them."
                                                                _RU_explanation="он находится в скобках, а ближайший к нему справа ${Z} находится за их пределами."
                                                                _TEMPLATING_ID="79"
                                                                _skill="is_current_parenthesized_right_not"
                                                                value="CORRECT"/>
                                                    </Outcome>
                                                </QuestionNode>
                                            </ThoughtBranch>
                                            <ThoughtBranch
                                                    _EN_description_error="${Z} is inside of parenthesis, and ${X} is outside of them"
                                                    _EN_description_null="there are no parenthesis that enclose ${Z} but not ${X}"
                                                    _RU_description_error="${Z} находится в скобках, а ${X} - за их пределами"
                                                    _RU_description_null="не существует скобок, окружающих ${Z}, но не окружающих ${X}[case='в']"
                                                    _TEMPLATING_ID="80" _alias="right.predetermining.3">
                                                <QuestionNode
                                                        _RU_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${Z}[case='и'], но не ${X}[case='в']"
                                                        _RU_endingCause="Потому что существуют скобки, окружающие ${Z}, но не ${X}"
                                                        _RU_question="Существуют ли скобки, окружающие ${Z}[case='и'], но не ${X}[case='в']?"
                                                        _TEMPLATING_ID="81"
                                                        _alias="right.predetermining.3.isZinParenthesis">
                                                    <Expression>
                                                        <ExistenceQuantifier type="parenthesis" varName="p">
                                                            <CheckClass>
                                                                <Variable name="p"/>
                                                                <Class name="parenthesis"/>
                                                            </CheckClass>
                                                            <ExistenceQuantifier type="token" varName="p1">
                                                                <CheckRelationship relationshipName="belongsTo">
                                                                    <Variable name="p1"/>
                                                                    <Variable name="p"/>
                                                                </CheckRelationship>
                                                                <ExistenceQuantifier type="token" varName="p2">
                                                                    <CheckRelationship relationshipName="belongsTo">
                                                                        <Variable name="p2"/>
                                                                        <Variable name="p"/>
                                                                    </CheckRelationship>
                                                                    <LogicalAnd>
                                                                        <CheckRelationship relationshipName="isBetween">
                                                                            <DecisionTreeVar name="Z"/>
                                                                            <Variable name="p1"/>
                                                                            <Variable name="p2"/>
                                                                        </CheckRelationship>
                                                                        <LogicalNot>
                                                                            <CheckRelationship
                                                                                    relationshipName="isBetween">
                                                                                <DecisionTreeVar name="X"/>
                                                                                <Variable name="p1"/>
                                                                                <Variable name="p2"/>
                                                                            </CheckRelationship>
                                                                        </LogicalNot>
                                                                    </LogicalAnd>
                                                                </ExistenceQuantifier>
                                                            </ExistenceQuantifier>
                                                        </ExistenceQuantifier>
                                                    </Expression>
                                                    <Outcome value="false">
                                                        <BranchResultNode value="NULL"/>
                                                    </Outcome>
                                                    <Outcome value="true">
                                                        <BranchResultNode
                                                                _EN_explanation="${Z} on its right must be evaluated first because ${Z} is in parentheses."
                                                                _RU_explanation="сначала должен быть вычислен ${Z} справа от него, так как ${Z} окружен круглыми скобками."
                                                                _TEMPLATING_ID="82"
                                                                _law="error_base_parenthesized_operators;error_base_student_error_in_complex"
                                                                _skill="is_right_parenthesized_current_not"
                                                                value="ERROR"/>
                                                    </Outcome>
                                                </QuestionNode>
                                            </ThoughtBranch>
                                            <Outcome
                                                    _EN_nextStepBranchResult="The operator on the ${$branchResult == BranchResult:CORRECT ? 'right' : 'left'} is always evaluated first."
                                                    _EN_nextStepExplanation="That's incorrect. In the absence of parentheses' effect, the order of evaluation is determined by the precedence of the operators - so it should be considered next."
                                                    _EN_nextStepQuestion="In the absence of parentheses' effect, how should one determine the order of evaluation between two operator?"
                                                    _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'Левый' : 'Правый'} оператор всегда выполняется первым"
                                                    _RU_nextStepExplanation="Это неверно. В отсутствии скобок, порядок выполнения стоящих рядом операторов определяется их приоритетом - его и надо рассматривать следующим."
                                                    _RU_nextStepQuestion="В отсутствии влияния скобок, как определяется порядок выполнения стоящих рядом операторов?"
                                                    _TEMPLATING_ID="83" value="NULL">
                                                <QuestionNode
                                                        _EN_asNextStep="We should compare the precedence of ${X.class()} and ${Z.class()}."
                                                        _EN_endingCause="Because of the precedences of ${X.class()} and ${Z.class()}."
                                                        _EN_question="Compare the precedence of ${X.class()} and ${Z.class()}."
                                                        _EN_triviality="Precedences of ${X} and ${Z} are obviously equal as they are the same operator."
                                                        _RU_asNextStep="Необходимо сравнить приоритеты ${X.class()}[case='р'] и ${Z.class()}[case='р']"
                                                        _RU_endingCause="Из-за соотношения приоритетов ${X.class()}[case='р'] и ${Z.class()}[case='р']"
                                                        _RU_question="Сравните приоритеты ${X.class()}[case='р'] и ${Z.class()}[case='р']"
                                                        _RU_triviality="Приоритеты ${X}[case='р'] и ${Z}[case='р'] очевидно равны, так как это один и тот же оператор."
                                                        _TEMPLATING_ID="84" _alias="right.precedence">
                                                    <Triviality>
                                                        <Compare operator="Equal">
                                                            <GetClass>
                                                                <DecisionTreeVar name="X"/>
                                                            </GetClass>
                                                            <GetClass>
                                                                <DecisionTreeVar name="Z"/>
                                                            </GetClass>
                                                        </Compare>
                                                    </Triviality>
                                                    <Expression>
                                                        <Compare>
                                                            <GetPropertyValue propertyName="precedence">
                                                                <DecisionTreeVar name="X"/>
                                                            </GetPropertyValue>
                                                            <GetPropertyValue propertyName="precedence">
                                                                <DecisionTreeVar name="Z"/>
                                                            </GetPropertyValue>
                                                        </Compare>
                                                    </Expression>
                                                    <Outcome
                                                            _EN_explanation="That's incorrect, because ${X.class()} has higher precedence than ${Z.class()}."
                                                            _EN_nextStepBranchResult="Operator with a ${$branchResult == BranchResult:CORRECT ? 'higher' : 'lower'} precedence is always evaluated first"
                                                            _EN_nextStepExplanation="That's incorrect. The operator with a higher precedence is always evaluated first. Therefore, in this case, the ${X} should be evaluated first, and we can conclude that its left operand does not prevent its evaluation."
                                                            _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have different precedences?"
                                                            _EN_text="${X.class()} has higher precedence."
                                                            _RU_explanation="Это неверно, поскольку ${X.class()}[case='и'] имеет больший приоритет, чем ${Z.class()}[case='и']."
                                                            _RU_nextStepBranchResult="Оператор с ${$branchResult == BranchResult:CORRECT ? 'большим' : 'меньшим'} приоритетом всегда выполняется первым"
                                                            _RU_nextStepExplanation="Это неверно. Оператор с большим приоритетом всегда выполняется первым. Т.к. ${X.class()}[case='и'] имеет больший приоритет, а значит может быть вычислен первым. Получается, правый операнд ${X}[case='и'] не требует дальнейших вычислений."
                                                            _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих разные приоритеты?"
                                                            _RU_text="Приоритет ${X.class()}[case='р'] больше."
                                                            _TEMPLATING_ID="85" value="Comparison:less">
                                                        <BranchResultNode
                                                                _EN_explanation="it has a higher precedence than ${Z}."
                                                                _RU_explanation="он имеет приоритет выше, чем у ${Z}[case='в']."
                                                                _TEMPLATING_ID="86"
                                                                _skill="left_competing_to_right_precedence"
                                                                value="CORRECT"/>
                                                    </Outcome>
                                                    <Outcome
                                                            _EN_explanation="That's incorrect, because ${Z.class()} has higher precedence than ${X.class()}."
                                                            _EN_nextStepBranchResult="Operator with a ${$branchResult == BranchResult:CORRECT ? 'lower' : 'higher'} precedence is always evaluated first"
                                                            _EN_nextStepExplanation="That's incorrect. The operator with a higher precedence is always evaluated first. Therefore, in this case, the ${Z} should be evaluated first, and we can conclude that the left operand of ${X} does prevent its evaluation."
                                                            _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have different precedences?"
                                                            _EN_text="${Z.class()} has higher precedence."
                                                            _RU_explanation="Это неверно, поскольку ${Z.class()}[case='и'] имеет больший приоритет, чем ${X.class()}[case='и']."
                                                            _RU_nextStepBranchResult="Оператор с ${$branchResult == BranchResult:CORRECT ? 'меньшим' : 'большим'} приоритетом всегда выполняется первым"
                                                            _RU_nextStepExplanation="Это неверно. Оператор с большим приоритетом всегда выполняется первым. Т.к. ${Z.class()}[case='и'] имеет больший приоритет, он должен быть вычислен первым. Получается, правый операнд ${X}[case='и'] требует дальнейших вычислений."
                                                            _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих разные приоритеты?"
                                                            _RU_text="Приоритет ${Z.class()}[case='р'] больше."
                                                            _TEMPLATING_ID="87" value="Comparison:greater">
                                                        <BranchResultNode
                                                                _EN_explanation="${Z} on its right must be evaluated first because it has a higher precedence."
                                                                _RU_explanation="сначала должен быть вычислен ${Z}[case='и'] справа от него, который имеет более высокий приоритет."
                                                                _TEMPLATING_ID="88" _error="right.precedence"
                                                                _law="error_base_higher_precedence_right"
                                                                _skill="left_competing_to_right_precedence"
                                                                value="ERROR"/>
                                                    </Outcome>
                                                    <Outcome
                                                            _EN_explanation="That's incorrect because ${X.class()} and ${Z.class()} have the same precedence."
                                                            _EN_nextStepBranchResult="The operator on the ${$branchResult == BranchResult:CORRECT ? 'right' : 'left'} is always evaluated first."
                                                            _EN_nextStepExplanation="That's incorrect. The order of evaluation between two operators that have the same precedence is determined by their associativity. Therefore we should next check the associativity of ${X.class()} and ${Z.class()}."
                                                            _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have the same precedence?"
                                                            _EN_text="They have the same precedence."
                                                            _RU_explanation="Это неверно, поскольку приоритеты ${X.class()}[case='р'] и ${Z.class()}[case='р'] одинаковы."
                                                            _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'Левый' : 'Правый'} оператор всегда выполняется первым"
                                                            _RU_nextStepExplanation="Это неверно. Порядок выполнения операторов, имеющих одинаковые приоритеты, задается ассоциативностью, а значит следующим шагом необходимо проверить ассоциативность ${X.class()}[case='р'] и ${Z.class()}[case='р']."
                                                            _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих равные приоритеты?"
                                                            _RU_text="Их приоритеты одинаковы." _TEMPLATING_ID="89"
                                                            value="Comparison:equal">
                                                        <QuestionNode
                                                                _EN_asNextStep="We should check if ${X} needs a left operand."
                                                                _EN_endingCause="Because ${X} doesn't need a left operand."
                                                                _EN_question="Does ${X.class()} need a left operand?"
                                                                _RU_asNextStep="Необходимо проверить, нужен ли ${X}[case='д'] левый операнд."
                                                                _RU_endingCause="Потому что ${X} не требует левого операнда"
                                                                _RU_question="Нужен ли ${X.class()}[case='д'] левый операнд?"
                                                                _TEMPLATING_ID="90" _alias="leftOperandAssoc.isNeeded">
                                                            <Expression>
                                                                <GetPropertyValue propertyName="needsOperand">
                                                                    <DecisionTreeVar name="X"/>
                                                                    <ParamsValues type="ordered">
                                                                        <Enum owner="OperandPlacement" value="left"/>
                                                                    </ParamsValues>
                                                                </GetPropertyValue>
                                                            </Expression>
                                                            <Outcome
                                                                    _EN_explanation="That's incorrect, because ${X.class()} doesn't need a left operand."
                                                                    _EN_nextStepExplanation="That's incorrect. If it doesn't need a left operand, then the left operand can't prevent its further evaluation."
                                                                    _EN_nextStepQuestion="What is the next reasoning step if we know that ${X.class()} doesn't need a left operand?"
                                                                    _RU_explanation="Это неверно. ${X.class()}[case='и'] не имеет (не требует) левого операнда."
                                                                    _RU_nextStepExplanation="Это неверно. Если оператор не имеет левого операнда, то и дальнейших вычислений его левый операнд требовать не может."
                                                                    _RU_nextStepQuestion="Какие выводы можно сделать, если ${X}[case='и'] не требует левого операнда?"
                                                                    _TEMPLATING_ID="91" value="false">
                                                                <BranchResultNode
                                                                        _EN_explanation=" ${Z} on its right must be evaluated first - these operators have the same precedence, but are evaluated from right to left (have right associativity)."
                                                                        _RU_explanation="сначала должен быть вычислен ${Z}[case='и'] справа от него: эти операторы имеют одинаковый приоритет, и вычисляются справа налево (правоассоциативны)."
                                                                        _TEMPLATING_ID="92"
                                                                        _skill="associativity_without_left_opposing_operand"
                                                                        value="ERROR"/>
                                                            </Outcome>
                                                            <Outcome
                                                                    _EN_explanation="That's incorrect, because ${X.class()} does require a left operand."
                                                                    _EN_nextStepExplanation="That's incorrect. From here, one should check if there are any operators that should still be evaluated in the left operand, and then reason based on that."
                                                                    _EN_nextStepQuestion="What is the next reasoning step if we know that ${X.class()} needs a left operand?"
                                                                    _RU_explanation="Это неверно. ${X.class()}[case='д'] всегда необходим левый операнд."
                                                                    _RU_nextStepExplanation="Это неверно. Необходимо дальше рассмотреть потенциально конкурирующие с ${X}[case='т'] операторы, и делать выводы исходя из их наличия/отсутствия."
                                                                    _RU_nextStepQuestion="Какие выводы можно сделать, если ${X}[case='д'] нужен левый операнд?"
                                                                    _TEMPLATING_ID="93" value="true">
                                                                <QuestionNode
                                                                        _EN_asNextStep="We should determine the associativity of ${X.class()} and ${Z.class()}"
                                                                        _EN_endingCause="Because of the associativity of ${X.class()} and ${Z.class()}"
                                                                        _EN_question="What's the associativity of ${X.class()} and ${Z.class()}?"
                                                                        _RU_asNextStep="Необходимо проверить, какова ассоциативность ${X.class()}[case='р'] и ${Z.class()}[case='р']"
                                                                        _RU_endingCause="Из-за ассоциативности ${X.class()} и ${Z.class()}"
                                                                        _RU_question="Какова ассоциативность ${X.class()}[case='р'] и ${Z.class()}[case='р']?"
                                                                        _TEMPLATING_ID="94"
                                                                        _alias="right.associativity">
                                                                    <Expression>
                                                                        <GetPropertyValue propertyName="associativity">
                                                                            <DecisionTreeVar name="Z"/>
                                                                        </GetPropertyValue>
                                                                    </Expression>
                                                                    <Outcome
                                                                            _EN_explanation="That's incorrect, because ${X.class()} and ${Z.class()} have right associativity."
                                                                            _EN_nextStepBranchResult="The one on the ${$branchResult == BranchResult:CORRECT ? 'left' : 'right'}"
                                                                            _EN_nextStepExplanation="That's incorrect. Operators that have right associativity evaluate from right to left. Therefore, in this case, ${Z.class()} should be evaluated first, and we can conclude that the right operand of ${X} does prevent its evaluation."
                                                                            _EN_nextStepQuestion="Which of the two nearby operators evaluates first if they have right associativity?"
                                                                            _EN_text="right"
                                                                            _RU_explanation="Это неверно, поскольку ${X.class()}[case='и'] и ${Z.class()}[case='и'] имеют правую ассоциативность."
                                                                            _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'Левый' : 'Правый'}"
                                                                            _RU_nextStepExplanation="Это неверно. При правой ассоциативности операторы выполняются справа налево. В данном случае это значит, ${Z.class()}[case='и'] должен быть вычислен первым. Получается, правый операнд ${X}[case='и'] требует дальнейших вычислений."
                                                                            _RU_nextStepQuestion="Какой из двух рядом стоящих операторов выполнится первым, если операторы имеют правую ассоциативность?"
                                                                            _RU_text="правая" _TEMPLATING_ID="95"
                                                                            value="associativity:right">
                                                                        <BranchResultNode
                                                                                _EN_explanation=" ${Z} on its right must be evaluated first - these operators have the same precedence, but are evaluated from right to left (have right associativity)."
                                                                                _RU_explanation="сначала должен быть вычислен ${Z}[case='и'] справа от него: эти операторы имеют одинаковый приоритет, и вычисляются справа налево (правоассоциативны)."
                                                                                _TEMPLATING_ID="96"
                                                                                _error="right.associativity"
                                                                                _law="error_base_same_precedence_right_associativity_right"
                                                                                _skill="left_competing_to_right_associativity"
                                                                                value="ERROR"/>
                                                                    </Outcome>
                                                                    <Outcome
                                                                            _EN_explanation="That's incorrect, because ${X.class()} and ${Z.class()} have left associativity."
                                                                            _EN_nextStepBranchResult="The one on the ${$branchResult == BranchResult:CORRECT ? 'left' : 'right'}"
                                                                            _EN_nextStepExplanation="That's incorrect. Operators that have left associativity evaluate from left to right. Therefore, in this case, ${X.class()} should be evaluated first, anand we can conclude that its left operand does not prevent its evaluation."
                                                                            _EN_nextStepQuestion="Which of the two nearby operators evaluates first if they have left associativity?"
                                                                            _EN_text="left"
                                                                            _RU_explanation="Это неверно, поскольку ${X.class()}[case='и'] и ${Z.class()}[case='и'] имеют правую ассоциативность."
                                                                            _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'Правый' : 'Левый'}"
                                                                            _RU_nextStepExplanation="Это неверно. При левой ассоциативности операторы выполняются слева направо. В данном случае это значит, ${X.class()}[case='и'] должен быть вычислен первым. Получается, правый операнд ${X}[case='и'] не требует дальнейших вычислений."
                                                                            _RU_nextStepQuestion="Какой из двух рядом стоящих операторов выполнится первым, если операторы имеют правую ассоциативность?"
                                                                            _RU_text="правая" _TEMPLATING_ID="97"
                                                                            value="associativity:left">
                                                                        <BranchResultNode
                                                                                _EN_explanation=" it has the same precedence as ${Z} and left associativity."
                                                                                _RU_explanation=" имеет одинаковый приоритет с ${Z}[case='т'] и левую ассоциативность (вычисляются слева направо)."
                                                                                _TEMPLATING_ID="98"
                                                                                _skill="left_competing_to_right_associativity"
                                                                                value="CORRECT"/>
                                                                    </Outcome>
                                                                </QuestionNode>
                                                            </Outcome>
                                                        </QuestionNode>
                                                    </Outcome>
                                                </QuestionNode>
                                            </Outcome>
                                        </BranchAggregationNode>
                                    </Outcome>
                                </QuestionNode>
                            </Outcome>
                        </FindActionNode>
                    </Outcome>
                </QuestionNode>
            </ThoughtBranch>
            <ThoughtBranch
                    _EN_description="${$branchResult == BranchResult:CORRECT ? 'no' : 'some'} operators with strict operand order should be considered before ${X} can be evaluated"
                    _EN_nextStepExplanation="That's incorrect. One should first find all such operators and check if they really hinder the evaluation of ${X}."
                    _EN_nextStepQuestion="What is the first step when considering operators with strict operand order?"
                    _RU_description="вычислению ${X}[case='р'] ${$branchResult == BranchResult:CORRECT ? 'не' : ''} мешают операторы со строгим порядком операндов"
                    _RU_nextStepExplanation="Это неверно. Прежде всего необходимо найти все подобные операторы, которые могут помешать вычислению ${X}[case='р']"
                    _RU_nextStepQuestion="С чего надо начать при определении того, мешают ли вычислению ${X}[case='р'] операторы со строгим порядком операндов?"
                    _TEMPLATING_ID="99" _alias="strict">
                <CycleAggregationNode
                        _EN_description="${$branchResult == BranchResult:CORRECT ? 'no' : 'some'} operators with strict operand order should be considered before ${X} can be evaluated"
                        _EN_question="Choose all operators with strict operand order that can influence the evaluation of ${X}"
                        _RU_description="вычислению ${X}[case='р'] ${$branchResult == BranchResult:CORRECT ? 'не' : ''} мешают операторы со строгим порядком операндов"
                        _RU_question="Выберите все операторы со строгим порядком операндов, которые могут помешать вычислению ${X}[case='р']"
                        _TEMPLATING_ID="100" _alias="Для всех операторов со строгим порядком - T" operator="AND">
                    <DecisionTreeVarDecl name="T" type="StrictOrderOperator"/>
                    <SelectorExpression>
                        <Boolean value="true"/>
                    </SelectorExpression>
                    <FindError _EN_explanation="${$checked} is not an operator with a strict operand order."
                               _RU_explanation="${$checked}[case='и'] не является оператором со строгим порядком операндов"
                               _alias="T_notStrict" priority="1" type="operator">
                        <Expression>
                            <LogicalAnd>
                                <Compare operator="NotEqual">
                                    <DecisionTreeVar name="X"/>
                                    <Variable name="checked"/>
                                </Compare>
                                <LogicalNot>
                                    <CheckClass>
                                        <Variable name="checked"/>
                                        <Class name="StrictOrderOperator"/>
                                    </CheckClass>
                                </LogicalNot>
                            </LogicalAnd>
                        </Expression>
                    </FindError>
                    <ThoughtBranch
                            _EN_description="${T} does ${$branchResult == BranchResult:CORRECT ? 'not' : ''} hinder evaluation of ${X} as an operator with strict order of operands"
                            _EN_nextStepExplanation="That's incorrect. We should first determine, if the left operand of ${T} is fully evaluated."
                            _EN_nextStepQuestion="What is the first step to determine if ${T} hinders the evaluation of ${X}?"
                            _RU_description="${T}[case='и'] ${$branchResult == BranchResult:CORRECT ? 'не' : ''} мешает вычислению ${X}[case='р'] как оператор со строгим порядком операндов"
                            _RU_nextStepExplanation="Это неверно. Прежде всего необходимо определить, вычислен ли уже левый операнд ${T}[case='р']."
                            _RU_nextStepQuestion="С чего надо начать, чтобы определить, мешают ли ${T}[case='и'] вычислению ${X}[case='р']?"
                            _TEMPLATING_ID="101" _alias="strict.Tcycle">
                        <QuestionNode _TEMPLATING_ID="102" _alias="X не в операнде Т">
                            <Expression>
                                <LogicalNot>
                                    <CheckRelationship relationshipName="isInOperandOf">
                                        <DecisionTreeVar name="X"/>
                                        <DecisionTreeVar name="T"/>
                                    </CheckRelationship>
                                </LogicalNot>
                            </Expression>
                            <Outcome value="true">
                                <QuestionNode _TEMPLATING_ID="103" _alias="X - это не T">
                                    <Expression>
                                        <Compare operator="NotEqual">
                                            <DecisionTreeVar name="X"/>
                                            <DecisionTreeVar name="T"/>
                                        </Compare>
                                    </Expression>
                                    <Outcome value="true">
                                        <BranchResultNode
                                                _EN_explanation="it is not a part of any operand of ${T} which has a strict order of operand evaluation"
                                                _RU_explanation="он не находится в ${T}[case='п'], который имеет строгий порядок вычисления операндов."
                                                _TEMPLATING_ID="104" _skill="is_current_operator_strict_order"
                                                value="CORRECT"/>
                                    </Outcome>
                                    <Outcome value="false">
                                        <BranchResultNode _TEMPLATING_ID="105" _skill="is_current_operator_strict_order"
                                                          value="CORRECT"/>
                                    </Outcome>
                                </QuestionNode>
                            </Outcome>
                            <Outcome value="false">
                                <QuestionNode _TEMPLATING_ID="106" _alias="X в его первом операнде">
                                    <Expression>
                                        <CheckRelationship relationshipName="isInOperandOf">
                                            <DecisionTreeVar name="X"/>
                                            <ParamsValues type="ordered">
                                                <GetPropertyValue propertyName="firstOperandPlacement">
                                                    <DecisionTreeVar name="T"/>
                                                </GetPropertyValue>
                                            </ParamsValues>
                                            <DecisionTreeVar name="T"/>
                                        </CheckRelationship>
                                    </Expression>
                                    <Outcome value="true">
                                        <BranchResultNode
                                                _EN_explanation="it belongs to the ${X=&gt;isInOperandOf(T).placement}[case='п'] operand of ${T}[case='р'], which is evaluated before the other operands of the latter."
                                                _RU_explanation="он находится в ${X=&gt;isInOperandOf(T).placement}[case='п'] операнде ${T}[case='р'], а этот операнд вычисляется раньше остальных."
                                                _TEMPLATING_ID="107"
                                                _skill="strict_order_first_operand_to_be_evaluated_while_solving"
                                                value="CORRECT"/>
                                    </Outcome>
                                    <Outcome value="false">
                                        <CycleAggregationNode
                                                _EN_asNextStep="We need to check if there are any unevaluated operators in the left operand of ${T}."
                                                _EN_description="There ${$branchResult == BranchResult:CORRECT ? 'are' : 'aren't'} any unevaluated operators in the left operand of ${T}?"
                                                _EN_endingCause="Because there are no unevaluated operators in the left operand of ${T}"
                                                _RU_asNextStep="Необходимо проверить, остались ли в левом операнде ${T}[case='р'] невычисленные операторы."
                                                _RU_description="В левом операнде ${T}[case='р'] ${$branchResult == BranchResult:CORRECT ? 'не' : ''} остались невычисленные операторы?"
                                                _RU_endingCause="Поскольку в левом операнде ${T} не осталось невычисленных операторов"
                                                _TEMPLATING_ID="108"
                                                _alias="Есть ли в первом операнде T невычисленный оператор (U)?"
                                                operator="AND">
                                            <DecisionTreeVarDecl name="U" type="operator"/>
                                            <SelectorExpression>
                                                <LogicalAnd>
                                                    <Compare operator="Equal">
                                                        <GetPropertyValue propertyName="state">
                                                            <Variable name="U"/>
                                                        </GetPropertyValue>
                                                        <Enum owner="state" value="unevaluated"/>
                                                    </Compare>
                                                    <CheckRelationship relationshipName="isInOperandOf">
                                                        <Variable name="U"/>
                                                        <ParamsValues type="ordered">
                                                            <GetPropertyValue propertyName="firstOperandPlacement">
                                                                <DecisionTreeVar name="T"/>
                                                            </GetPropertyValue>
                                                        </ParamsValues>
                                                        <DecisionTreeVar name="T"/>
                                                    </CheckRelationship>
                                                </LogicalAnd>
                                            </SelectorExpression>
                                            <ThoughtBranch
                                                    _EN_nextStepBranchResult="Left operand of ${$branchResult == BranchResult:CORRECT ? 'not' : ''} hinder the evaluation of ${X}."
                                                    _EN_nextStepExplanation="That's incorrect. In operators with strict operand order, the left operand must always be evaluated first, and so ${X} cannot be evaluated yet."
                                                    _EN_nextStepQuestion="What can we decide if an operator with a strict order of operands has yet-unevaluated operand?"
                                                    _RU_nextStepBranchResult="Левый операнд ${$branchResult == BranchResult:CORRECT ? 'не' : ''} мешает вычислению ${X}[case='р']."
                                                    _RU_nextStepExplanation="Это неверно. В операторах со строгим порядком операндов левый операнд всегда должен вычисляться первым, и значит ${X}[case='и'] пока не может быть вычислен."
                                                    _RU_nextStepQuestion="Какой вывод можно сделать, если у оператора со строгим порядком операндов не вычислен левый операнд?"
                                                    _TEMPLATING_ID="109">
                                                <BranchResultNode
                                                        _EN_explanation="${U} that belongs to ${U=&gt;isInOperandOf(T).placement}[case='п'] operand ${T}[case='р'] should be evaluated before it"
                                                        _RU_explanation="${U}, стоящий в ${U=&gt;isInOperandOf(T).placement}[case='п'] операнде ${T}[case='р'], должен быть вычислен ранее"
                                                        _TEMPLATING_ID="110" _error="strict.leftShouldBeEvaluatedFirst"
                                                        _law="error_base_student_error_strict_operands_order"
                                                        _skill="is_first_operand_of_strict_order_operator_fully_evaluated"
                                                        value="ERROR"/>
                                            </ThoughtBranch>
                                            <Outcome
                                                    _EN_explanation="This is incorrect, because there are no such operators - they are all evaluated."
                                                    _EN_nextStepExplanation="This is incorrect. Most operators with strict operand ordering also involve their operands                                  being omitted in some situations. So next we need to check whether that applies in this case."
                                                    _EN_nextStepQuestion="What further steps are needed when considering operators with strict operand order?"
                                                    _RU_explanation="Это неверно, поскольку таких операторов нет - все вычислены."
                                                    _RU_nextStepExplanation="Это неверно. Большинство операторов со строгим порядком операндов также предполагают, что в некоторых ситуациях их операнды могут быть опущены. Поэтому далее нужно проверить, применимо ли это в данном случае."
                                                    _RU_nextStepQuestion="Какие дальнейшие шаги нужны при рассмотрении операторов со строгим порядком операндов?"
                                                    _TEMPLATING_ID="111" value="NULL">
                                                <QuestionNode
                                                        _EN_asNextStep="We need to check if the operands of ${T.class()} can be omitted."
                                                        _EN_endingCause="Because ${T.class()} does not involve the omission of its operands"
                                                        _EN_question="Can the operands of ${T.class()} be omitted?"
                                                        _RU_asNextStep="Нужно проверить, могут ли операнды ${T.class()}[case='р'] быть опущены."
                                                        _RU_endingCause="Поскольку ${T.class()} не предполагает опущения своих операндов"
                                                        _RU_question="Могут ли операнды ${T.class()}[case='р'] быть опущены?"
                                                        _TEMPLATING_ID="112"
                                                        _alias="Может ли опускать операнд, в котором X">
                                                    <Expression>
                                                        <Compare operator="NotEqual">
                                                            <GetPropertyValue
                                                                    propertyName="requiredFirstOperandValueToEvaluate">
                                                                <DecisionTreeVar name="T"/>
                                                                <ParamsValues type="ordered">
                                                                    <GetRelationshipParamValue paramName="placement"
                                                                                               relationshipName="isInOperandOf">
                                                                        <DecisionTreeVar name="X"/>
                                                                        <DecisionTreeVar name="T"/>
                                                                    </GetRelationshipParamValue>
                                                                </ParamsValues>
                                                            </GetPropertyValue>
                                                            <Enum owner="ExpectedValue" value="any"/>
                                                        </Compare>
                                                    </Expression>
                                                    <Outcome
                                                            _EN_explanation="This is incorrect. Although ${T.class()} defines a strict order for its operands, it does not involve their omission."
                                                            _EN_nextStepExplanation="This is incorrect. Since ${T.class()} does not omit its operands, and its left operand is already fully evaluated,                                          it does not interfere with the evaluation of ${X}."
                                                            _EN_nextStepQuestion="What can we decide in this case?"
                                                            _RU_explanation="Это неверно. Хотя ${T.class()}[case='и'] и задает строгий порядок своих операндов, он не подразумевает их пропуска."
                                                            _RU_nextStepExplanation="Это неверно. Поскольку ${T.class()}[case='и'] не опускает свои операнды, и его левый операнд уже полностью вычислен,                                         то и вычислению ${X}[case='и'] он не мешает."
                                                            _RU_nextStepQuestion="Какой вывод можно сделать, в таком случае?"
                                                            _TEMPLATING_ID="113" value="false">
                                                        <BranchResultNode
                                                                _EN_explanation="${T.firstOperandPlacement} operand ${T}[case='р'] had already been evaluated, and that operator always evaluates all its operands"
                                                                _RU_explanation="${T.firstOperandPlacement} операнд ${T}[case='р'] уже вычислен, и этот оператор всегда вычисляет все свои операнды"
                                                                _TEMPLATING_ID="114"
                                                                _skill="no_omitted_operands_despite_strict_order_while_solving"
                                                                value="CORRECT"/>
                                                    </Outcome>
                                                    <Outcome
                                                            _EN_explanation="This is incorrect. Although ${T.class()} defines a strict order for its operands, it does not involve their omission."
                                                            _EN_nextStepExplanation="This is incorrect. First, we need to determine which operand of ${T} contains ${X},                                         and only then check whether it should be omitted in this situation."
                                                            _EN_nextStepQuestion="What further steps are needed when considering operators with strict operand order?"
                                                            _RU_explanation="Это неверно. В ${T.class()}[case='п'] может быть опущен операнд, в котором находится ${X}[case='и']}."
                                                            _RU_nextStepExplanation="Это неверно. Сначала необходимо определить, в каком операнде ${T}[case='р'] находится ${X}[case='и'],                                          а уже затем проверять, не должен ли он быть пропущен в данной ситуации."
                                                            _RU_nextStepQuestion="Какие дальнейшие шаги нужны при рассмотрении операторов со строгим порядком операндов?"
                                                            _TEMPLATING_ID="115" value="true">
                                                        <TupleQuestionNode
                                                                _EN_asNextStep="We need to check whether the right operand of ${T.class()} should be omitted."
                                                                _EN_endingCause="Because ${X} is omitted as the right operand of ${T.class()}."
                                                                _RU_asNextStep="Необходимо проверить, опускается ли правый операнд ${T}[case='р'] в данном случае."
                                                                _RU_endingCause="Поскольку ${X} опускается как правый операнд ${T.class()}."
                                                                _TEMPLATING_ID="116" _alias="опускается ли Х (кортеж)">
                                                            <Part _EN_question="What value should the left operand of ${T.class()} have in order for its right operand to be evaluated?"
                                                                  _RU_question="При каком значении левого операнда в ${T.class()}[case='п'] вычисляется правый операнд?"
                                                                  _alias="Какое значение должно быть у левого чтобы правый вычислился">
                                                                <Expression>
                                                                    <Compare operator="Equal">
                                                                        <GetPropertyValue
                                                                                propertyName="requiredFirstOperandValueToEvaluate">
                                                                            <DecisionTreeVar name="T"/>
                                                                            <ParamsValues type="ordered">
                                                                                <GetRelationshipParamValue
                                                                                        paramName="placement"
                                                                                        relationshipName="isInOperandOf">
                                                                                    <DecisionTreeVar name="X"/>
                                                                                    <DecisionTreeVar name="T"/>
                                                                                </GetRelationshipParamValue>
                                                                            </ParamsValues>
                                                                        </GetPropertyValue>
                                                                        <Enum owner="ExpectedValue" value="true"/>
                                                                    </Compare>
                                                                </Expression>
                                                                <Outcome
                                                                        _EN_explanation="That's incorrect. ${T.class()} only evaluates its right operand, if the left evaluates as 'true'.                                                             Otherwise the right operand is omitted."
                                                                        _EN_text="true"
                                                                        _RU_explanation="Это неверно. ${T.class()}[case='и'] вычисляет правый операнд только в случае, если левый имеет значение true.                                                             В ином случае правый операнд опускается."
                                                                        _RU_text="true" value="true"/>
                                                                <Outcome
                                                                        _EN_explanation="That's incorrect. ${T.class()} only evaluates its right operand, if the left evaluates as 'false'.                                                             Otherwise the right operand is omitted."
                                                                        _EN_text="false"
                                                                        _RU_explanation="Это неверно. ${T.class()}[case='и'] вычисляет правый операнд только в случае, если левый имеет значение false.                                                             В ином случае правый операнд опускается."
                                                                        _RU_text="false" value="false"/>
                                                            </Part>
                                                            <Part _EN_question="What is the value of first operand of ${T} in this case?"
                                                                  _RU_question="Какое значение имеет первый операнд ${T}[case='р'] в данном случае?"
                                                                  _alias="Какое значение у первого">
                                                                <Expression>
                                                                    <GetPropertyValue propertyName="evaluatesTo">
                                                                        <GetByRelationship
                                                                                relationshipName="hasOperand">
                                                                            <DecisionTreeVar name="T"/>
                                                                            <ParamsValues type="ordered">
                                                                                <GetPropertyValue
                                                                                        propertyName="firstOperandPlacement">
                                                                                    <DecisionTreeVar name="T"/>
                                                                                </GetPropertyValue>
                                                                            </ParamsValues>
                                                                        </GetByRelationship>
                                                                    </GetPropertyValue>
                                                                </Expression>
                                                                <Outcome
                                                                        _EN_explanation="That's incorrect. In this case the left operand evaluates as 'true'.                                                              Remember that we assume that all variables and non-boolean operators evaluate as 'true'."
                                                                        _EN_text="'true'"
                                                                        _RU_explanation="Это неверно. Левый операнд в данном случае имеет значение true.                                                              Помните, что мы предполагаем, что все переменные и не-логические операции вычисляются как true."
                                                                        _RU_text="true" value="true"/>
                                                                <Outcome
                                                                        _EN_explanation="That's incorrect. In this case the left operand evaluates as 'false'.                                                             Remember that we assume that all variables and non-boolean operators evaluate as 'true'."
                                                                        _EN_text="'false'"
                                                                        _RU_explanation="Это неверно. Левый операнд в данном случае имеет значение false.                                                             Помните, что мы предполагаем, что все переменные и не-логические операции вычисляются как true."
                                                                        _RU_text="false" value="false"/>
                                                            </Part>
                                                            <Outcome
                                                                    _EN_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'can be evaluated' : 'is omitted'}."
                                                                    _EN_nextStepExplanation="This is incorrect. Given the above, ${X} is not omitted, and can be evaluated."
                                                                    _EN_nextStepQuestion="What can we conclude in this case?"
                                                                    _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'может быть вычислен' : 'опускается'}."
                                                                    _RU_nextStepExplanation="Это неверно. С учетом сказанного выше, ${X}[case='и'] не опускается, и может быть свободно вычислен."
                                                                    _RU_nextStepQuestion="Какой вывод можно сделать в таком случае?"
                                                                    _TEMPLATING_ID="117" value="(true;true)">
                                                                <BranchResultNode
                                                                        _EN_explanation="it belongs to ${X=&gt;isInOperandOf(T).placement}[case='п'] operand of ${T}[case='р'] whose ${T.firstOperandPlacement} operand evaluates to ${T-&gt;hasOperand&lt;placement=T.firstOperandPlacement&gt;.evaluatesTo}."
                                                                        _RU_explanation="он находится в ${X=&gt;isInOperandOf(T).placement}[case='п'] операнде ${T}[case='р'], чей ${T.firstOperandPlacement} операнд имеет значение ${T-&gt;hasOperand&lt;placement=T.firstOperandPlacement&gt;.evaluatesTo}."
                                                                        _TEMPLATING_ID="118"
                                                                        _skill="should_strict_order_current_operand_be_omitted_while_solving"
                                                                        value="CORRECT"/>
                                                            </Outcome>
                                                            <Outcome
                                                                    _EN_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'can be evaluated' : 'is omitted'}."
                                                                    _EN_nextStepExplanation="This is incorrect. Given the above, ${X} is not omitted, and can be evaluated."
                                                                    _EN_nextStepQuestion="What can we conclude in this case?"
                                                                    _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'может быть вычислен' : 'опускается'}."
                                                                    _RU_nextStepExplanation="Это неверно. С учетом сказанного выше, ${X}[case='и'] не опускается, и может быть свободно вычислен."
                                                                    _RU_nextStepQuestion="Какой вывод можно сделать в таком случае?"
                                                                    _TEMPLATING_ID="119" value="(false;false)">
                                                                <BranchResultNode
                                                                        _EN_explanation="it belongs to ${X=&gt;isInOperandOf(T).placement}[case='п'] operand of ${T}[case='р'] whose ${T.firstOperandPlacement} operand evaluates to ${T-&gt;hasOperand&lt;placement=T.firstOperandPlacement&gt;.evaluatesTo}."
                                                                        _RU_explanation="он находится в ${X=&gt;isInOperandOf(T).placement}[case='п'] операнде ${T}[case='р'], чей ${T.firstOperandPlacement} операнд имеет значение ${T-&gt;hasOperand&lt;placement=T.firstOperandPlacement&gt;.evaluatesTo}."
                                                                        _TEMPLATING_ID="120"
                                                                        _skill="should_strict_order_current_operand_be_omitted_while_solving"
                                                                        value="CORRECT"/>
                                                            </Outcome>
                                                            <Outcome
                                                                    _EN_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'can be evaluated' : 'is omitted'}."
                                                                    _EN_nextStepExplanation="This is incorrect. Given the above, ${X} is omitted, and so cannot be evaluated now."
                                                                    _EN_nextStepQuestion="What can we conclude in this case?"
                                                                    _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'может быть вычислен' : 'опускается'}."
                                                                    _RU_nextStepExplanation="Это неверно. С учетом сказанного выше, ${X}[case='и'] опускается, а значит не может быть вычислен."
                                                                    _RU_nextStepQuestion="Какой вывод можно сделать в таком случае?"
                                                                    _TEMPLATING_ID="121" value="(true;false)">
                                                                <BranchResultNode
                                                                        _EN_explanation="it belongs to ${X=&gt;isInOperandOf(T).placement}[case='п'] operand of ${T}[case='р'] whose ${T.firstOperandPlacement} operand evaluates to ${T-&gt;hasOperand&lt;placement=T.firstOperandPlacement&gt;.evaluatesTo} which forbids evaluation of ${X}[case='р']."
                                                                        _RU_explanation="он находится в ${X=&gt;isInOperandOf(T).placement}[case='п'] операнде ${T}[case='р'], чей ${T.firstOperandPlacement} операнд имеет значение ${T-&gt;hasOperand&lt;placement=T.firstOperandPlacement&gt;.evaluatesTo}, что блокирует вычисление ${X}[case='р']."
                                                                        _TEMPLATING_ID="122" _alias="X опускается"
                                                                        _error="strict.leftShouldBeTrue_omittedInRight"
                                                                        _law="error_base_student_error_strict_operands_order"
                                                                        _skill="should_strict_order_current_operand_be_omitted_while_solving"
                                                                        value="ERROR">
                                                                    <Expression>
                                                                        <AssignToProperty propertyName="state">
                                                                            <DecisionTreeVar name="X"/>
                                                                            <Enum owner="state" value="omitted"/>
                                                                        </AssignToProperty>
                                                                    </Expression>
                                                                </BranchResultNode>
                                                            </Outcome>
                                                            <Outcome
                                                                    _EN_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'can be evaluated' : 'is omitted'}."
                                                                    _EN_nextStepExplanation="This is incorrect. Given the above, ${X} is omitted, and so cannot be evaluated now."
                                                                    _EN_nextStepQuestion="What can we conclude in this case?"
                                                                    _RU_nextStepBranchResult="${$branchResult == BranchResult:CORRECT ? 'может быть вычислен' : 'опускается'}."
                                                                    _RU_nextStepExplanation="Это неверно. С учетом сказанного выше, ${X}[case='и'] опускается, а значит не может быть вычислен."
                                                                    _RU_nextStepQuestion="Какой вывод можно сделать в таком случае?"
                                                                    _TEMPLATING_ID="123" value="(false;true)">
                                                                <BranchResultNode
                                                                        _EN_explanation="it belongs to ${X=&gt;isInOperandOf(T).placement}[case='п'] operand of ${T}[case='р'] whose ${T.firstOperandPlacement} operand evaluates to ${T-&gt;hasOperand&lt;placement=T.firstOperandPlacement&gt;.evaluatesTo} which forbids evaluation of ${X}[case='р']."
                                                                        _RU_explanation="он находится в ${X=&gt;isInOperandOf(T).placement}[case='п'] операнде ${T}[case='р'], чей ${T.firstOperandPlacement} операнд имеет значение ${T-&gt;hasOperand&lt;placement=T.firstOperandPlacement&gt;.evaluatesTo}, что блокирует вычисление ${X}[case='р']."
                                                                        _TEMPLATING_ID="124" _alias="X опускается"
                                                                        _error="strict.leftShouldBeFalse_omittedInRight"
                                                                        _law="error_base_student_error_strict_operands_order"
                                                                        _skill="should_strict_order_current_operand_be_omitted_while_solving"
                                                                        value="ERROR">
                                                                    <Expression>
                                                                        <AssignToProperty propertyName="state">
                                                                            <DecisionTreeVar name="X"/>
                                                                            <Enum owner="state" value="omitted"/>
                                                                        </AssignToProperty>
                                                                    </Expression>
                                                                </BranchResultNode>
                                                            </Outcome>
                                                        </TupleQuestionNode>
                                                    </Outcome>
                                                </QuestionNode>
                                            </Outcome>
                                        </CycleAggregationNode>
                                    </Outcome>
                                </QuestionNode>
                            </Outcome>
                        </QuestionNode>
                    </ThoughtBranch>
                    <Outcome value="NULL">
                        <BranchResultNode
                                _EN_explanation="the expression does not contain unevaluated operators with strict order of operand evaluation."
                                _RU_explanation="в выражении нет невычисленных операторов со строгим порядком вычисления операндов."
                                _TEMPLATING_ID="125" _skill="expression_strict_order_operators_present"
                                value="CORRECT"/>
                    </Outcome>
                    <Outcome value="CORRECT">
                        <BranchResultNode value="CORRECT"/>
                    </Outcome>
                    <Outcome value="ERROR">
                        <BranchResultNode value="ERROR"/>
                    </Outcome>
                </CycleAggregationNode>
            </ThoughtBranch>
            <ThoughtBranch
                    _RU_description="вычислению ${X}[case='р'] ${$branchResult == BranchResult:CORRECT ? 'не' : ''} мешают операторы вызова функций со строгим порядком вычисления аргументов"
                    _RU_nextStepExplanation="Это неверно. Прежде всего необходимо найти все вызовы функций с несколькими аргументами, которые могут помешать вычислению ${X}[case='р']"
                    _RU_nextStepQuestion="С чего надо начать при определении того, мешают ли вычислению ${X}[case='р'] операторы вызова функций со строгим порядком аргументов?"
                    _TEMPLATING_ID="126" _alias="strict_central">
                <QuestionNode
                        _EN_asNextStep="We need to check if ${obj:currentLanguage} has a strict function call argument evaluation order"
                        _EN_endingCause="because ${obj:currentLanguage} does not have a strict function evaluation order"
                        _EN_question="Does ${obj:currentLanguage} have a strict function call argument evaluation order?"
                        _RU_asNextStep="Необходимо проверить, имеет ли ${obj:currentLanguage} строгий порядок вычисления аргументов вызовов функций"
                        _RU_endingCause="потому что ${obj:currentLanguage} не имеет строгого порядка вычисления функций"
                        _RU_question="Имеет ли ${obj:currentLanguage} строгий порядок вычисления аргументов вызовов функций?"
                        _TEMPLATING_ID="127" _alias="Does the language have strict order of central operands?">
                    <Expression>
                        <GetPropertyValue propertyName="isStrictOrderCentralOperands">
                            <Object name="currentLanguage"/>
                        </GetPropertyValue>
                    </Expression>
                    <Outcome
                            _EN_explanation="${obj:currentLanguage} does not support strict ordering of arguments in the function call operator"
                            _EN_nextStepExplanation="That is incorrect. The ${obj:currentLanguage} language does not support strict ordering of arguments in the function call operator"
                            _EN_nextStepQuestion="Given that ${obj:currentLanguage} does not support strict ordering of arguments in the function call operator, what conclusion should we draw?"
                            _EN_text="${obj:currentLanguage} does not support strict ordering of arguments in the function call operator"
                            _RU_explanation="${obj:currentLanguage} не поддерживает строгий порядок аргументов вызова функций"
                            _RU_nextStepExplanation="Это неверно. Язык ${obj:currentLanguage} не имеет строгого порядка аргументов в операторе вызова функций"
                            _RU_nextStepQuestion="Учитывая, что ${obj:currentLanguage} не поддерживает строгий порядок аргументов вызова функции, какой вывод нужно сделать?"
                            _RU_text="${obj:currentLanguage} не имеет строгого порядка аргументов в операторе вызова функций"
                            _TEMPLATING_ID="128" value="false">
                        <BranchResultNode
                                _EN_explanation="${obj:currentLanguage} allows evaluating of function arguments in any order."
                                _RU_explanation="${obj:currentLanguage} разрешает вычисление аргументов функции в любом порядке."
                                _TEMPLATING_ID="129" _skill="are_central_operands_strict_order" value="CORRECT"/>
                    </Outcome>
                    <Outcome
                            _EN_explanation="${obj:currentLanguage} supports strict function call argument ordering by specification"
                            _EN_nextStepExplanation="That's incorrect. ${obj:currentLanguage} supports strict function call argument ordering by specification"
                            _EN_nextStepQuestion="Given the strict function call argument ordering in ${obj:currentLanguage}[case='п'], what should be done next?"
                            _EN_text="${obj:currentLanguage} supports strict function call argument ordering"
                            _RU_explanation="${obj:currentLanguage} по спецификации поддерживает строгий порядок аргументов вызова функций"
                            _RU_nextStepExplanation="Это неверно. ${obj:currentLanguage} по спецификации поддерживает строгий порядок аргументов вызова функций"
                            _RU_nextStepQuestion="Учитывая строгий порядок аргументов вызова функций в ${obj:currentLanguage}[case='п'], что нужно сделать дальше?"
                            _RU_text="${obj:currentLanguage} поддерживает строгий порядок аргументов вызова функций"
                            _TEMPLATING_ID="130" value="true">
                        <CycleAggregationNode
                                _EN_asNextStep="Need to check all such function call operators that can have multiple arguments and ${X} between tokens of this operator"
                                _EN_endingCause="because there are no function call operators that can have multiple arguments and ${X} between tokens of this operator"
                                _EN_question="Find all such function call operators that can have multiple arguments and ${X} between tokens of this operator"
                                _RU_asNextStep="Необходимо проверить все такие операторы вызова функций, которые могут иметь несколько аргументов и ${X} между токенами этого оператора"
                                _RU_endingCause="потому что нет операторов вызова функций, которые могут иметь несколько аргументов и ${X} между токенами этого оператора"
                                _RU_question="Найдите все такие операторы вызова функций, которые могут иметь несколько аргументов и ${X} между токенами этого оператора"
                                _TEMPLATING_ID="131" operator="AND">
                            <DecisionTreeVarDecl name="V" type="operator"/>
                            <SelectorExpression>
                                <LogicalAnd>
                                    <LogicalAnd>
                                        <GetPropertyValue propertyName="canHaveManyCentralOperands">
                                            <Variable name="V"/>
                                        </GetPropertyValue>
                                        <ExistenceQuantifier type="token" varName="V1">
                                            <CheckRelationship relationshipName="belongsTo">
                                                <Variable name="V1"/>
                                                <Variable name="V"/>
                                            </CheckRelationship>
                                            <CheckRelationship relationshipName="rightOf">
                                                <DecisionTreeVar name="X1"/>
                                                <Variable name="V1"/>
                                            </CheckRelationship>
                                        </ExistenceQuantifier>
                                    </LogicalAnd>
                                    <ExistenceQuantifier type="token" varName="V2">
                                        <CheckRelationship relationshipName="belongsTo">
                                            <Variable name="V2"/>
                                            <Variable name="V"/>
                                        </CheckRelationship>
                                        <CheckRelationship relationshipName="leftOf">
                                            <DecisionTreeVar name="X1"/>
                                            <Variable name="V2"/>
                                        </CheckRelationship>
                                    </ExistenceQuantifier>
                                </LogicalAnd>
                            </SelectorExpression>
                            <ThoughtBranch
                                    _EN_nextStepExplanation="That's incorrect. First, we need to find all function calls that contain ${X} in their arguments."
                                    _EN_nextStepQuestion="Given that function call operators have been found that contain ${X}, what should we do next?"
                                    _RU_nextStepExplanation="Это неверно. Прежде всего необходимо найти все вызовы функций, в аргументах которых есть ${X}"
                                    _RU_nextStepQuestion="Учитывая, что найдены операторы вызова функций, в которых есть ${X}, что нужно делать дальше?"
                                    _TEMPLATING_ID="132">
                                <FindActionNode
                                        _EN_asNextStep="We need to check if there is a comma that is not an operator between ${V}[case='т'] and ${X}[case='т']."
                                        _EN_endingCause="because there is no comma between ${V}[case='т'] and ${X}[case='т']."
                                        _EN_question="Find a comma that is not an operator between ${V}[case='т'] and ${X}[case='т']?"
                                        _RU_asNextStep="Необходимо проверить, есть ли запятая, которая не является оператором, между ${V}[case='т'] и ${X}[case='т']."
                                        _RU_endingCause="потому что запятой между между ${V}[case='т'] и ${X}[case='т'] нет."
                                        _RU_question="Найдите запятую, которая не является оператором, между ${V}[case='т'] и ${X}[case='т']?"
                                        _TEMPLATING_ID="133">
                                    <DecisionTreeVarDecl name="W" type="separator"/>
                                    <Expression>
                                        <GetByCondition type="separator" varName="w">
                                            <LogicalAnd>
                                                <CheckRelationship relationshipName="isBetween">
                                                    <GetByCondition type="token" varName="t">
                                                        <CheckRelationship relationshipName="has">
                                                            <Variable name="w"/>
                                                            <Variable name="t"/>
                                                        </CheckRelationship>
                                                    </GetByCondition>
                                                    <GetByCondition type="token" varName="V1">
                                                        <LogicalAnd>
                                                            <CheckRelationship relationshipName="belongsTo">
                                                                <Variable name="V1"/>
                                                                <DecisionTreeVar name="V"/>
                                                            </CheckRelationship>
                                                            <CheckRelationship relationshipName="rightOf">
                                                                <DecisionTreeVar name="X1"/>
                                                                <Variable name="V1"/>
                                                            </CheckRelationship>
                                                        </LogicalAnd>
                                                    </GetByCondition>
                                                    <DecisionTreeVar name="X1"/>
                                                </CheckRelationship>
                                                <LogicalNot>
                                                    <LogicalOr>
                                                        <ExistenceQuantifier type="token" varName="sep">
                                                            <CheckClass>
                                                                <GetByRelationship relationshipName="belongsTo">
                                                                    <Variable name="sep"/>
                                                                </GetByRelationship>
                                                                <Class name="separator"/>
                                                            </CheckClass>
                                                            <CheckRelationship relationshipName="isBetween">
                                                                <Variable name="sep"/>
                                                                <GetByCondition type="token" varName="t">
                                                                    <CheckRelationship relationshipName="has">
                                                                        <Variable name="w"/>
                                                                        <Variable name="t"/>
                                                                    </CheckRelationship>
                                                                </GetByCondition>
                                                                <DecisionTreeVar name="X"/>
                                                            </CheckRelationship>
                                                        </ExistenceQuantifier>
                                                        <ExistenceQuantifier type="token" varName="call">
                                                            <LogicalAnd>
                                                                <CheckClass>
                                                                    <GetByRelationship relationshipName="belongsTo">
                                                                        <Variable name="call"/>
                                                                    </GetByRelationship>
                                                                    <Class name="operator" />
                                                                </CheckClass>
                                                                <GetPropertyValue propertyName="canHaveManyCentralOperands">
                                                                    <Cast>
                                                                        <GetByRelationship relationshipName="belongsTo">
                                                                            <Variable name="call"/>
                                                                        </GetByRelationship>
                                                                        <Class name="operator" />
                                                                    </Cast>
                                                                </GetPropertyValue>
                                                            </LogicalAnd>
                                                            <LogicalAnd>
                                                                <CheckRelationship relationshipName="isBetween">
                                                                    <Variable name="call"/>
                                                                    <GetByCondition type="token" varName="V1">
                                                                        <LogicalAnd>
                                                                            <CheckRelationship relationshipName="belongsTo">
                                                                                <Variable name="V1"/>
                                                                                <DecisionTreeVar name="V"/>
                                                                            </CheckRelationship>
                                                                            <CheckRelationship relationshipName="rightOf">
                                                                                <DecisionTreeVar name="X1"/>
                                                                                <Variable name="V1"/>
                                                                            </CheckRelationship>
                                                                        </LogicalAnd>
                                                                    </GetByCondition>
                                                                    <GetByCondition type="token" varName="t">
                                                                        <CheckRelationship relationshipName="has">
                                                                            <Variable name="w"/>
                                                                            <Variable name="t"/>
                                                                        </CheckRelationship>
                                                                    </GetByCondition>
                                                                </CheckRelationship>
                                                                <ExistenceQuantifier type="token" varName="call2">
                                                                    <LogicalAnd>
                                                                        <Compare operator="EQ">
                                                                            <GetByRelationship relationshipName="belongsTo">
                                                                                <Variable name="call"/>
                                                                            </GetByRelationship>
                                                                            <GetByRelationship relationshipName="belongsTo">
                                                                                <Variable name="call2"/>
                                                                            </GetByRelationship>
                                                                        </Compare>
                                                                        <Compare operator="NEQ">
                                                                            <Variable name="call"/>
                                                                            <Variable name="call2"/>
                                                                        </Compare>
                                                                    </LogicalAnd>
                                                                    <LogicalNot>
                                                                        <CheckRelationship relationshipName="isBetween">
                                                                            <Variable name="call2"/>
                                                                            <GetByCondition type="token" varName="V1">
                                                                                <LogicalAnd>
                                                                                    <CheckRelationship relationshipName="belongsTo">
                                                                                        <Variable name="V1"/>
                                                                                        <DecisionTreeVar name="V"/>
                                                                                    </CheckRelationship>
                                                                                    <CheckRelationship relationshipName="rightOf">
                                                                                        <DecisionTreeVar name="X1"/>
                                                                                        <Variable name="V1"/>
                                                                                    </CheckRelationship>
                                                                                </LogicalAnd>
                                                                            </GetByCondition>
                                                                            <GetByCondition type="token" varName="t">
                                                                                <CheckRelationship relationshipName="has">
                                                                                    <Variable name="w"/>
                                                                                    <Variable name="t"/>
                                                                                </CheckRelationship>
                                                                            </GetByCondition>
                                                                        </CheckRelationship>
                                                                    </LogicalNot>
                                                                </ExistenceQuantifier>
                                                            </LogicalAnd>
                                                        </ExistenceQuantifier>
                                                    </LogicalOr>
                                                </LogicalNot>
                                            </LogicalAnd>
                                        </GetByCondition>
                                    </Expression>
                                    <Outcome _EN_explanation="${V} does not have multiple arguments"
                                             _EN_nextStepExplanation="That is incorrect. Since ${V} does not have multiple arguments, it does not block the evaluation of ${X}[case='р']"
                                             _EN_nextStepQuestion="Given that ${V} does not have multiple arguments, what should we do next?"
                                             _EN_text="There is no comma between ${V}[case='т'] and ${X}[case='т']."
                                             _RU_explanation="${V} не имеет нескольких аргументов"
                                             _RU_nextStepExplanation="Это неверно. Так как ${V} не имеет несколько аргументов и вычислению ${X}[case='р'] не мешает"
                                             _RU_nextStepQuestion="Учитывая что ${V} не имеет нескольких аргументов, что нужно делать дальше?"
                                             _RU_text="Нет запятой между ${V}[case='т'] и ${X}[case='т']."
                                             _TEMPLATING_ID="134" value="false">
                                        <BranchResultNode
                                                _EN_explanation="${obj:currentLanguage} evaluates function arguments from left to right but ${X} is in the first argument of ${V}"
                                                _RU_explanation="${obj:currentLanguage} вычисляет аргументы функций слева направо, но ${X} находится в первом аргументе ${V}[case='р']"
                                                _TEMPLATING_ID="135" _skill="no_comma_in_central_operands"
                                                value="CORRECT"/>
                                    </Outcome>
                                    <Outcome _EN_explanation="${W} is not the first argument of ${V}[case='р']."
                                             _EN_nextStepExplanation="That's incorrect. ${W} is not the first argument of ${V}[case='р']."
                                             _EN_nextStepQuestion="Given that ${W} is not the first argument of ${V}[case='р'], what should we do next?"
                                             _EN_text="Found a comma between the left token ${V}[case='р'] and ${W}[case='т']."
                                             _RU_explanation="${W} не является первым аргументом ${V}[case='р']."
                                             _RU_nextStepExplanation="Это неверно. ${W} не является первым аргументом ${V}[case='р']."
                                             _RU_nextStepQuestion="Учитывая, что ${W} не является первым аргументом ${V}[case='р'], что нужно делать дальше?"
                                             _RU_text="Найдена запятая между левым токеном ${V}[case='р'] и ${W}[case='т']."
                                             _TEMPLATING_ID="136" value="true">
                                        <QuestionNode
                                                _EN_asNextStep="Need to check if there is an unevaluated operator between ${V}[case='т'] and ${W}[case='т']"
                                                _EN_endingCause="because ${res? 'there is' : 'no'} unevaluated operator between ${V}[case='т'] and ${W}[case='т']"
                                                _EN_question="Is there an unevaluated operator between ${V}[case='т'] and ${W}[case='т']"
                                                _RU_asNextStep="Необходимо проверить, есть ли невычисленный оператор между ${V}[case='т'] и ${W}[case='т']"
                                                _RU_endingCause="потому что ${res ? 'есть' : 'нет'} невычисленного оператора между ${V}[case='т'] и ${W}[case='т']"
                                                _RU_question="Есть ли невычисленный оператор между ${V}[case='т'] и ${W}[case='т']"
                                                _TEMPLATING_ID="137">
                                            <Expression>
                                                <ExistenceQuantifier type="operator" varName="R">
                                                    <Compare operator="Equal">
                                                        <GetPropertyValue propertyName="state">
                                                            <Variable name="R"/>
                                                        </GetPropertyValue>
                                                        <Enum owner="state" value="unevaluated"/>
                                                    </Compare>
                                                    <CheckRelationship relationshipName="isBetween">
                                                        <Variable name="R"/>
                                                        <GetByCondition type="token" varName="V1">
                                                            <LogicalAnd>
                                                                <CheckRelationship relationshipName="belongsTo">
                                                                    <Variable name="V1"/>
                                                                    <DecisionTreeVar name="V"/>
                                                                </CheckRelationship>
                                                                <CheckRelationship relationshipName="rightOf">
                                                                    <DecisionTreeVar name="X1"/>
                                                                    <Variable name="V1"/>
                                                                </CheckRelationship>
                                                            </LogicalAnd>
                                                        </GetByCondition>
                                                        <DecisionTreeVar name="W"/>
                                                    </CheckRelationship>
                                                </ExistenceQuantifier>
                                            </Expression>
                                            <Outcome
                                                    _EN_explanation="All operators evaluated between ${V}[case='т'] and ${W}[case='т']"
                                                    _EN_nextStepExplanation="That is incorrect. All operators evaluated between ${V}[case='т'] and ${W}[case='т']"
                                                    _EN_nextStepQuestion="Given that there is no unevaluated operator between ${V}[case='т'] and ${W}[case='т'], what to do next?"
                                                    _EN_text="No unevaluated operator between ${V}[case='т'] and ${W}[case='т']"
                                                    _RU_explanation="Все операторы вычислены между ${V}[case='т'] и ${W}[case='т']"
                                                    _RU_nextStepExplanation="Это неверно. Все операторы вычислены между ${V}[case='т'] и ${W}[case='т']"
                                                    _RU_nextStepQuestion="Учитывая, что нет невычисленного оператора между ${V}[case='т'] и ${W}[case='т'], что делать дальше?"
                                                    _RU_text="Нет невычисленного оператора между ${V}[case='т'] и ${W}[case='т']"
                                                    _TEMPLATING_ID="138" value="true">
                                                <BranchResultNode
                                                        _EN_explanation="${obj:currentLanguage} evaluates function arguments from left to right but at least one argument of ${V} to the left of ${X} is not evaluated"
                                                        _RU_explanation="${obj:currentLanguage} вычисляет аргументы функций слева направо, но не все аргументы функции ${V} слева от ${X}[case='р'] вычислены"
                                                        _TEMPLATING_ID="139"
                                                        _skill="previous_central_operands_are_unevaluated"
                                                        value="ERROR"/>
                                            </Outcome>
                                            <Outcome
                                                    _EN_explanation="The expression did not evaluate the operator between ${V}[case='т'] and ${W}[case='т']."
                                                    _EN_nextStepExplanation="That is incorrect. Found an unevaluated the operator between ${V}[case='т'] and ${W}[case='т']."
                                                    _EN_nextStepQuestion="Given that the expression did not evaluate the operator between ${V}[case='т'] and ${W}[case='т'], what should be done next?"
                                                    _EN_text="Found an unevaluated operator between ${V}[case='т'] and ${W}[case='т']."
                                                    _RU_explanation="В выражении не вычислен оператор между ${V}[case='т'] и ${W}[case='т']."
                                                    _RU_nextStepExplanation="Это неверно. Найден невычисленный оператор между ${V}[case='т'] и ${W}[case='т']."
                                                    _RU_nextStepQuestion="Учитывая, что в выражении не вычислен оператор между ${V}[case='т'] и ${W}[case='т'], что необходимо сделать дальше?"
                                                    _RU_text="Найден невычисленный оператор между ${V}[case='т'] и ${W}[case='т']."
                                                    _TEMPLATING_ID="140" value="false">
                                                <BranchResultNode
                                                        _EN_explanation="${obj:currentLanguage} evaluates function arguments from left to right but all arguments of ${V} to the left of the argument containing ${X} are evaluated"
                                                        _RU_explanation="${obj:currentLanguage} вычисляет аргументы функций слева направо, но все аргументы функции ${V} слева от аргумента содержащего ${X}[case='в'] вычислены"
                                                        _TEMPLATING_ID="141"
                                                        _skill="previous_central_operands_are_unevaluated"
                                                        value="CORRECT"/>
                                            </Outcome>
                                        </QuestionNode>
                                    </Outcome>
                                </FindActionNode>
                            </ThoughtBranch>
                            <Outcome
                                    _EN_explanation="There are no function call operators that do not have ${X}[case='p'] in multiple arguments"
                                    _EN_nextStepExplanation="This is incorrect. There are no function call operators in the expression that do not have ${X}[case='p'] in multiple arguments"
                                    _EN_nextStepQuestion="Given that there are no function call operators that do not have ${X}[case='p'] in multiple arguments, what should we do next?"
                                    _EN_text="There are no function call operators that do not have ${X}[case='p'] in multiple arguments"
                                    _RU_explanation="Нет таких операторов вызова функций, в нескольких аргументах которого нет ${X}[case='р']"
                                    _RU_nextStepExplanation="Это неверно. В выражении нет таких операторов вызова функций, в нескольких аргументах которого нет ${X}[case='р']"
                                    _RU_nextStepQuestion="Учитывая, что нет таких операторов вызова функций, в нескольких аргументах которого нет ${X}[case='р'], что нужно делать дальше?"
                                    _RU_text="Нет таких операторов вызова функций, в нескольких аргументах которого нет ${X}[case='р']"
                                    _TEMPLATING_ID="142" value="NULL">
                                <BranchResultNode
                                        _EN_explanation="${obj:currentLanguage} evaluates function arguments from left to right but ${X} is not inside any function argument"
                                        _RU_explanation="${obj:currentLanguage} вычисляет аргументы функций слева направо, но ${X} не находится внутри вызова функции"
                                        _TEMPLATING_ID="143" _skill="no_current_in_many_central_operands"
                                        value="CORRECT"/>
                            </Outcome>
                        </CycleAggregationNode>
                    </Outcome>
                </QuestionNode>
            </ThoughtBranch>
            <Outcome value="CORRECT">
                <BranchResultNode value="CORRECT">
                    <Expression>
                        <Block>
                            <AssignToProperty propertyName="state">
                                <DecisionTreeVar name="X"/>
                                <Enum owner="state" value="evaluated"/>
                            </AssignToProperty>
                            <ForAllQuantifier type="operand" varName="x_op">
                                <LogicalAnd>
                                    <CheckRelationship relationshipName="isOperandOf">
                                        <Variable name="x_op"/>
                                        <DecisionTreeVar name="X"/>
                                    </CheckRelationship>
                                    <Compare operator="NotEqual">
                                        <GetPropertyValue propertyName="state">
                                            <Variable name="x_op"/>
                                        </GetPropertyValue>
                                        <Enum owner="state" value="omitted"/>
                                    </Compare>
                                </LogicalAnd>
                                <AssignToProperty propertyName="state">
                                    <Variable name="x_op"/>
                                    <Enum owner="state" value="used"/>
                                </AssignToProperty>
                            </ForAllQuantifier>
                        </Block>
                    </Expression>
                </BranchResultNode>
            </Outcome>
            <Outcome value="ERROR">
                <BranchResultNode value="ERROR"/>
            </Outcome>
        </BranchAggregationNode>
    </ThoughtBranch>
</DecisionTree>
