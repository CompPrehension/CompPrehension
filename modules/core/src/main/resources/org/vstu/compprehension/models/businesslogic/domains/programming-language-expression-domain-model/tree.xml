<StartNode>
    <!-- Данное дерево отличается тем, что имеет 4 ветки, использует и проставляет omitted,
     но не составляет дерево выражения (только использует его)-->
    <InputVariables>
        <DecisionTreeVarDecl name="X" type="operator" />
        <AdditionalVarDecl name="X1" type="token">
            <Expression>
                <GetExtreme extremeVarName="x1" varName="x_token" type="token">
                    <LogicalNot>
                        <ExistenceQuantifier varName="x_token" type="token">
                            <CheckRelationship>
                                <Relationship name="has" />
                                <DecisionTreeVar name="X" />
                                <Variable name="x_token" />
                            </CheckRelationship>
                            <CheckRelationship>
                                <Relationship name="leftOf" />
                                <Variable name="x_token" />
                                <Variable name="x1" />
                            </CheckRelationship>
                        </ExistenceQuantifier>
                    </LogicalNot>
                    <CheckRelationship>
                        <Relationship name="has" />
                        <DecisionTreeVar name="X" />
                        <Variable name="x_token" />
                    </CheckRelationship>
                </GetExtreme>
            </Expression>
        </AdditionalVarDecl>
    </InputVariables>
    <ThoughtBranch type="bool" _alias="main"
        _RU_description="${val('X','и')} ${result ? '' : 'не'} может выполниться следующим"
        _EN_description="${val('X','и')} ${result ? 'can' : 'cant'} be evaluated next"
        _RU_hint_prefix="${val('X','и')} может быть вычислен в настоящее время потому, что "
        _EN_hint_prefix="${val('X','и')} can be evaluated, because "
        _RU_error_prefix="${val('X','и')} не может быть вычислен в настоящее время потому, что "
        _EN_error_prefix="${val('X','и')} cannot be evaluated yet, because "
    >
        <LogicAggregationNode id="3" operator="and" _alias="main.and"
            _RU_asNextStep="Необходимо проверить, может ли ${val('X','и')} выполниться следующим."
            _RU_description="${val('X','и')} ${result ? '' : 'не'} может выполниться следующим"
            _RU_endingCause="Потому что есть факторы, мешающие дальнейшему вычислению ${val('X','р')}"
            _EN_asNextStep="We should check if ${val('X','и')} can be evaluated next."
            _EN_description="${val('X','и')} ${result ? 'can' : 'cant'} be evaluated next"
            _EN_endingCause="Because one of the operands of ${val('X','и')} prevents its evaluation"
        >
            <ThoughtBranch type="bool" _alias="central"
                _RU_description="внутренний операнд ${val('X','р')} ${result ? 'не' : ''} требует дальнейших вычислений"
                _RU_nextStepQuestion="С чего надо начать при рассмотрении внутреннего операнда?"
                _RU_nextStepExplanation="Это неверно. Прежде всего необходимо проверить, нужен ли оператору внутренний операнд."
                _EN_description="inner operand of ${val('X','р')} ${result ? 'doesnt require' : 'requires'} further evaluation"
                _EN_nextStepQuestion="What is the first step when considering operator's inner operand?"
                _EN_nextStepExplanation="That's incorrect. One should first check if the operator needs inner operand at all."
            >
                <QuestionNode type="int" _alias="central.isNeeded"
                    _RU_asNextStep="Необходимо проверить, нужен ли ${val('X','д')} внутренний операнд."
                    _RU_question="Сколько токенов имеет ${class('X','и')}?"
                    _RU_endingCause="Потому что ${class('X','и')} не требует внутреннего операнда"
                    _EN_asNextStep="We should check if the operator needs inner operand at all."
                    _EN_question="How many token does ${class('X','и')} have?"
                    _EN_endingCause="Because ${class('X','и')} doesn't need inner operand."
                >
                    <Expression>
                        <GetPropertyValue>
                            <DecisionTreeVar name="X" />
                            <Property name="countOfTokens" />
                        </GetPropertyValue>
                    </Expression>
                    <Outcome value="1"
                        _RU_explanation="Это неверно. ${class('X','и')} имеет только один токен."
                        _RU_nextStepQuestion="Какие выводы можно сделать, если ${class('X','и')} имеет только один токен?"
                        _RU_nextStepExplanation="Это неверно. Т.к. ${class('X','и')} имеет только один токен, а значит, не имеет внутреннего операнда (только левый и правый). Получается, внутренний операнд не может помешать его вычислению."
                        _EN_explanation="That's incorrect. ${class('X','и')} has just one token."
                        _EN_nextStepQuestion="What is the next reasoning step if we know that ${class('X','и')} has just one token?"
                        _EN_nextStepExplanation="That's incorrect. Because ${class('X','и')} has just one token, it can't have an inner operand at all (only a left and a right one). Therefore, no inner operand to prevent its evaluation."
                    >
                        <BranchResultNode value='true' _skill="central_operand_needed"
                            _RU_explanation="${val('X','и')}  имеет одну лексему и поэтому не может иметь центрального операнда."
                            _EN_explanation="${val('X','и')} has one token and so does not have a central operand."
                        />
                    </Outcome>
                    <Outcome value="2"
                        _RU_explanation="Это неверно. ${class('X','и')} имеет два токена."
                        _RU_nextStepQuestion="Какой дальнейший шаг можно сделать, если ${class('X','и')} имеет два токена?"
                        _RU_nextStepExplanation="Это неверно. Т.к. ${class('X','и')} имеет два токена, а значит, требует внутренний операнд, необходимо дальнейшее нахождение и рассмотрение данного операнда."
                        _EN_explanation="That's incorrect. ${class('X','и')} has two tokens."
                        _EN_nextStepQuestion="What is the next reasoning step if we know that ${class('X','и')} has two tokens?"
                        _EN_nextStepExplanation="That's incorrect - ${class('X','и')} having two tokens means it has an inner operand positioned between them. So we need to find the second token of ${val('X','р')}, to then find and check the state of the inner operand."
                    >
                        <FindActionNode _alias="central.findX2"
                            _RU_asNextStep="Необходимо найти второй токен ${val('X','р')}."
                            _RU_question="Найдите второй токен ${val('X', 'Gen')}."
                            _EN_asNextStep="We should find the second token of ${val('X','р')}."
                            _EN_question="Find the second token of ${val('X', 'Gen')}."
                        >
                            <DecisionTreeVarDecl name="X2" type="token" />
                            <Expression>
                                <GetByCondition varName="x2">
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="x2" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckRelationship>
                                                <Relationship name="belongsTo" />
                                                <Variable name="x2" />
                                                <DecisionTreeVar name="X" />
                                            </CheckRelationship>
                                        </LogicalAnd>
                                        <CheckRelationship>
                                            <Relationship name="rightOf" />
                                            <Variable name="x2" />
                                            <DecisionTreeVar name="X1" />
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </GetByCondition>
                            </Expression>
                            <FindError priority="1" _alias="X2_wrongType"
                                _RU_explanation="Это неверно, поскольку ${obj(checked, 'Nom')} не может являться токеном ${class('X', 'Gen')} - он является токеном другого типа."
                                _EN_explanation="That's incorrect, because ${obj(checked, 'Nom')} can't be the token of ${class('X', 'Gen')} - tokens of this type are unrelated to ${class('X', 'Gen')}."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                        </LogicalAnd>
                                        <Compare operator="NOT_EQUAL">
                                            <GetClass>
                                                <GetByRelationship>
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                            </GetClass>
                                            <GetClass>
                                                <DecisionTreeVar name="X" />
                                            </GetClass>
                                        </Compare>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError priority="2" _alias="X2_wrongSide"
                                _RU_explanation="Это неверно - ${obj(checked, 'Nom')} находится не с той стороны от ${val('X1', 'Gen')}."
                                _EN_explanation="That's incorrect - ${obj(checked, 'Nom')} is on the wrong side of ${val('X1', 'Gen')}."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship>
                                            <Relationship name="isBetween" />
                                            <DecisionTreeVar name="X1" />
                                            <DecisionTreeVar name="X2" />
                                            <Variable name="checked" />
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError priority="3" _alias="X2_tooFar"
                                _RU_explanation="Это неверно, ${obj(checked, 'Nom')} слишком далеко, чтобы быть парой для ${val('X1', 'Gen')}."
                                _EN_explanation="That's incorrect, ${obj(checked, 'Nom')} is too far to be the second token to ${val('X1', 'Gen')}."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship>
                                            <Relationship name="isBetween" />
                                            <DecisionTreeVar name="X2" />
                                            <DecisionTreeVar name="X1" />
                                            <Variable name="checked" />
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError priority="4" _alias="X2_tooClose"
                                _RU_explanation="Это неверно, ${obj(checked, 'Nom')} слишком близко, чтобы быть парой для ${val('X1', 'Gen')}."
                                _EN_explanation="That's incorrect, ${obj(checked, 'Nom')} is too close to be the second token to ${val('X1', 'Gen')}."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship>
                                            <Relationship name="isBetween" />
                                            <Variable name="checked" />
                                            <DecisionTreeVar name="X1" />
                                            <DecisionTreeVar name="X2" />
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <Outcome value="found"
                                _RU_explanation="второй токен ${val('X','р')} это ${val('X2','и')}"
                                _EN_explanation="second token of ${val('X','р')} is ${val('X2','и')}"
                            >
                                <QuestionNode type="bool" _alias="central.isUnevaluated"
                                    _RU_asNextStep="Необходимо проверить, есть ли внутри ${val('X','р')} невычисленные операторы."
                                    _RU_question="Есть ли внутри ${val('X','р')} невычисленные операторы?"
                                    _RU_endingCause="Из-за наличия/отсутствия внутри ${val('X','р')} невычисленных операторов."
                                    _EN_asNextStep="We should check if there are unevaluated operators between ${val('X1', 'и')} and ${val('X2', 'и')}."
                                    _EN_question="Are there unevaluated operators between ${val('X1', 'и')} and ${val('X2', 'и')}?"
                                    _EN_endingCause="Because of the presence/absence of unevaluated operators between ${val('X1', 'и')} and ${val('X2', 'и')}."
                                >
                                    <Expression>
                                        <LogicalAnd>
                                            <!-- Patch: В операторах, где есть и левый и центральный
                                            операнд могли появляться лишние сообщения об ошибках.
                                            Поэтому центральный операнд не считается невычисленным,
                                            пока левый операнд не будет вычислен (на тернарные в
                                            питоне по итогам тестов не повлияло)-->
                                            <LogicalOr>
                                                <LogicalNot>
                                                    <GetPropertyValue>
                                                        <DecisionTreeVar name="X" />
                                                        <Property name="needsLeftOperand" />
                                                    </GetPropertyValue>
                                                </LogicalNot>
                                                <LogicalNot>
                                                    <Compare operator="EQUAL">
                                                        <GetPropertyValue>
                                                            <GetByRelationship varName="t">
                                                                <DecisionTreeVar name="X" />
                                                                <Relationship name="hasLeftOperand" />
                                                            </GetByRelationship>
                                                            <Property name="state" />
                                                        </GetPropertyValue>
                                                        <Enum owner="state" value="unevaluated" />
                                                    </Compare>
                                                </LogicalNot>
                                            </LogicalOr>
                                            <ExistenceQuantifier varName="i">
                                                <CheckClass>
                                                    <Variable name="i" />
                                                    <Class name="operator" />
                                                </CheckClass>
                                                <LogicalAnd>
                                                    <CheckRelationship>
                                                        <Relationship name="isBetween" />
                                                        <Variable name="i" />
                                                        <DecisionTreeVar name="X1" />
                                                        <DecisionTreeVar name="X2" />
                                                    </CheckRelationship>
                                                    <Compare operator="EQUAL">
                                                        <GetPropertyValue>
                                                            <Variable name="i" />
                                                            <Property name="state" />
                                                        </GetPropertyValue>
                                                        <Enum owner="state" value="unevaluated" />
                                                    </Compare>
                                                </LogicalAnd>
                                            </ExistenceQuantifier>
                                        </LogicalAnd>
                                    </Expression>
                                    <Outcome value="true"
                                        _RU_explanation="Это неверно. Внутри ${val('X','р')} присутствуют невычисленные операторы."
                                        _RU_nextStepQuestion="Какие выводы можно сделать, если внутри ${val('X','р')} присутствуют невычисленные операторы?"
                                        _RU_nextStepExplanation="Это неверно. Т.к. внутри ${val('X','р')} присутствуют невычисленные операторы, это значит, что его внутренний операнд невычислен и мешает дальнейшему вычислению ${val('X','р')}."
                                        _EN_explanation="That's incorrect. There are unevaluated operators between ${val('X1', 'и')} and ${val('X2', 'и')}."
                                        _EN_nextStepQuestion="What can we conclude if there are unevaluated operators between ${val('X1', 'и')} and ${val('X2', 'и')}?"
                                        _EN_nextStepExplanation="That's incorrect. Any unevaluated operator between ${val('X1', 'и')} and ${val('X2', 'и')}, means that the inner operand of ${val('X','р')} is not fully evaluated. Therefore, it is preventing its further evaluation.."
                                    >
                                        <BranchResultNode value="false"
                                            _skill="is_central_operand_evaluated"
                                            _law="error_base_student_error_in_complex;error_base_student_error_unevaluated_operand;error_base_enclosing_operators"
                                            _error="central.isUnevaluated"
                                            _RU_explanation="еще не вычислен его центральный операнд."
                                            _EN_explanation=" its central operand is not evaluated yet."
                                        />
                                    </Outcome>
                                    <Outcome value="false"
                                        _RU_explanation="Это неверно. Все операторы внутри  ${val('X','р')} вычислены."
                                        _RU_nextStepQuestion="Какие выводы можно сделать, если  Все операторы внутри  ${val('X','р')} вычислены?"
                                        _RU_nextStepExplanation="Это неверно. Т.к. внутри ${val('X','р')} нет невычисленные операторов, это значит, что его внутренний операнд полностью вычислен и не мешает дальнейшему вычислению ${val('X','р')}."
                                        _EN_explanation="That's incorrect. There are no unevaluated operators between ${val('X1', 'и')} and ${val('X2', 'и')}."
                                        _EN_nextStepQuestion="What can we conclude if there are no unevaluated operators between ${val('X1', 'и')} and ${val('X2', 'и')}?"
                                        _EN_nextStepExplanation="That's incorrect. If all of the operators between ${val('X1', 'и')} and ${val('X2', 'и')} are evaluated, then the inner operand of ${val('X','р')} is fully evaluated. Therefore, it is not preventing its further evaluation."
                                    >
                                        <BranchResultNode value="true"
                                            _skill="is_central_operand_evaluated"
                                            _RU_explanation=" его центральный операнд уже вычислен."
                                            _EN_explanation="its central operand has been evaluated."
                                        />
                                    </Outcome>
                                </QuestionNode>
                            </Outcome>
                        </FindActionNode>
                    </Outcome>
                </QuestionNode>
            </ThoughtBranch>
            <ThoughtBranch type="bool" _alias="left"
                _RU_description="левый операнд ${val('X','р')} ${result ? 'не' : ''} требует дальнейших вычислений"
                _RU_nextStepQuestion="С чего надо начать при рассмотрении левого операнда?"
                _RU_nextStepExplanation="Это неверно. Прежде всего необходимо проверить, нужен ли оператору левый операнд."
                _EN_description="left operand of ${val('X','р')} ${result ? 'doesnt require' : 'requires'} further evaluation"
                _EN_nextStepQuestion="What is the first step when considering operator's left operand?"
                _EN_nextStepExplanation="That's incorrect. One should first check if the operator needs left operand at all."
            >
                <QuestionNode type="bool" _alias="left.isNeeded"
                    _RU_asNextStep="Необходимо проверить, нужен ли ${val('X','д')} левый операнд."
                    _RU_question="Нужен ли ${class('X','д')} левый операнд?"
                    _RU_endingCause="Потому что ${val('X','и')} не требует левого операнда"
                    _EN_asNextStep="We should check if ${val('X','д')} needs a left operand."
                    _EN_question="Does ${class('X','д')} need a left operand?"
                    _EN_endingCause="Because ${val('X','и')} doesn't need a left operand."
                >
                    <Expression>
                        <GetPropertyValue>
                            <DecisionTreeVar name="X" />
                            <Property name="needsLeftOperand" />
                        </GetPropertyValue>
                    </Expression>
                    <Outcome value="false"
                        _RU_explanation="Это неверно. ${class('X','и')} не имеет (не требует) левого операнда."
                        _RU_nextStepQuestion="Какие выводы можно сделать, если ${val('X','и')} не требует левого операнда?"
                        _RU_nextStepExplanation="Это неверно. Если оператор не имеет левого операнда, то и дальнейших вычислений его левый операнд требовать не может."
                        _EN_explanation="That's incorrect, because ${class('X','и')} doesn't need a left operand."
                        _EN_nextStepQuestion="What is the next reasoning step if we know that ${class('X','и')} doesn't need a left operand?"
                        _EN_nextStepExplanation="That's incorrect. If it doesn't need a left operand, then the left operand can't prevent its further evaluation."
                    >
                        <BranchResultNode value="true" _skill="left_operand_needed"
                            _RU_explanation="он не имеет левого операнда"
                            _EN_explanation="it does not have a left operand"
                        />
                    </Outcome>
                    <Outcome value="true"
                        _RU_explanation="Это неверно. ${class('X','д')} всегда необходим левый операнд."
                        _RU_nextStepQuestion="Какие выводы можно сделать, если ${val('X','д')} нужен левый операнд?"
                        _RU_nextStepExplanation="Это неверно. Необходимо дальше рассмотреть потенциально конкурирующие с ${val('X','т')} операторы, и делать выводы исходя из их наличия/отсуствия."
                        _EN_explanation="That's incorrect, because ${class('X','и')} does require a left operand."
                        _EN_nextStepQuestion="What is the next reasoning step if we know that ${class('X','и')} needs a left operand?"
                        _EN_nextStepExplanation="That's incorrect. From here, one should check if there are any operators that should still be evaluated in the left operand, and then reason based on that."
                    >
                        <FindActionNode _alias="left.findY"
                            _RU_asNextStep="Необходимо найти потенциально мешающий оператор слева от ${val('X','р')}"
                            _RU_question="Какой оператор может помешать выполнению ${val('X', 'Gen')} слева?"
                            _RU_endingCause="Потому что слева от ${val('X','р')} находятся только вычисленные операторы"
                            _EN_asNextStep="We should look for an unevaluated operator that could be in the left operand of ${val('X','р')}, preventing its further evaluation."
                            _EN_question="Find an operator that could be in the left operand of ${val('X','р')}, preventing its further evaluation?"
                            _EN_endingCause="Because there are only evaluated operators to the left of ${val('X','р')}."
                        >
                            <DecisionTreeVarDecl name="Y1" type="token" />
                            <Expression>
                                <GetExtreme extremeVarName="y1_ex" varName="y1">
                                    <LogicalAnd>
                                        <!-- Patch: между ближайшим левым и текущим ищется
                                        запятая-разделитель, которая не позволяет найти ближайший
                                        оператор в вызове функций-->
                                        <LogicalNot>
                                            <ExistenceQuantifier varName="commaSep" type="token">
                                                <CheckRelationship>
                                                    <Relationship name="isBetween" />
                                                    <Variable name="commaSep" />
                                                    <Variable name="y1_ex" />
                                                    <DecisionTreeVar name="X" />
                                                </CheckRelationship>
                                                <LogicalAnd>
                                                    <CheckClass>
                                                        <GetByRelationship varName="var">
                                                            <Variable name="commaSep" />
                                                            <Relationship name="belongsTo" />
                                                        </GetByRelationship>
                                                        <Class name="separator" />
                                                    </CheckClass>
                                                    <LogicalAnd>
                                                        <CheckRelationship>
                                                            <Relationship name="isInOperandOf" />
                                                            <GetByRelationship varName="y1_ex_op">
                                                                <Variable name="y1_ex" />
                                                                <Relationship name="belongsTo" />
                                                            </GetByRelationship>
                                                            <GetByRelationship
                                                                varName="ownerOfComma">
                                                                <GetByRelationship varName="var">
                                                                    <Variable name="commaSep" />
                                                                    <Relationship name="belongsTo" />
                                                                </GetByRelationship>
                                                                <Relationship
                                                                    name="belongsToOperator" />
                                                            </GetByRelationship>
                                                        </CheckRelationship>
                                                        <CheckRelationship>
                                                            <Relationship name="isInOperandOf" />
                                                            <DecisionTreeVar name="X" />
                                                            <GetByRelationship
                                                                varName="ownerOfComma">
                                                                <GetByRelationship varName="var">
                                                                    <Variable name="commaSep" />
                                                                    <Relationship name="belongsTo" />
                                                                </GetByRelationship>
                                                                <Relationship
                                                                    name="belongsToOperator" />
                                                            </GetByRelationship>
                                                        </CheckRelationship>
                                                    </LogicalAnd>
                                                </LogicalAnd>
                                            </ExistenceQuantifier>
                                        </LogicalNot>
                                        <LogicalNot>
                                            <ExistenceQuantifier varName="y1">
                                                <LogicalAnd>
                                                    <LogicalAnd>
                                                        <CheckClass>
                                                            <Variable name="y1" />
                                                            <Class name="token" />
                                                        </CheckClass>
                                                        <CheckRelationship>
                                                            <Relationship name="leftOf" />
                                                            <Variable name="y1" />
                                                            <DecisionTreeVar name="X" />
                                                        </CheckRelationship>
                                                    </LogicalAnd>
                                                    <LogicalAnd>
                                                        <CheckClass>
                                                            <GetByRelationship varName="var">
                                                                <Variable name="y1" />
                                                                <Relationship name="belongsTo" />
                                                            </GetByRelationship>
                                                            <Class name="operator" />
                                                        </CheckClass>
                                                        <Compare operator="EQUAL">
                                                            <GetPropertyValue>
                                                                <GetByRelationship varName="var">
                                                                    <Variable name="y1" />
                                                                    <Relationship name="belongsTo" />
                                                                </GetByRelationship>
                                                                <Property name="state" />
                                                            </GetPropertyValue>
                                                            <Enum owner="state" value="unevaluated" />
                                                        </Compare>
                                                    </LogicalAnd>
                                                </LogicalAnd>
                                                <CheckRelationship>
                                                    <Relationship name="isBetween" />
                                                    <Variable name="y1" />
                                                    <Variable name="y1_ex" />
                                                    <DecisionTreeVar name="X" />
                                                </CheckRelationship>
                                            </ExistenceQuantifier>
                                        </LogicalNot>
                                    </LogicalAnd>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="y1" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckRelationship>
                                                <Relationship name="leftOf" />
                                                <Variable name="y1" />
                                                <DecisionTreeVar name="X" />
                                            </CheckRelationship>
                                        </LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="y1" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                            <Compare operator="EQUAL">
                                                <GetPropertyValue>
                                                    <GetByRelationship varName="var">
                                                        <Variable name="y1" />
                                                        <Relationship name="belongsTo" />
                                                    </GetByRelationship>
                                                    <Property name="state" />
                                                </GetPropertyValue>
                                                <Enum owner="state" value="unevaluated" />
                                            </Compare>
                                        </LogicalAnd>
                                    </LogicalAnd>
                                </GetExtreme>
                            </Expression>
                            <FindError priority="1" _alias="Y1_wrongSide"
                                _RU_explanation="Это неверно, поскольку ${obj(checked, 'Nom')} находится справа от ${val('X', 'Gen')}."
                                _EN_explanation="That's incorrect, because ${obj(checked, 'Nom')} is to the right of ${val('X', 'Gen')}."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship>
                                            <Relationship name="rightOf" />
                                            <Variable name="checked" />
                                            <DecisionTreeVar name="X" />
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError priority="2" _alias="Y1_omitted"
                                _RU_explanation="Это неверно, поскольку ${obj(checked, 'Nom')} опускается оператором со строгим порядком операндов (можете сказать, каким?), а значит не может помешать вычислению ${val('X', 'р')}."
                                _EN_explanation="That's incorrect, as ${obj(checked, 'Nom')} is omitted by an operator with a strict operand order (can you tell which one?), and therefore cannot prevent the evaluation of ${val('X', 'р')}."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <CheckClass>
                                            <Variable name="checked" />
                                            <Class name="token" />
                                        </CheckClass>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                            <Compare operator="EQUAL">
                                                <GetPropertyValue>
                                                    <GetByRelationship varName="var">
                                                        <Variable name="checked" />
                                                        <Relationship name="belongsTo" />
                                                    </GetByRelationship>
                                                    <Property name="state" />
                                                </GetPropertyValue>
                                                <Enum owner="state" value="omitted" />
                                            </Compare>
                                        </LogicalAnd>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError priority="3" _alias="Y1_evaluated"
                                _RU_explanation="Это неверно - ${obj(checked, 'Nom')} уже вычислен и по сути является операндом, а значит не может помешать вычислению ${val('X', 'Gen')}."
                                _EN_explanation="That's incorrect - ${obj(checked, 'Nom')} is already evaluated and now serves as just an operand, and therefore cannot prevent the evaluation of ${val('X', 'Gen')}."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <CheckClass>
                                            <Variable name="checked" />
                                            <Class name="token" />
                                        </CheckClass>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                            <Compare operator="NOT_EQUAL">
                                                <GetPropertyValue>
                                                    <GetByRelationship varName="var">
                                                        <Variable name="checked" />
                                                        <Relationship name="belongsTo" />
                                                    </GetByRelationship>
                                                    <Property name="state" />
                                                </GetPropertyValue>
                                                <Enum owner="state" value="unevaluated" />
                                            </Compare>
                                        </LogicalAnd>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError priority="4" _alias="Y1_tooFar"
                                _RU_explanation="Это неверно, ${obj(checked, 'Nom')} слишком далеко от ${val('X', 'Gen')} чтобы помешать ему."
                                _EN_explanation="That might be true, but there is a fitting operator closer to the ${val('X', 'Gen')} than ${obj(checked, 'Nom')} and it should be considered first."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship>
                                            <Relationship name="isBetween" />
                                            <DecisionTreeVar name="Y1" />
                                            <DecisionTreeVar name="X" />
                                            <Variable name="checked" />
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <AdditionalVarDecl name="Y" type="operator">
                                <Expression>
                                    <Cast>
                                        <GetByRelationship>
                                            <DecisionTreeVar name="Y1" />
                                            <Relationship name="belongsTo" />
                                        </GetByRelationship>
                                        <Class name="operator" />
                                    </Cast>
                                </Expression>
                            </AdditionalVarDecl>
                            <Outcome value="none"
                                _RU_explanation="слева от ${val('X','р')} нет потенциально мешающих операторов"
                                _RU_nextStepQuestion="Какие выводы можно сделать, если слева от ${val('X','р')} находятся только вычисленные операторы?"
                                _RU_nextStepExplanation="Это неверно. Если все выражение слева от ${val('X','р')} вычислено, значит и его левый операнд вычислен и не мешает вычислению ${val('X','р')}."
                                _EN_explanation="there are no unevaluated operators to the left of ${val('X','р')}"
                                _EN_nextStepQuestion="What is the next reasoning step if we know that there are only evaluated operators to the left of ${val('X','р')}?"
                                _EN_nextStepExplanation="That's incorrect. If the expression to the left of the ${val('X','р')} is already evaluated, then the left operand of ${val('X','р')} is fully evaluated. Therefore, it is not preventing its further evaluation."
                            >
                                <BranchResultNode value="true"
                                    _skill="left_competing_operator_present"
                                    _RU_explanation="все операторы слева от него уже вычислены."
                                    _EN_explanation="all operators to the left of it have been already evaluated."
                                />
                            </Outcome>
                            <Outcome value="found"
                                _RU_explanation="слева от ${val('X','р')} есть потенциально мешающий оператор - это ${val('Y','и')}"
                                _RU_nextStepQuestion="Как определяется порядок вычисления двух конкурирующих операторов?"
                                _RU_nextStepBranchResult="${branchResult ? 'Правый' : 'Левый'} оператор всегда выполняется первым"
                                _RU_nextStepExplanation="Это неверно. Определение порядка вычислений двух операторов надо начинать с рассмотрения влияния скобок на их приоритет."
                                _EN_explanation="there is a potentially blocking operator to the left of ${val('X','р')} - it's ${val('Y','и')}"
                                _EN_nextStepQuestion="How should one determine the order of evaluation between two operators?"
                                _EN_nextStepBranchResult="The one on the ${branchResult ? 'right' : 'left'} is always evaluated first"
                                _EN_nextStepExplanation="That's incorrect. One should first determine if parentheses have any effect on the precedence of the two operators."
                            >
                                <QuestionNode type="bool" _alias="left.predetermining.1.isXinY"
                                    _RU_asNextStep="Необходимо проверить, находится ли ${val('X','и')} между ${val('Y1','р')} И ${val('Y2','р')}"
                                    _RU_question="Верно ли, что ${val('X','и')} находится между ${val('Y1','р')} И ${val('Y2','р')}?"
                                    _RU_endingCause="Потому что ${val('X','и')} находится между ${val('Y1','р')} И ${val('Y2','р')}"
                                    _EN_asNextStep="We should check if ${val('X','и')} is between ${val('Y1', 'и')} and ${val('Y2', 'и')}"
                                    _EN_question="Is ${val('X','и')} between ${val('Y1', 'и')} and ${val('Y2', 'и')}?"
                                    _EN_endingCause="Because ${val('X','и')} is between ${val('Y1', 'и')} and ${val('Y2', 'и')}"
                                >
                                    <Expression>
                                        <ExistenceQuantifier varName="y2">
                                            <LogicalAnd>
                                                <LogicalAnd>
                                                    <CheckClass>
                                                        <Variable
                                                            name="y2" />
                                                        <Class
                                                            name="token" />
                                                    </CheckClass>
                                                    <CheckRelationship>
                                                        <Relationship
                                                            name="belongsTo" />
                                                        <Variable
                                                            name="y2" />
                                                        <DecisionTreeVar
                                                            name="Y" />
                                                    </CheckRelationship>
                                                </LogicalAnd>
                                                <Compare
                                                    operator="NOT_EQUAL">
                                                    <Variable name="y2" />
                                                    <DecisionTreeVar
                                                        name="Y1" />
                                                </Compare>
                                            </LogicalAnd>
                                            <CheckRelationship>
                                                <Relationship name="isBetween" />
                                                <DecisionTreeVar name="X" />
                                                <DecisionTreeVar name="Y1" />
                                                <Variable name="y2" />
                                            </CheckRelationship>
                                        </ExistenceQuantifier>
                                    </Expression>
                                    <Outcome value="true"
                                        _RU_nextStepQuestion="Какие выводы можно сделать на данном этапе?"
                                        _RU_nextStepExplanation="Это неверно."
                                        _EN_nextStepQuestion="What can we now conclude?"
                                        _EN_nextStepExplanation="That's incorrect."
                                    >
                                        <BranchResultNode value="true"
                                            _skill="left_operator_enclosed"
                                            _RU_explanation="он заключен в ближайший оператор слева к нему ${val('Y','и')}"
                                            _EN_explanation="it is enclosed in the ${val('Y','и')}, which is closest to it from the left"
                                        />
                                    </Outcome>
                                    <Outcome value="false"
                                        _RU_nextStepQuestion="Какие выводы можно сделать на данном этапе?"
                                        _RU_nextStepExplanation="Это неверно."
                                        _EN_nextStepQuestion="What can we now conclude?"
                                        _EN_nextStepExplanation="That's incorrect."
                                    >
                                        <PredeterminingFactorsNode _alias="left.predetermining"
                                            _RU_asNextStep="Необходимо рассмотреть влияние скобок на взаимодействие между ${val('X','т')} и ${val('Y','т')}."
                                            _RU_question="Как скобки влияют на взаимодействие между ${val('X','т')} и ${val('Y','т')}?"
                                            _RU_endingCause="Из-за роли скобок в выражении"
                                            _EN_asNextStep="We should check if parentheses have any effect on the precedence of the two operators."
                                            _EN_question="How do parentheses affect the evaluation of ${val('X','т')} and ${val('Y','т')}?"
                                            _EN_endingCause="Because of the effect of the parentheses"
                                        >
                                            <Outcome value="predetermined_2"
                                                _RU_text="${val('X','и')} находится в скобках, а ${val('Y','и')} - за их пределами"
                                                _RU_explanation="${result ? '${val('X','и')} находится в скобках, а ${val('Y','и')} - за их пределами' : 'не существует скобок, окружающих ${val('X','и')}, но не окружающих ${val('Y','в')}'}"
                                                _RU_nextStepQuestion="Как определяется порядок вычисления операторов, один из которых находится в скобках, а другой - за их пределами?"
                                                _RU_nextStepBranchResult="Оператор ${branchResult ? 'в скобках' : 'вне скобок'} всегда выполняется первым"
                                                _RU_nextStepExplanation="Это неверно. У операторов, находящихся в скобках, всегда приоритет над внешними операторами. Поэтому, т.к. ${val('X','и')} находится в скобках, а ${val('Y','и')} - за их пределами, то ${val('X','и')} может выполниться первым без помех."
                                                _EN_text="There are parenthesis that enclose ${val('X','и')} but not ${val('Y','в')}"
                                                _EN_explanation="there are ${result ? '' : 'no' } parenthesis that enclose ${val('X','и')} but not ${val('Y','в')}"
                                                _EN_nextStepQuestion="How should one determine the order of evaluation between two operators, if one of them is inside of parenthesis, and the other is ouside of them?"
                                                _EN_nextStepBranchResult="The operator ${branchResult ? 'inside' : 'outside'} the parenthesis is always evaluated first"
                                                _EN_nextStepExplanation="That's incorrect. Operators in parenthesis always take precedence over external operators. Therefore, as ${val('X','и')} is inside of parenthesis, and ${val('Y','и')} is ouside of them, then the ${val('X','и')} should be evaluated first."
                                            >
                                                <BranchResultNode value="true"
                                                    _skill="is_current_parenthesized_left_not"
                                                    _RU_explanation="он находится в скобках, в которых нет ближайшего слева к нему ${val('Y','р')}"
                                                    _EN_explanation="it is in parentheses, which do not contain the ${val('Y','р') closest to it"
                                                />
                                                <ThoughtBranch type="bool"
                                                    _alias="left.predetermining.2"
                                                    _RU_description="${result ? '${val('X','и')} находится в скобках, а ${val('Y','и')} - за их пределами' : 'не существует скобок, окружающих ${val('X','и')}, но не окружающих ${val('Y','в')}'}"
                                                    _EN_description="${result ? '${val('X','и')} is inside of parenthesis, and ${val('Y','и')} is ouside of them' : 'there are no parenthesis that enclose ${val('X','и')} but not ${val('Y','в')}'}"
                                                >
                                                    <!-- Вопросы не задаются, поскольку ветка
                                                    тривиальна,
                                            так что формулировки не прописал-->
                                                    <QuestionNode type="bool"
                                                        _alias="left.predetermining.2.isXinParenthesis"
                                                        _RU_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${val('X','и')}, но не ${val('Y','и')}"
                                                        _RU_question="Существуют ли скобки, окружающие ${val('X','и')}, но не ${val('Y','и')}?"
                                                        _RU_endingCause="Потому что существуют скобки, окружающие ${val('X','и')}, но не ${val('Y','и')}"
                                                        _EN_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${val('X','и')}, но не ${val('Y','и')}"
                                                        _EN_question="Существуют ли скобки, окружающие ${val('X','и')}, но не ${val('Y','и')}?"
                                                        _EN_endingCause="Потому что существуют скобки, окружающие ${val('X','и')}, но не ${val('Y','и')}"
                                                    >
                                                        <Expression>
                                                            <ExistenceQuantifier varName="p">
                                                                <CheckClass>
                                                                    <Variable name="p" />
                                                                    <Class name="parenthesis" />
                                                                </CheckClass>
                                                                <ExistenceQuantifier
                                                                    varName="p1"
                                                                    type="token">
                                                                    <CheckRelationship>
                                                                        <Relationship
                                                                            name="belongsTo" />
                                                                        <Variable name="p1" />
                                                                        <Variable name="p" />
                                                                    </CheckRelationship>
                                                                    <ExistenceQuantifier
                                                                        varName="p2"
                                                                        type="token">
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="belongsTo" />
                                                                            <Variable name="p2" />
                                                                            <Variable name="p" />
                                                                        </CheckRelationship>
                                                                        <LogicalAnd>
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isBetween" />
                                                                                <DecisionTreeVar
                                                                                    name="X" />
                                                                                <Variable
                                                                                    name="p1" />
                                                                                <Variable
                                                                                    name="p2" />
                                                                            </CheckRelationship>
                                                                            <LogicalNot>
                                                                                <CheckRelationship>
                                                                                    <Relationship
                                                                                        name="isBetween" />
                                                                                    <DecisionTreeVar
                                                                                        name="Y" />
                                                                                    <Variable
                                                                                        name="p1" />
                                                                                    <Variable
                                                                                        name="p2" />
                                                                                </CheckRelationship>
                                                                            </LogicalNot>
                                                                        </LogicalAnd>
                                                                    </ExistenceQuantifier>
                                                                </ExistenceQuantifier>
                                                            </ExistenceQuantifier>
                                                        </Expression>
                                                        <Outcome value="false">
                                                            <BranchResultNode value="false" />
                                                        </Outcome>
                                                        <Outcome value="true">
                                                            <BranchResultNode value="true" />
                                                        </Outcome>
                                                    </QuestionNode>
                                                </ThoughtBranch>
                                            </Outcome>
                                            <Outcome value="predetermined_3"
                                                _RU_text="${val('Y','и')} находится в скобках, а ${val('X','и')} - за их пределами"
                                                _RU_explanation="${result ? '${val('Y','и')} находится в скобках, а ${val('X','и')} - за их пределами' : 'не существует скобок, окружающих ${val('Y','и')}, но не окружающих ${val('X','в')}'}"
                                                _RU_nextStepQuestion="Как определяется порядок вычисления операторов, один из которых находится в скобках, а другой - за их пределами?"
                                                _RU_nextStepBranchResult="Оператор ${branchResult ? 'вне скобок' : 'в скобках'} всегда выполняется первым"
                                                _RU_nextStepExplanation="Это неверно. У операторов, находящихся в скобках, всегда приоритет над внешними операторами. Поэтому, т.к. ${val('Y','и')} находится в скобках, а ${val('X','и')} - за их пределами, то ${val('Y','и')} должен выполниться раньше, мешая ${val('X','д')}."
                                                _EN_text="There are parenthesis that enclose ${val('Y','и')} but not ${val('X','в')}"
                                                _EN_explanation="there are ${result ? '' : 'no' } parenthesis that enclose ${val('Y','и')} but not ${val('X','в')}"
                                                _EN_nextStepQuestion="How should one determine the order of evaluation between two operators, if one of them is inside of parenthesis, and the other is ouside of them?"
                                                _EN_nextStepBranchResult="The operator ${branchResult ? 'outside' : 'inside'} the parenthesis is always evaluated first"
                                                _EN_nextStepExplanation="That's incorrect. Operators in parentheses always take precedence over external operators. Therefore, as ${val('Y','и')} is inside of parenthesis, and ${val('X','и')} is ouside of them, then the ${val('Y','и')} should be evaluated first, blocking ${val('X','д')}."
                                            >
                                                <BranchResultNode value="false"
                                                    _law="error_base_student_error_in_complex;error_base_parenthesized_operators"
                                                    _skill="is_left_parenthesized_current_not"
                                                    _error="left.parenthesis"
                                                    _RU_explanation="сначала должен быть вычислен ${val('Y','и')} слева от него, так как ${val('Y','и')} окружен круглыми скобками."
                                                    _EN_explanation="${val('Y','и')} on its left must be evaluated first because ${val('Y','и')} is in parentheses."
                                                />
                                                <ThoughtBranch type="bool"
                                                    _alias="left.predetermining.3"
                                                    _RU_description="${result ? '${val('Y','и')} находится в скобках, а ${val('X','и')} - за их пределами' : 'не существует скобок, окружающих ${val('Y','и')}, но не окружающих ${val('X','в')}'}"
                                                    _EN_description="${result ? '${val('Y','и')} is inside of parenthesis, and ${val('X','и')} is ouside of them' : 'there are no parenthesis that enclose ${val('Y','и')} but not ${val('X','в')}'}"
                                                >
                                                    <!-- Вопросы не задаются, поскольку ветка
                                                    тривиальна,
                                            так что формулировки не прописал-->
                                                    <QuestionNode type="bool"
                                                        _alias="left.predetermining.3.isYinParenthesis"
                                                        _RU_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${val('Y','и')}, но не ${val('X','в')}"
                                                        _RU_question="Существуют ли скобки, окружающие ${val('Y','и')}, но не ${val('X','в')}?"
                                                        _RU_endingCause="Потому что существуют скобки, окружающие ${val('Y','и')}, но не ${val('X','в')}"
                                                        _EN_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${val('Y','и')}, но не ${val('X','в')}"
                                                        _EN_question="Существуют ли скобки, окружающие ${val('Y','и')}, но не ${val('X','в')}?"
                                                        _EN_endingCause="Потому что существуют скобки, окружающие ${val('Y','и')}, но не ${val('X','в')}"
                                                    >
                                                        <Expression>
                                                            <ExistenceQuantifier varName="p">
                                                                <CheckClass>
                                                                    <Variable name="p" />
                                                                    <Class name="parenthesis" />
                                                                </CheckClass>
                                                                <ExistenceQuantifier varName="p1"
                                                                    type="token">
                                                                    <CheckRelationship>
                                                                        <Relationship
                                                                            name="belongsTo" />
                                                                        <Variable name="p1" />
                                                                        <Variable name="p" />
                                                                    </CheckRelationship>
                                                                    <ExistenceQuantifier
                                                                        varName="p2"
                                                                        type="token">
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="belongsTo" />
                                                                            <Variable name="p2" />
                                                                            <Variable name="p" />
                                                                        </CheckRelationship>
                                                                        <LogicalAnd>
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isBetween" />
                                                                                <DecisionTreeVar
                                                                                    name="Y" />
                                                                                <Variable name="p1" />
                                                                                <Variable name="p2" />
                                                                            </CheckRelationship>
                                                                            <LogicalNot>
                                                                                <CheckRelationship>
                                                                                    <Relationship
                                                                                        name="isBetween" />
                                                                                    <DecisionTreeVar
                                                                                        name="X" />
                                                                                    <Variable
                                                                                        name="p1" />
                                                                                    <Variable
                                                                                        name="p2" />
                                                                                </CheckRelationship>
                                                                            </LogicalNot>
                                                                        </LogicalAnd>
                                                                    </ExistenceQuantifier>
                                                                </ExistenceQuantifier>
                                                            </ExistenceQuantifier>
                                                        </Expression>
                                                        <Outcome value="false">
                                                            <BranchResultNode value="false" />
                                                        </Outcome>
                                                        <Outcome value="true">
                                                            <BranchResultNode value="true" />
                                                        </Outcome>
                                                    </QuestionNode>
                                                </ThoughtBranch>
                                            </Outcome>
                                            <Outcome value="undetermined"
                                                _RU_text="Никак - скобки не влияют на порядок вычисления ${val('X','р')} и ${val('Y','р')}"
                                                _RU_explanation="${result ? 'скобки не влияют на порядок вычисления ${val('X','р')} и ${val('Y','р')}' : 'скобки имеют влияние на порядок вычисления ${val('X','р')} и ${val('Y','р')}'}"
                                                _RU_nextStepQuestion="В отсутствии влияния скобок, как определяется порядок выполнения стоящих рядом операторов?"
                                                _RU_nextStepBranchResult="${branchResult ? 'Правый' : 'Левый'} оператор всегда выполняется первым"
                                                _RU_nextStepExplanation="Это неверно. В отсутствии скобок, порядок выполнения стоящих рядом операторов определяется их приоритетом - его и надо рассматривать следующим."
                                                _EN_text="They don't - parentheses have no effect on ${val('X','т')} and ${val('Y','т')}"
                                                _EN_explanation="parentheses do ${result ? 'not' : ''} affect the evaluation of ${val('X','т')} and ${val('Y','т')}"
                                                _EN_nextStepQuestion="In the absence of parentheses' effect, how should one determine the order of evaluation between two operator?"
                                                _EN_nextStepBranchResult="The operator on the ${branchResult ? 'right' : 'left'} is always evaluated first."
                                                _EN_nextStepExplanation="That's incorrect. In the absence of parentheses' effect, the order of evaluation is determined by the precedence of the operators - so it should be considered next."
                                            >
                                                <QuestionNode type="comparison"
                                                    _alias="left.precedence"
                                                    _RU_asNextStep="Необходимо сравнить приоритеты ${class('X','р')} и ${class('Y','р')}"
                                                    _RU_question="Сравните приоритеты ${class('X','р')} и ${class('Y','р')}"
                                                    _RU_endingCause="Из-за соотношения приоритетов ${class('X','р')} и ${class('Y','р')}"
                                                    _EN_asNextStep="We should compare the precendence of ${class('X','р')} and ${class('Y','р')}."
                                                    _EN_question="Compare the precendence of ${class('X','р')} and ${class('Y','р')}."
                                                    _EN_endingCause="Because of the precendences of ${class('X','р')} and ${class('Y','р')}."
                                                    _RU_triviality="Приоритеты ${val('X','р')} и ${val('Y','р')} очевидно равны, так как это один и тот же оператор."
                                                    _EN_triviality="Precendences of ${val('X','р')} and ${val('Y','р')} are obviously equal as they are the same operator."
                                                >
                                                    <Expression>
                                                        <Compare>
                                                            <GetPropertyValue>
                                                                <DecisionTreeVar name="X" />
                                                                <Property name="precedence" />
                                                            </GetPropertyValue>
                                                            <GetPropertyValue>
                                                                <DecisionTreeVar name="Y" />
                                                                <Property name="precedence" />
                                                            </GetPropertyValue>
                                                        </Compare>
                                                    </Expression>
                                                    <Triviality>
                                                        <Compare operator="EQUAL">
                                                            <GetClass>
                                                                <DecisionTreeVar name="X" />
                                                            </GetClass>
                                                            <GetClass>
                                                                <DecisionTreeVar name="Y" />
                                                            </GetClass>
                                                        </Compare>
                                                    </Triviality>
                                                    <!--обратное
                                            сравнение приоритетов, потому что 1 наивысший приоритет -->
                                                    <Outcome value="Comparison:less"
                                                        _RU_text="Приоритет ${class('X','р')} больше."
                                                        _RU_explanation="Это неверно, поскольку ${class('X','и')} имеет больший приоритет, чем ${class('Y','и')}."
                                                        _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих разные приоритеты?"
                                                        _RU_nextStepBranchResult="Оператор с ${branchResult ? 'большим' : 'меньшим'} приоритетом всегда выполняется первым"
                                                        _RU_nextStepExplanation="Это неверно. Оператор с большим приоритетом всегда выполняется первым. Т.к. ${class('X','и')} имеет больший приоритет, а значит может быть вычислен первым. Получается, левый операнд ${val('X','и')} не требует дальнейших вычислений."
                                                        _EN_text="${class('X','р')} has higher precendence."
                                                        _EN_explanation="That's incorrect, because ${class('X','р')} has higher precendence than ${class('Y','р')}."
                                                        _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have different precedences?"
                                                        _EN_nextStepBranchResult="Operator with a ${branchResult ? 'higher' : 'lower'} precedence is always evaluated first"
                                                        _EN_nextStepExplanation="That's incorrect. The operator with a higher precedence is always evaluated first. Therefore, in this case, the ${val('X','и')} should be evaluated first, and we can conclude that its left operand does not prevent its evaluation."
                                                    >
                                                        <BranchResultNode value="true"
                                                            _skill="right_competing_to_left_precedence"
                                                            _RU_explanation="он имеет приоритет выше, чем ${val('Y','в')}."
                                                            _EN_explanation="it has a higher priority than ${val('Y','в')}."
                                                        />
                                                    </Outcome>
                                                    <Outcome value="Comparison:greater"
                                                        _RU_text="Приоритет ${class('Y','р')} больше."
                                                        _RU_explanation="Это неверно, поскольку ${class('Y','и')} имеет больший приоритет, чем ${class('X','и')}."
                                                        _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих разные приоритеты?"
                                                        _RU_nextStepBranchResult="Оператор с ${branchResult ? 'меньшим' : 'большим'} приоритетом всегда выполняется первым"
                                                        _RU_nextStepExplanation="Это неверно. Оператор с большим приоритетом всегда выполняется первым. Т.к. ${class('Y','и')} имеет больший приоритет, он должен быть вычислен первым. Получается, левый операнд ${val('X','и')} требует дальнейших вычислений."
                                                        _EN_text="${class('Y','р')} has higher precendence."
                                                        _EN_explanation="That's incorrect, because ${class('Y','р')} has higher precendence than ${class('X','р')}."
                                                        _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have different precedences?"
                                                        _EN_nextStepBranchResult="Operator with a ${branchResult ? 'lower' : 'higher'} precedence is always evaluated first"
                                                        _EN_nextStepExplanation="That's incorrect. The operator with a higher precedence is always evaluated first. Therefore, in this case, the ${val('Y','и')} should be evaluated first, and we can conclude that the left operand of ${val('X','и')} does prevent its evaluation."
                                                    >
                                                        <BranchResultNode value="false"
                                                            _skill="right_competing_to_left_precedence"
                                                            _law="error_base_higher_precedence_left"
                                                            _error="left.precedence"
                                                            _RU_explanation="сначала должен быть вычислен ${val('Y','и')} слева от него, который имеет более высокий приоритет."
                                                            _EN_explanation="${val('Y','и')} on its left must be evaluated first because it has a higher precedence."
                                                        />
                                                    </Outcome>
                                                    <Outcome value="Comparison:equal"
                                                        _RU_text="Их приоритеты одинаковы."
                                                        _RU_explanation="Это неверно, поскольку приоритеты ${class('X','р')} и ${class('Y','р')} одинаковы."
                                                        _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих равные приоритеты?"
                                                        _RU_nextStepBranchResult="${branchResult ? 'Правый' : 'Левый'} оператор всегда выполняется первым"
                                                        _RU_nextStepExplanation="Это неверно. Порядок выполнения операторов, имеющих одинаковые приоритеты, задается ассоциативностью, а значит следующим шагом необходимо проверить ассоциативность ${class('X','р')} и ${class('Y','р')}."
                                                        _EN_text="They have the same precedence."
                                                        _EN_explanation="That's incorrect because ${class('X','р')} and ${class('Y','р')} have the same precedence."
                                                        _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have the same precedence?"
                                                        _EN_nextStepBranchResult="The operator on the ${branchResult ? 'right' : 'left'} is always evaluated first."
                                                        _EN_nextStepExplanation="That's incorrect. The order of evaluation between two operators that have the same precedence is determined by their associativity. Therefore we should next check the associativity of ${class('X','р')} and ${class('Y','р')}."
                                                    >
                                                        <QuestionNode
                                                            _alias="rightOperandAssoc.isNeeded"
                                                            _RU_asNextStep="Необходимо проверить, нужен ли ${val('X','д')} правый операнд."
                                                            _RU_question="Нужен ли ${class('X','д')} правый операнд?"
                                                            _RU_endingCause="Потому что ${val('X','и')} не требует правого операнда"
                                                            _EN_asNextStep="We should check if ${val('X','д')} needs a right operand."
                                                            _EN_question="Does ${class('X','д')} need a right operand?"
                                                            _EN_endingCause="Because ${val('X','и')} doesn't need a right operand."
                                                        >
                                                            <Expression>
                                                                <GetPropertyValue>
                                                                    <DecisionTreeVar name="X" />
                                                                    <Property
                                                                        name="needsRightOperand" />
                                                                </GetPropertyValue>
                                                            </Expression>
                                                            <Outcome value="false"
                                                                _RU_explanation="Это неверно. ${class('X','и')} не имеет (не требует) правого операнда."
                                                                _RU_nextStepQuestion="Какие выводы можно сделать, если ${val('X','и')} не требует правого операнда?"
                                                                _RU_nextStepExplanation="Это неверно. Если оператор не имеет правого операнда, то и дальнейших вычислений его правый операнд требовать не может."
                                                                _EN_explanation="That's incorrect, because ${class('X','и')} doesn't need a right operand."
                                                                _EN_nextStepQuestion="What is the next reasoning step if we know that ${class('X','и')} doesn't need a right operand?"
                                                                _EN_nextStepExplanation="That's incorrect. If it doesn't need a right operand, then the right operand can't prevent its further evaluation."
                                                            >
                                                                <BranchResultNode value="false"
                                                                    _skill="associativity_without_right_opposing_operand"
                                                                    _RU_explanation="сначала должен быть вычислен ${val('Y','и')} слева от него: эти операторы имеют одинаковый приоритет, и вычисляются слева направо (левоассоциативны)."
                                                                    _EN_explanation=" ${val('Y','и')} on its left must be evaluated first - these operators have the same precedence, but are evaluated from left to right (have left associativity)."
                                                                />
                                                            </Outcome>
                                                            <Outcome value="true"
                                                                _RU_explanation="Это неверно. ${class('X','д')} всегда необходим правый операнд."
                                                                _RU_nextStepQuestion="Какие выводы можно сделать, если ${val('X','д')} нужен правый операнд?"
                                                                _RU_nextStepExplanation="Это неверно. Необходимо дальше рассмотреть потенциально конкурирующие с ${val('X','т')} операторы, и делать выводы исходя из их наличия/отсуствия."
                                                                _EN_explanation="That's incorrect, because ${class('X','и')} does require a right operand."
                                                                _EN_nextStepQuestion="What is the next reasoning step if we know that ${class('X','и')} needs a right operand?"
                                                                _EN_nextStepExplanation="That's incorrect. From here, one should check if there are any operators that should still be evaluated in the right operand, and then reason based on that."
                                                            >
                                                                <QuestionNode type="enum"
                                                                    enumOwner="associativity"
                                                                    _alias="left.associativity"
                                                                    _RU_asNextStep="Необходимо проверить, какова ассоциативность ${class('X','р')} и ${class('Y','р')}"
                                                                    _RU_question="Какова ассоциативность ${class('X','р')} и ${class('Y','р')}?"
                                                                    _RU_endingCause="Из-за ассоциативности ${class('X','р')} и ${class('Y','р')}"
                                                                    _EN_asNextStep="We should determine the associativity of ${class('X','р')} and ${class('Y','р')}"
                                                                    _EN_question="What's the associativity of ${class('X','р')} and ${class('Y','р')}?"
                                                                    _EN_endingCause="Because of the associatity of ${class('X','р')} and ${class('Y','р')}"
                                                                >
                                                                    <Expression>
                                                                        <GetPropertyValue>
                                                                            <DecisionTreeVar
                                                                                name="Y" />
                                                                            <Property
                                                                                name="associativity" />
                                                                        </GetPropertyValue>
                                                                    </Expression>
                                                                    <Outcome
                                                                        value="associativity:left"
                                                                        _RU_text="левая"
                                                                        _RU_explanation="Это неверно, поскольку ${class('X','и')} и ${class('Y','и')} имеют левую ассоциативность."
                                                                        _RU_nextStepQuestion="Какой из двух рядом стоящих операторов выполнится первым, если операторы имеют левую ассоциативность?"
                                                                        _RU_nextStepBranchResult="${branchResult ? 'Правый' : 'Левый'}"
                                                                        _RU_nextStepExplanation="Это неверно. При левой ассоциативности операторы выполняются слева направо. В данном случае это значит, ${class('Y','и')} должен быть вычислен первым. Получается, левый операнд ${val('X','и')} требует дальнейших вычислений."
                                                                        _EN_text="left"
                                                                        _EN_explanation="That's incorrect, because ${class('X','р')} and ${class('Y','р')} have left associativity."
                                                                        _EN_nextStepQuestion="Which of the two nearby operators evaluates first if they have left associativity?"
                                                                        _EN_nextStepBranchResult="The one on the ${branchResult ? 'right' : 'left'}"
                                                                        _EN_nextStepExplanation="That's incorrect. Operators that have left associativity evaluate from left to right. Therefore, in this case, ${class('Y','и')} should be evaluated first, and we can conclude that the left operand of ${val('X','и')} does prevent its evaluation."
                                                                    >
                                                                        <BranchResultNode
                                                                            value="false"
                                                                            _skill="right_competing_to_left_associativity"
                                                                            _law="error_base_same_precedence_left_associativity_left"
                                                                            _error="left.associativity"
                                                                            _RU_explanation=" имеет одинаковый приоритет с ${val('Y','р')} и правую ассоциативность (вычисляются справа налево) ."
                                                                            _EN_explanation=" ${val('Y','и')} on its left must be evaluated first - these operators have the same precedence, but are evaluated from left to right (have left associativity)."
                                                                        />
                                                                    </Outcome>
                                                                    <Outcome
                                                                        value="associativity:right"
                                                                        _RU_text="правая"
                                                                        _RU_explanation="Это неверно, поскольку ${class('X','и')} и ${class('Y','и')} имеют правую ассоциативность."
                                                                        _RU_nextStepQuestion="Какой из двух рядом стоящих операторов выполнится первым, если операторы имеют правую ассоциативность?"
                                                                        _RU_nextStepBranchResult="${branchResult ? 'Правый' : 'Левый'}"
                                                                        _RU_nextStepExplanation="Это неверно. При правой ассоциативности операторы выполняются справа налево. В данном случае это значит, ${class('X','и')} должен быть вычислен первым. Получается, левый операнд ${val('X','и')} не требует дальнейших вычислений."
                                                                        _EN_text="right"
                                                                        _EN_explanation="That's incorrect, because ${class('X','р')} and ${class('Y','р')} have right associativity."
                                                                        _EN_nextStepQuestion="Which of the two nearby operators evaluates first if they have right associativity?"
                                                                        _EN_nextStepBranchResult="The one on the ${branchResult ? 'right' : 'left'}"
                                                                        _EN_nextStepExplanation="That's incorrect. Operators that have right associativity evaluate from right to left. Therefore, in this case, ${class('X','и')} should be evaluated first, anand we can conclude that its left operand does not prevent its evaluation."
                                                                    >
                                                                        <BranchResultNode
                                                                            value="true"
                                                                            _skill="right_competing_to_left_associativity"
                                                                            _RU_explanation=" имеет одинаковый приоритет с ${val('Y','р')} и правую ассоциативность (вычисляются справа налево) ."
                                                                            _EN_explanation="it has the same precedence as ${val('Y','р')} and right associativity."
                                                                        />
                                                                    </Outcome>
                                                                </QuestionNode>
                                                            </Outcome>
                                                        </QuestionNode>
                                                    </Outcome>
                                                </QuestionNode>
                                            </Outcome>
                                        </PredeterminingFactorsNode>
                                    </Outcome>
                                </QuestionNode>
                            </Outcome>
                        </FindActionNode>
                    </Outcome>
                </QuestionNode>
            </ThoughtBranch>
            <ThoughtBranch type="bool" _alias="right"
                _RU_description="правый операнд ${val('X','р')} ${result ? 'не' : ''} требует дальнейших вычислений"
                _RU_nextStepQuestion="С чего надо начать при рассмотрении правого операнда?"
                _RU_nextStepExplanation="Это неверно. Прежде всего необходимо проверить, нужен ли оператору правый операнд."
                _EN_description="right operand of ${val('X','р')} ${result ? 'doesnt require' : 'requires'} further evaluation"
                _EN_nextStepQuestion="What is the first step when considering operator's right operand?"
                _EN_nextStepExplanation="That's incorrect. One should first check if the operator needs right operand at all."
            >
                <QuestionNode type="bool" _alias="right.isNeeded"
                    _RU_asNextStep="Необходимо проверить, нужен ли ${val('X','д')} правый операнд."
                    _RU_question="Нужен ли ${class('X','д')} правый операнд?"
                    _RU_endingCause="Потому что ${val('X','и')} не требует правого операнда"
                    _EN_asNextStep="We should check if ${val('X','д')} needs a right operand."
                    _EN_question="Does ${class('X','д')} need a right operand?"
                    _EN_endingCause="Because ${val('X','и')} doesn't need a right operand."
                >
                    <Expression>
                        <GetPropertyValue>
                            <DecisionTreeVar name="X" />
                            <Property name="needsRightOperand" />
                        </GetPropertyValue>
                    </Expression>
                    <Outcome value="false"
                        _RU_explanation="Это неверно. ${class('X','и')} не имеет (не требует) правого операнда."
                        _RU_nextStepQuestion="Какие выводы можно сделать, если ${val('X','и')} не требует правого операнда?"
                        _RU_nextStepExplanation="Это неверно. Если оператор не имеет правого операнда, то и дальнейших вычислений его правый операнд требовать не может."
                        _EN_explanation="That's incorrect, because ${class('X','и')} doesn't need a right operand."
                        _EN_nextStepQuestion="What is the next reasoning step if we know that ${class('X','и')} doesn't need a right operand?"
                        _EN_nextStepExplanation="That's incorrect. If it doesn't need a right operand, then the right operand can't prevent its further evaluation."
                    >
                        <BranchResultNode value="true" _skill="right_operand_needed"
                            _EN_explanation="it does not have a right operand"
                            _RU_explanation="он не имеет правого операнда"
                        />
                    </Outcome>
                    <Outcome value="true"
                        _RU_explanation="Это неверно. ${class('X','д')} всегда необходим правый операнд."
                        _RU_nextStepQuestion="Какие выводы можно сделать, если ${val('X','д')} нужен правый операнд?"
                        _RU_nextStepExplanation="Это неверно. Необходимо дальше рассмотреть потенциально конкурирующие с ${val('X','т')} операторы, и делать выводы исходя из их наличия/отсуствия."
                        _EN_explanation="That's incorrect, because ${class('X','и')} does require a right operand."
                        _EN_nextStepQuestion="What is the next reasoning step if we know that ${class('X','и')} needs a right operand?"
                        _EN_nextStepExplanation="That's incorrect. From here, one should check if there are any operators that should still be evaluated in the right operand, and then reason based on that."
                    >
                        <FindActionNode _alias="right.findZ"
                            _RU_asNextStep="Необходимо найти потенциально мешающий оператор справа от ${val('X','р')}"
                            _RU_question="Какой оператор может помешать выполнению ${val('X', 'Gen')} справа?"
                            _RU_endingCause="Потому что справа от ${val('X','р')} находятся только вычисленные операторы"
                            _EN_asNextStep="We should look for an unevaluated operator that could be in the right operand of ${val('X','р')}, preventing its further evaluation."
                            _EN_question="Find an operator that could be in the right operand of ${val('X','р')}, preventing its further evaluation?"
                            _EN_endingCause="Because there are only evaluated operators to the right of ${val('X','р')}."
                        >
                            <DecisionTreeVarDecl name="Z1" type="token" />
                            <Expression>
                                <GetExtreme extremeVarName="z1_ex" varName="z1">
                                    <LogicalAnd>
                                        <!-- Patch: между ближайшим левым и текущим ищется
                                        запятая-разделитель, которая не позволяет найти ближайший
                                        оператор в вызове функций-->
                                        <LogicalNot>
                                            <ExistenceQuantifier varName="commaSep" type="token">
                                                <CheckRelationship>
                                                    <Relationship name="isBetween" />
                                                    <Variable name="commaSep" />
                                                    <Variable name="z1_ex" />
                                                    <DecisionTreeVar name="X" />
                                                </CheckRelationship>
                                                <LogicalAnd>
                                                    <CheckClass>
                                                        <GetByRelationship varName="var">
                                                            <Variable name="commaSep" />
                                                            <Relationship name="belongsTo" />
                                                        </GetByRelationship>
                                                        <Class name="separator" />
                                                    </CheckClass>
                                                    <LogicalAnd>
                                                        <CheckRelationship>
                                                            <Relationship name="isInOperandOf" />
                                                            <GetByRelationship varName="y1_ex_op">
                                                                <Variable name="z1_ex" />
                                                                <Relationship name="belongsTo" />
                                                            </GetByRelationship>
                                                            <GetByRelationship
                                                                varName="ownerOfComma">
                                                                <GetByRelationship varName="var">
                                                                    <Variable name="commaSep" />
                                                                    <Relationship name="belongsTo" />
                                                                </GetByRelationship>
                                                                <Relationship
                                                                    name="belongsToOperator" />
                                                            </GetByRelationship>
                                                        </CheckRelationship>
                                                        <CheckRelationship>
                                                            <Relationship name="isInOperandOf" />
                                                            <DecisionTreeVar name="X" />
                                                            <GetByRelationship
                                                                varName="ownerOfComma">
                                                                <GetByRelationship varName="var">
                                                                    <Variable name="commaSep" />
                                                                    <Relationship name="belongsTo" />
                                                                </GetByRelationship>
                                                                <Relationship
                                                                    name="belongsToOperator" />
                                                            </GetByRelationship>
                                                        </CheckRelationship>
                                                    </LogicalAnd>
                                                </LogicalAnd>
                                            </ExistenceQuantifier>
                                        </LogicalNot>
                                        <LogicalNot>
                                            <ExistenceQuantifier varName="z1">
                                                <LogicalAnd>
                                                    <LogicalAnd>
                                                        <CheckClass>
                                                            <Variable name="z1" />
                                                            <Class name="token" />
                                                        </CheckClass>
                                                        <CheckRelationship>
                                                            <Relationship name="rightOf" />
                                                            <Variable name="z1" />
                                                            <DecisionTreeVar name="X" />
                                                        </CheckRelationship>
                                                    </LogicalAnd>
                                                    <LogicalAnd>
                                                        <CheckClass>
                                                            <GetByRelationship varName="var">
                                                                <Variable name="z1" />
                                                                <Relationship name="belongsTo" />
                                                            </GetByRelationship>
                                                            <Class name="operator" />
                                                        </CheckClass>
                                                        <Compare operator="EQUAL">
                                                            <GetPropertyValue>
                                                                <GetByRelationship varName="var">
                                                                    <Variable name="z1" />
                                                                    <Relationship name="belongsTo" />
                                                                </GetByRelationship>
                                                                <Property name="state" />
                                                            </GetPropertyValue>
                                                            <Enum owner="state" value="unevaluated" />
                                                        </Compare>
                                                    </LogicalAnd>
                                                </LogicalAnd>
                                                <CheckRelationship>
                                                    <Relationship name="isBetween" />
                                                    <Variable name="z1" />
                                                    <Variable name="z1_ex" />
                                                    <DecisionTreeVar name="X" />
                                                </CheckRelationship>
                                            </ExistenceQuantifier>
                                        </LogicalNot>
                                    </LogicalAnd>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="z1" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckRelationship>
                                                <Relationship name="rightOf" />
                                                <Variable name="z1" />
                                                <DecisionTreeVar name="X" />
                                            </CheckRelationship>
                                        </LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="z1" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                            <Compare operator="EQUAL">
                                                <GetPropertyValue>
                                                    <GetByRelationship varName="var">
                                                        <Variable name="z1" />
                                                        <Relationship name="belongsTo" />
                                                    </GetByRelationship>
                                                    <Property name="state" />
                                                </GetPropertyValue>
                                                <Enum owner="state" value="unevaluated" />
                                            </Compare>
                                        </LogicalAnd>
                                    </LogicalAnd>
                                </GetExtreme>
                            </Expression>
                            <FindError priority="1" _alias="Z1_wrongSide"
                                _RU_explanation="Это неверно, поскольку ${obj(checked, 'Nom')} находится слева от ${val('X', 'Gen')}."
                                _EN_explanation="That's incorrect, because ${obj(checked, 'Nom')} is to the left of ${val('X', 'Gen')}."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship>
                                            <Relationship name="leftOf" />
                                            <Variable name="checked" />
                                            <DecisionTreeVar name="X" />
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError priority="2" _alias="Z1_omitted"
                                _RU_explanation="Это неверно, поскольку ${obj(checked, 'Nom')} опускается оператором со строгим порядком операндов (можете сказать, каким?), а значит не может помешать вычислению ${val('X', 'р')}."
                                _EN_explanation="That's incorrect, as ${obj(checked, 'Nom')} is omitted by an operator with a strict operand order (can you tell which one?), and therefore cannot prevent the evaluation of ${val('X', 'р')}."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <CheckClass>
                                            <Variable name="checked" />
                                            <Class name="token" />
                                        </CheckClass>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                            <Compare operator="EQUAL">
                                                <GetPropertyValue>
                                                    <GetByRelationship varName="var">
                                                        <Variable name="checked" />
                                                        <Relationship name="belongsTo" />
                                                    </GetByRelationship>
                                                    <Property name="state" />
                                                </GetPropertyValue>
                                                <Enum owner="state" value="omitted" />
                                            </Compare>
                                        </LogicalAnd>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError priority="3" _alias="Z1_evaluated"
                                _RU_explanation="Это неверно - ${obj(checked, 'Nom')} уже вычислен и по сути является операндом, а значит не может помешать вычислению ${val('X', 'Gen')}."
                                _EN_explanation="That's incorrect - ${obj(checked, 'Nom')} is already evaluated and now serves as just an operand, and therefore cannot prevent the evaluation of ${val('X', 'Gen')}."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <CheckClass>
                                            <Variable name="checked" />
                                            <Class name="token" />
                                        </CheckClass>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                            <Compare operator="NOT_EQUAL">
                                                <GetPropertyValue>
                                                    <GetByRelationship varName="var">
                                                        <Variable name="checked" />
                                                        <Relationship name="belongsTo" />
                                                    </GetByRelationship>
                                                    <Property name="state" />
                                                </GetPropertyValue>
                                                <Enum owner="state" value="unevaluated" />
                                            </Compare>
                                        </LogicalAnd>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <FindError priority="4" _alias="Z1_tooFar"
                                _RU_explanation="Это неверно, ${obj(checked, 'Nom')} слишком далеко от ${val('X', 'Gen')} чтобы помешать ему."
                                _EN_explanation="That might be true, but there is a fitting operator closer to the ${val('X', 'Gen')} than ${obj(checked, 'Nom')} and it should be considered first."
                            >
                                <Expression>
                                    <LogicalAnd>
                                        <LogicalAnd>
                                            <CheckClass>
                                                <Variable name="checked" />
                                                <Class name="token" />
                                            </CheckClass>
                                            <CheckClass>
                                                <GetByRelationship varName="var">
                                                    <Variable name="checked" />
                                                    <Relationship name="belongsTo" />
                                                </GetByRelationship>
                                                <Class name="operator" />
                                            </CheckClass>
                                        </LogicalAnd>
                                        <CheckRelationship>
                                            <Relationship name="isBetween" />
                                            <DecisionTreeVar name="Z1" />
                                            <DecisionTreeVar name="X" />
                                            <Variable name="checked" />
                                        </CheckRelationship>
                                    </LogicalAnd>
                                </Expression>
                            </FindError>
                            <AdditionalVarDecl name="Z" type="operator">
                                <Expression>
                                    <Cast>
                                        <GetByRelationship>
                                            <DecisionTreeVar name="Z1" />
                                            <Relationship name="belongsTo" />
                                        </GetByRelationship>
                                        <Class name="operator" />
                                    </Cast>
                                </Expression>
                            </AdditionalVarDecl>
                            <Outcome value="none"
                                _RU_explanation="справа от ${val('X','р')} нет потенциально мешающих операторов"
                                _RU_nextStepQuestion="Какие выводы можно сделать, если справа от ${val('X','р')} находятся только вычисленные операторы?"
                                _RU_nextStepExplanation="Это неверно. Если все выражение справа от ${val('X','р')} вычислено, значит и его правый операнд вычислен и не мешает вычислению ${val('X','р')}."
                                _EN_explanation="there are no unevaluated operators to the right of ${val('X','р')}"
                                _EN_nextStepQuestion="What is the next reasoning step if we know that there are only evaluated operators to the right of ${val('X','р')}?"
                                _EN_nextStepExplanation="That's incorrect. If the expression to the right of the ${val('X','р')} is already evaluated, then the right operand of ${val('X','р')} is fully evaluated. Therefore, it is not preventing its further evaluation."
                            >
                                <BranchResultNode value="true"
                                    skill="right_competing_operator_present"
                                    _RU_explanation="Все операторы справа от него уже вычислены."
                                    _EN_explanation="All operators to the right of it have been already evaluated."
                                />
                            </Outcome>
                            <Outcome value="found"
                                _RU_explanation="справа от ${val('X','р')} есть потенциально мешающий оператор - это ${val('Z','и')}"
                                _RU_nextStepQuestion="Как определяется порядок вычисления двух конкурирующих операторов?"
                                _RU_nextStepBranchResult="${branchResult ? 'Левый' : 'Правый'} оператор всегда выполняется первым"
                                _RU_nextStepExplanation="Это неверно. Определение порядка вычислений двух операторов надо начинать с рассмотрения влияния скобок на их приоритет."
                                _EN_explanation="there is a potentially blocking operator to the right of ${val('X','р')} - it's ${val('Z','и')}"
                                _EN_nextStepQuestion="How should one determine the order of evaluation between two operators?"
                                _EN_nextStepBranchResult="The one on the ${branchResult ? 'left' : 'right'} is always evaluated first"
                                _EN_nextStepExplanation="That's incorrect. One should first determine if parentheses have any effect on the precedence of the two operators."
                            >
                                <QuestionNode type="bool"
                                    _alias="right.predetermining.1.isXinZ"
                                    _RU_asNextStep="Необходимо проверить, находится ли ${val('X','и')} между ${val('Z1','р')} и между ${val('Z2','р')}"
                                    _RU_question="Верно ли, что ${val('X','и')} находится между ${val('Z1','р')} и между ${val('Z2','р')}?"
                                    _RU_endingCause="Потому что ${val('X','и')} находится между ${val('Z1','р')} и между ${val('Z2','р')}"
                                    _EN_asNextStep="We should check if ${val('X','и')} is between ${val('Z1', 'и')} and ${val('Z2', 'и')}"
                                    _EN_question="Is ${val('X','и')} between ${val('Z1', 'и')} and ${val('Z2', 'и')}?"
                                    _EN_endingCause="Because ${val('X','и')} is between ${val('Z1', 'и')} and ${val('Z2', 'и')}"
                                >
                                    <Expression>
                                        <ExistenceQuantifier varName="z2">
                                            <LogicalAnd>
                                                <LogicalAnd>
                                                    <CheckClass>
                                                        <Variable name="z2" />
                                                        <Class name="token" />
                                                    </CheckClass>
                                                    <CheckRelationship>
                                                        <Relationship
                                                            name="belongsTo" />
                                                        <Variable name="z2" />
                                                        <DecisionTreeVar
                                                            name="Z" />
                                                    </CheckRelationship>
                                                </LogicalAnd>
                                                <Compare operator="NOT_EQUAL">
                                                    <Variable name="z2" />
                                                    <DecisionTreeVar name="Z1" />
                                                </Compare>
                                            </LogicalAnd>
                                            <CheckRelationship>
                                                <Relationship
                                                    name="isBetween" />
                                                <DecisionTreeVar name="X" />
                                                <DecisionTreeVar name="Z1" />
                                                <Variable name="z2" />
                                            </CheckRelationship>
                                        </ExistenceQuantifier>
                                    </Expression>
                                    <Outcome value="true"
                                        _RU_nextStepQuestion="Какие выводы можно сделать на данном этапе?"
                                        _RU_nextStepExplanation="Это неверно."
                                        _EN_nextStepQuestion="What can we now conclude?"
                                        _EN_nextStepExplanation="That's incorrect."
                                    >
                                        <BranchResultNode value="true"
                                            _skill="right_operator_enclosed"
                                            _RU_explanation="он заключен в ближайший оператор справа к нему ${val('Z','и')}"
                                            _EN_explanation="it is enclosed in the ${val('Z','и')}, which is closest to it from the right"
                                        />
                                    </Outcome>
                                    <Outcome value="false"
                                        _RU_nextStepQuestion="Какие выводы можно сделать на данном этапе?"
                                        _RU_nextStepExplanation="Это неверно."
                                        _EN_nextStepQuestion="What can we now conclude?"
                                        _EN_nextStepExplanation="That's incorrect."
                                    >
                                        <PredeterminingFactorsNode _alias="right.predetermining"
                                            _RU_asNextStep="Необходимо рассмотреть влияние скобок на взаимодействие между ${val('X','т')} и ${val('Z','т')}."
                                            _RU_question="Как скобки влияют на взаимодействие между ${val('X','т')} и ${val('Z','т')}?"
                                            _RU_endingCause="Из-за роли скобок в выражении"
                                            _EN_asNextStep="We should check if parentheses have any effect on the precedence of the two operators."
                                            _EN_question="How do parentheses affect the evaluation of ${val('X','т')} and ${val('Z','т')}?"
                                            _EN_endingCause="Because of the effect of the parentheses"
                                        >
                                            <Outcome value="predetermined_2"
                                                _RU_text="${val('X','и')} находится в скобках, а ${val('Z','и')} - за их пределами"
                                                _RU_explanation="${result ? '${val('X','и')} находится в скобках, а ${val('Z','и')} - за их пределами' : 'не существует скобок, окружающих ${val('X','и')}, но не окружающих ${val('Z','в')}'}"
                                                _RU_nextStepQuestion="Как определяется порядок вычисления операторов, один из которых находится в скобках, а другой - за их пределами?"
                                                _RU_nextStepBranchResult="Оператор ${branchResult ? 'в скобках' : 'вне скобок'} всегда выполняется первым"
                                                _RU_nextStepExplanation="Это неверно. У операторов, находящихся в скобках, всегда приоритет над внешними операторами. Поэтому, т.к. ${val('X','и')} находится в скобках, а ${val('Z','и')} - за их пределами, то ${val('X','и')} может выполниться первым без помех."
                                                _EN_text="There are parenthesis that enclose ${val('X','и')} but not ${val('Z','в')}"
                                                _EN_explanation="there are ${result ? '' : 'no' } parenthesis that enclose ${val('X','и')} but not ${val('Z','в')}"
                                                _EN_nextStepQuestion="How should one determine the order of evaluation between two operators, if one of them is inside of parenthesis, and the other is ouside of them?"
                                                _EN_nextStepBranchResult="The operator ${branchResult ? 'inside' : 'outside'} the parenthesis is always evaluated first"
                                                _EN_nextStepExplanation="That's incorrect. Operators in parenthesis always take precedence over external operators. Therefore, as ${val('X','и')} is inside of parenthesis, and ${val('Z','и')} is ouside of them, then the ${val('X','и')} should be evaluated first."
                                            >
                                                <BranchResultNode value="true"
                                                    _skill="is_current_parenthesized_right_not"
                                                    _RU_explanation="он находится в скобках, в которых нет ближайшего справа к нему ${val('Z','р')}"
                                                    _EN_explanation="it is in parentheses, which do not contain the ${val('Z','р') closest to it"
                                                />
                                                <ThoughtBranch type="bool"
                                                    _alias="right.predetermining.2"
                                                    _RU_description="${result ? '${val('X','и')} находится в скобках, а ${val('Z','и')} - за их пределами' : 'не существует скобок, окружающих ${val('X','и')}, но не окружающих ${val('Z','в')}'}"
                                                    _EN_description="${result ? '${val('X','и')} is inside of parenthesis, and ${val('Z','и')} is ouside of them' : 'there are no parenthesis that enclose ${val('X','и')} but not ${val('Z','в')}'}"
                                                >
                                                    <!-- Вопросы не задаются, поскольку ветка
                                                    тривиальна,
                                            так что формулировки не прописал-->
                                                    <QuestionNode type="bool"
                                                        _alias="right.predetermining.2.isXinParenthesis"
                                                        _RU_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${val('X','и')}, но не ${val('Z','и')}"
                                                        _RU_question="Существуют ли скобки, окружающие ${val('X','и')}, но не ${val('Z','и')}?"
                                                        _RU_endingCause="Потому что существуют скобки, окружающие ${val('X','и')}, но не ${val('Z','и')}"
                                                    >
                                                        <Expression>
                                                            <ExistenceQuantifier varName="p">
                                                                <CheckClass>
                                                                    <Variable name="p" />
                                                                    <Class name="parenthesis" />
                                                                </CheckClass>
                                                                <ExistenceQuantifier varName="p1"
                                                                    type="token">
                                                                    <CheckRelationship>
                                                                        <Relationship
                                                                            name="belongsTo" />
                                                                        <Variable name="p1" />
                                                                        <Variable name="p" />
                                                                    </CheckRelationship>
                                                                    <ExistenceQuantifier
                                                                        varName="p2"
                                                                        type="token">
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="belongsTo" />
                                                                            <Variable name="p2" />
                                                                            <Variable name="p" />
                                                                        </CheckRelationship>
                                                                        <LogicalAnd>
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isBetween" />
                                                                                <DecisionTreeVar
                                                                                    name="X" />
                                                                                <Variable name="p1" />
                                                                                <Variable name="p2" />
                                                                            </CheckRelationship>
                                                                            <LogicalNot>
                                                                                <CheckRelationship>
                                                                                    <Relationship
                                                                                        name="isBetween" />
                                                                                    <DecisionTreeVar
                                                                                        name="Z" />
                                                                                    <Variable
                                                                                        name="p1" />
                                                                                    <Variable
                                                                                        name="p2" />
                                                                                </CheckRelationship>
                                                                            </LogicalNot>
                                                                        </LogicalAnd>
                                                                    </ExistenceQuantifier>
                                                                </ExistenceQuantifier>
                                                            </ExistenceQuantifier>
                                                        </Expression>
                                                        <Outcome value="false">
                                                            <BranchResultNode value="false" />
                                                        </Outcome>
                                                        <Outcome value="true">
                                                            <BranchResultNode value="true" />
                                                        </Outcome>
                                                    </QuestionNode>
                                                </ThoughtBranch>
                                            </Outcome>
                                            <Outcome value="predetermined_3"
                                                _RU_text="${val('Z','и')} находится в скобках, а ${val('X','и')} - за их пределами"
                                                _RU_explanation="${result ? '${val('Z','и')} находится в скобках, а ${val('X','и')} - за их пределами' : 'не существует скобок, окружающих ${val('Z','и')}, но не окружающих ${val('X','в')}'}"
                                                _RU_nextStepQuestion="Как определяется порядок вычисления операторов, один из которых находится в скобках, а другой - за их пределами?"
                                                _RU_nextStepBranchResult="Оператор ${branchResult ? 'вне скобок' : 'в скобках'} всегда выполняется первым"
                                                _RU_nextStepExplanation="Это неверно. У операторов, находящихся в скобках, всегда приоритет над внешними операторами. Поэтому, т.к. ${val('Z','и')} находится в скобках, а ${val('X','и')} - за их пределами, то ${val('Z','и')} должен выполниться раньше, мешая ${val('X','д')}."
                                                _EN_text="There are parenthesis that enclose ${val('Z','и')} but not ${val('X','в')}"
                                                _EN_explanation="there are ${result ? '' : 'no' } parenthesis that enclose ${val('Z','и')} but not ${val('X','в')}"
                                                _EN_nextStepQuestion="How should one determine the order of evaluation between two operators, if one of them is inside of parenthesis, and the other is ouside of them?"
                                                _EN_nextStepBranchResult="The operator ${branchResult ? 'outside' : 'inside'} the parenthesis is always evaluated first"
                                                _EN_nextStepExplanation="That's incorrect. Operators in parenthesis always take precedence over external operators. Therefore, as ${val('Z','и')} is inside of parenthesis, and ${val('X','и')} is ouside of them, then the ${val('Z','и')} should be evaluated first, blocking ${val('X','д')}."
                                            >
                                                <BranchResultNode value="false"
                                                    _error="right.parenthesis"
                                                    _RU_explanation="сначала должен быть вычислен ${val('Z','и')} справа от него, так как ${val('Z','и')} окружен круглыми скобками."
                                                    _EN_explanation="${val('Z','и')} on its left must be evaluated first because ${val('Z','и')} is in parentheses."
                                                    _skill="is_right_parenthesized_current_not"
                                                    _law="error_base_parenthesized_operators;error_base_student_error_in_complex"
                                                />
                                                <ThoughtBranch type="bool"
                                                    _alias="right.predetermining.3"
                                                    _RU_description="${result ? '${val('Z','и')} находится в скобках, а ${val('X','и')} - за их пределами' : 'не существует скобок, окружающих ${val('Z','и')}, но не окружающих ${val('X','в')}'}"
                                                    _EN_description="${result ? '${val('Z','и')} is inside of parenthesis, and ${val('X','и')} is ouside of them' : 'there are no parenthesis that enclose ${val('Z','и')} but not ${val('X','в')}'}"
                                                >
                                                    <!-- Вопросы не задаются, поскольку ветка
                                                    тривиальна,
                                            так что формулировки не прописал-->
                                                    <QuestionNode type="bool"
                                                        _alias="right.predetermining.3.isZinParenthesis"
                                                        _RU_asNextStep="Необходимо проверить, существуют ли скобки, окружающие ${val('Z','и')}, но не ${val('X','в')}"
                                                        _RU_question="Существуют ли скобки, окружающие ${val('Z','и')}, но не ${val('X','в')}?"
                                                        _RU_endingCause="Потому что существуют скобки, окружающие ${val('Z','и')}, но не ${val('X','в')}"
                                                    >
                                                        <Expression>
                                                            <ExistenceQuantifier varName="p">
                                                                <CheckClass>
                                                                    <Variable name="p" />
                                                                    <Class name="parenthesis" />
                                                                </CheckClass>
                                                                <ExistenceQuantifier varName="p1"
                                                                    type="token">
                                                                    <CheckRelationship>
                                                                        <Relationship
                                                                            name="belongsTo" />
                                                                        <Variable name="p1" />
                                                                        <Variable name="p" />
                                                                    </CheckRelationship>
                                                                    <ExistenceQuantifier
                                                                        varName="p2"
                                                                        type="token">
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="belongsTo" />
                                                                            <Variable name="p2" />
                                                                            <Variable name="p" />
                                                                        </CheckRelationship>
                                                                        <LogicalAnd>
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isBetween" />
                                                                                <DecisionTreeVar
                                                                                    name="Z" />
                                                                                <Variable name="p1" />
                                                                                <Variable name="p2" />
                                                                            </CheckRelationship>
                                                                            <LogicalNot>
                                                                                <CheckRelationship>
                                                                                    <Relationship
                                                                                        name="isBetween" />
                                                                                    <DecisionTreeVar
                                                                                        name="X" />
                                                                                    <Variable
                                                                                        name="p1" />
                                                                                    <Variable
                                                                                        name="p2" />
                                                                                </CheckRelationship>
                                                                            </LogicalNot>
                                                                        </LogicalAnd>
                                                                    </ExistenceQuantifier>
                                                                </ExistenceQuantifier>
                                                            </ExistenceQuantifier>
                                                        </Expression>
                                                        <Outcome value="false">
                                                            <BranchResultNode value="false" />
                                                        </Outcome>
                                                        <Outcome value="true">
                                                            <BranchResultNode value="true" />
                                                        </Outcome>
                                                    </QuestionNode>
                                                </ThoughtBranch>
                                            </Outcome>
                                            <Outcome value="undetermined"
                                                _RU_text="Никак - скобки не влияют на порядок вычисления ${val('X','р')} и ${val('Z','р')}"
                                                _RU_explanation="${result ? 'скобки не влияют на порядок вычисления ${val('X','р')} и ${val('Z','р')}' : 'скобки имеют влияние на порядок вычисления ${val('X','р')} и ${val('Z','р')}'}"
                                                _RU_nextStepQuestion="В отсутствии влияния скобок, как определяется порядок выполнения стоящих рядом операторов?"
                                                _RU_nextStepBranchResult="${branchResult ? 'Левый' : 'Правый'} оператор всегда выполняется первым"
                                                _RU_nextStepExplanation="Это неверно. В отсутствии скобок, порядок выполнения стоящих рядом операторов определяется их приоритетом - его и надо рассматривать следующим."
                                                _EN_text="They don't - parentheses have no effect on ${val('X','т')} and ${val('Z','т')}"
                                                _EN_explanation="parentheses do ${result ? 'not' : ''} affect the evaluation of ${val('X','т')} and ${val('Z','т')}"
                                                _EN_nextStepQuestion="In the absence of parentheses' effect, how should one determine the order of evaluation between two operator?"
                                                _EN_nextStepBranchResult="The operator on the ${branchResult ? 'right' : 'left'} is always evaluated first."
                                                _EN_nextStepExplanation="That's incorrect. In the absence of parentheses' effect, the order of evaluation is determined by the precedence of the operators - so it should be considered next."
                                            >
                                                <QuestionNode type="comparison"
                                                    _alias="right.precedence"
                                                    _RU_asNextStep="Необходимо сравнить приоритеты ${class('X','р')} и ${class('Z','р')}"
                                                    _RU_question="Сравните приоритеты ${class('X','р')} и ${class('Z','р')}"
                                                    _RU_endingCause="Из-за соотношения приоритетов ${class('X','р')} и ${class('Z','р')}"
                                                    _EN_asNextStep="We should compare the precendence of ${class('X','р')} and ${class('Z','р')}."
                                                    _EN_question="Compare the precendence of ${class('X','р')} and ${class('Z','р')}."
                                                    _EN_endingCause="Because of the precendences of ${class('X','р')} and ${class('Z','р')}."
                                                    _RU_triviality="Приоритеты ${val('X','р')} и ${val('Z','р')} очевидно равны, так как это один и тот же оператор."
                                                    _EN_triviality="Precendences of ${val('X','р')} and ${val('Z','р')} are obviously equal as they are the same operator."
                                                >
                                                    <!-- ${class('X','р') != class('Z','р')  ?
                                                    class('X','р')
                                            + ' и ' + class('Z','р')  :  val('X','р') + ' и ' +
                                            val('Z','р')}-->
                                                    <Expression>
                                                        <Compare>
                                                            <GetPropertyValue>
                                                                <DecisionTreeVar name="X" />
                                                                <Property name="precedence" />
                                                            </GetPropertyValue>
                                                            <GetPropertyValue>
                                                                <DecisionTreeVar name="Z" />
                                                                <Property name="precedence" />
                                                            </GetPropertyValue>
                                                        </Compare>
                                                    </Expression>
                                                    <Triviality>
                                                        <Compare operator="EQUAL">
                                                            <GetClass>
                                                                <DecisionTreeVar name="X" />
                                                            </GetClass>
                                                            <GetClass>
                                                                <DecisionTreeVar name="Z" />
                                                            </GetClass>
                                                        </Compare>
                                                    </Triviality>
                                                    <!--обратное
                                            сравнение приоритетов, потому что 1 наивысший приоритет -->
                                                    <Outcome value="Comparison:less"
                                                        _RU_text="Приоритет ${class('X','р')} больше."
                                                        _RU_explanation="Это неверно, поскольку ${class('X','и')} имеет больший приоритет, чем ${class('Z','и')}."
                                                        _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих разные приоритеты?"
                                                        _RU_nextStepBranchResult="Оператор с ${branchResult ? 'большим' : 'меньшим'} приоритетом всегда выполняется первым"
                                                        _RU_nextStepExplanation="Это неверно. Оператор с большим приоритетом всегда выполняется первым. Т.к. ${class('X','и')} имеет больший приоритет, а значит может быть вычислен первым. Получается, правый операнд ${val('X','и')} не требует дальнейших вычислений."
                                                        _EN_text="${class('X','р')} has higher precendence."
                                                        _EN_explanation="That's incorrect, because ${class('X','р')} has higher precendence than ${class('Z','р')}."
                                                        _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have different precedences?"
                                                        _EN_nextStepBranchResult="Operator with a ${branchResult ? 'higher' : 'lower'} precedence is always evaluated first"
                                                        _EN_nextStepExplanation="That's incorrect. The operator with a higher precedence is always evaluated first. Therefore, in this case, the ${val('X','и')} should be evaluated first, and we can conclude that its left operand does not prevent its evaluation."
                                                    >
                                                        <BranchResultNode value="true"
                                                            _skill="left_competing_to_right_precedence"
                                                            _RU_explanation="он имеет приоритет выше, чем ${val('Z','в')}."
                                                            _EN_explanation="it has a higher priority than ${val('Z','в')}."
                                                        />
                                                    </Outcome>
                                                    <Outcome value="Comparison:greater"
                                                        _RU_text="Приоритет ${class('Z','р')} больше."
                                                        _RU_explanation="Это неверно, поскольку ${class('Z','и')} имеет больший приоритет, чем ${class('X','и')}."
                                                        _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих разные приоритеты?"
                                                        _RU_nextStepBranchResult="Оператор с ${branchResult ? 'меньшим' : 'большим'} приоритетом всегда выполняется первым"
                                                        _RU_nextStepExplanation="Это неверно. Оператор с большим приоритетом всегда выполняется первым. Т.к. ${class('Z','и')} имеет больший приоритет, он должен быть вычислен первым. Получается, правый операнд ${val('X','и')} требует дальнейших вычислений."
                                                        _EN_text="${class('Z','р')} has higher precendence."
                                                        _EN_explanation="That's incorrect, because ${class('Z','р')} has higher precendence than ${class('X','р')}."
                                                        _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have different precedences?"
                                                        _EN_nextStepBranchResult="Operator with a ${branchResult ? 'lower' : 'higher'} precedence is always evaluated first"
                                                        _EN_nextStepExplanation="That's incorrect. The operator with a higher precedence is always evaluated first. Therefore, in this case, the ${val('Z','и')} should be evaluated first, and we can conclude that the left operand of ${val('X','и')} does prevent its evaluation."
                                                    >
                                                        <BranchResultNode value="false"
                                                            _law="error_base_higher_precedence_right"
                                                            _skill="left_competing_to_right_precedence"
                                                            _error="right.precedence"
                                                            _RU_explanation="сначала должен быть вычислен ${val('Z','и')} справа от него, который имеет более высокий приоритет."
                                                            _EN_explanation="${val('Z','и')} on its right must be evaluated first because it has a higher precedence."
                                                        />
                                                    </Outcome>
                                                    <Outcome value="Comparison:equal"
                                                        _RU_text="Их приоритеты одинаковы."
                                                        _RU_explanation="Это неверно, поскольку приоритеты ${class('X','р')} и ${class('Z','р')} одинаковы."
                                                        _RU_nextStepQuestion="Как определяется порядок выполнения операторов, имеющих равные приоритеты?"
                                                        _RU_nextStepBranchResult="${branchResult ? 'Левый' : 'Правый'} оператор всегда выполняется первым"
                                                        _RU_nextStepExplanation="Это неверно. Порядок выполнения операторов, имеющих одинаковые приоритеты, задается ассоциативностью, а значит следующим шагом необходимо проверить ассоциативность ${class('X','р')} и ${class('Z','р')}."
                                                        _EN_text="They have the same precedence."
                                                        _EN_explanation="That's incorrect because ${class('X','р')} and ${class('Z','р')} have the same precedence."
                                                        _EN_nextStepQuestion="How should one determine the order of evaluation between two operators that have the same precedence?"
                                                        _EN_nextStepBranchResult="The operator on the ${branchResult ? 'right' : 'left'} is always evaluated first."
                                                        _EN_nextStepExplanation="That's incorrect. The order of evaluation between two operators that have the same precedence is determined by their associativity. Therefore we should next check the associativity of ${class('X','р')} and ${class('Z','р')}."
                                                    >
                                                        <QuestionNode type="bool"
                                                            _alias="leftOperandAssoc.isNeeded"
                                                            _RU_asNextStep="Необходимо проверить, нужен ли ${val('X','д')} левый операнд."
                                                            _RU_question="Нужен ли ${class('X','д')} левый операнд?"
                                                            _RU_endingCause="Потому что ${val('X','и')} не требует левого операнда"
                                                            _EN_asNextStep="We should check if ${val('X','д')} needs a left operand."
                                                            _EN_question="Does ${class('X','д')} need a left operand?"
                                                            _EN_endingCause="Because ${val('X','и')} doesn't need a left operand."
                                                        >
                                                            <Expression>
                                                                <GetPropertyValue>
                                                                    <DecisionTreeVar name="X" />
                                                                    <Property
                                                                        name="needsLeftOperand" />
                                                                </GetPropertyValue>
                                                            </Expression>
                                                            <Outcome value="false"
                                                                _RU_explanation="Это неверно. ${class('X','и')} не имеет (не требует) левого операнда."
                                                                _RU_nextStepQuestion="Какие выводы можно сделать, если ${val('X','и')} не требует левого операнда?"
                                                                _RU_nextStepExplanation="Это неверно. Если оператор не имеет левого операнда, то и дальнейших вычислений его левый операнд требовать не может."
                                                                _EN_explanation="That's incorrect, because ${class('X','и')} doesn't need a left operand."
                                                                _EN_nextStepQuestion="What is the next reasoning step if we know that ${class('X','и')} doesn't need a left operand?"
                                                                _EN_nextStepExplanation="That's incorrect. If it doesn't need a left operand, then the left operand can't prevent its further evaluation."
                                                            >
                                                                <BranchResultNode value="false"
                                                                    _skill="associativity_without_left_opposing_operand"
                                                                    _RU_explanation="сначала должен быть вычислен ${val('Z','и')} справа от него: эти операторы имеют одинаковый приоритет, и вычисляются справа налево (правоассоциативны)."
                                                                    _EN_explanation=" ${val('Z','и')} on its right must be evaluated first - these operators have the same precedence, but are evaluated from right to left (have right associativity)."
                                                                />
                                                            </Outcome>
                                                            <Outcome value="true"
                                                                _RU_explanation="Это неверно. ${class('X','д')} всегда необходим левый операнд."
                                                                _RU_nextStepQuestion="Какие выводы можно сделать, если ${val('X','д')} нужен левый операнд?"
                                                                _RU_nextStepExplanation="Это неверно. Необходимо дальше рассмотреть потенциально конкурирующие с ${val('X','т')} операторы, и делать выводы исходя из их наличия/отсуствия."
                                                                _EN_explanation="That's incorrect, because ${class('X','и')} does require a left operand."
                                                                _EN_nextStepQuestion="What is the next reasoning step if we know that ${class('X','и')} needs a left operand?"
                                                                _EN_nextStepExplanation="That's incorrect. From here, one should check if there are any operators that should still be evaluated in the left operand, and then reason based on that."
                                                            >
                                                                <QuestionNode type="enum"
                                                                    enumOwner="associativity"
                                                                    _alias="right.associativity"
                                                                    _RU_asNextStep="Необходимо проверить, какова ассоциативность ${class('X','р')} и ${class('Z','р')}"
                                                                    _RU_question="Какова ассоциативность ${class('X','р')} и ${class('Z','р')}?"
                                                                    _RU_endingCause="Из-за ассоциативности ${class('X','р')} и ${class('Z','р')}"
                                                                    _EN_asNextStep="We should determine the associativity of ${class('X','р')} and ${class('Z','р')}"
                                                                    _EN_question="What's the associativity of ${class('X','р')} and ${class('Z','р')}?"
                                                                    _EN_endingCause="Because of the associatity of ${class('X','р')} and ${class('Z','р')}"
                                                                >
                                                                    <Expression>
                                                                        <GetPropertyValue>
                                                                            <DecisionTreeVar
                                                                                name="Z" />
                                                                            <Property
                                                                                name="associativity" />
                                                                        </GetPropertyValue>
                                                                    </Expression>
                                                                    <Outcome
                                                                        value="associativity:right"
                                                                        _RU_text="правая"
                                                                        _RU_explanation="Это неверно, поскольку ${class('X','и')} и ${class('Z','и')} имеют правую ассоциативность."
                                                                        _RU_nextStepQuestion="Какой из двух рядом стоящих операторов выполнится первым, если операторы имеют правую ассоциативность?"
                                                                        _RU_nextStepBranchResult="${branchResult ? 'Левый' : 'Правый'}"
                                                                        _RU_nextStepExplanation="Это неверно. При правой ассоциативности операторы выполняются справа налево. В данном случае это значит, ${class('Z','и')} должен быть вычислен первым. Получается, правый операнд ${val('X','и')} требует дальнейших вычислений."
                                                                        _EN_text="right"
                                                                        _EN_explanation="That's incorrect, because ${class('X','р')} and ${class('Z','р')} have right associativity."
                                                                        _EN_nextStepQuestion="Which of the two nearby operators evaluates first if they have right associativity?"
                                                                        _EN_nextStepBranchResult="The one on the ${branchResult ? 'left' : 'right'}"
                                                                        _EN_nextStepExplanation="That's incorrect. Operators that have right associativity evaluate from right to left. Therefore, in this case, ${class('Z','и')} should be evaluated first, and we can conclude that the right operand of ${val('X','и')} does prevent its evaluation."
                                                                    >
                                                                        <BranchResultNode
                                                                            value="false"
                                                                            _law="error_base_same_precedence_right_associativity_right"
                                                                            _skill="left_competing_to_right_associativity"
                                                                            _error="right.associativity"
                                                                            _RU_explanation="сначала должен быть вычислен ${val('Z','и')} справа от него: эти операторы имеют одинаковый приоритет, и вычисляются справа налево (правоассоциативны)."
                                                                            _EN_explanation=" ${val('Z','и')} on its right must be evaluated first - these operators have the same precedence, but are evaluated from right to left (have right associativity)."
                                                                        />
                                                                    </Outcome>
                                                                    <Outcome
                                                                        value="associativity:left"
                                                                        _RU_text="правая"
                                                                        _RU_explanation="Это неверно, поскольку ${class('X','и')} и ${class('Z','и')} имеют правую ассоциативность."
                                                                        _RU_nextStepQuestion="Какой из двух рядом стоящих операторов выполнится первым, если операторы имеют правую ассоциативность?"
                                                                        _RU_nextStepBranchResult="${branchResult ? 'Правый' : 'Левый'}"
                                                                        _RU_nextStepExplanation="Это неверно. При левой ассоциативности операторы выполняются слева направо. В данном случае это значит, ${class('X','и')} должен быть вычислен первым. Получается, правый операнд ${val('X','и')} не требует дальнейших вычислений."
                                                                        _EN_text="left"
                                                                        _EN_explanation="That's incorrect, because ${class('X','р')} and ${class('Z','р')} have left associativity."
                                                                        _EN_nextStepQuestion="Which of the two nearby operators evaluates first if they have left associativity?"
                                                                        _EN_nextStepBranchResult="The one on the ${branchResult ? 'left' : 'right'}"
                                                                        _EN_nextStepExplanation="That's incorrect. Operators that have left associativity evaluate from left to right. Therefore, in this case, ${class('X','и')} should be evaluated first, anand we can conclude that its left operand does not prevent its evaluation."
                                                                    >
                                                                        <BranchResultNode
                                                                            value="true"
                                                                            _skill="left_competing_to_right_associativity"
                                                                            _RU_explanation=" имеет одинаковый приоритет с ${val('Z','р')} и левую ассоциативность (вычисляются слева направо) ."
                                                                            _EN_explanation="it has the same precedence as ${val('Z','р')} and left associativity."
                                                                        />
                                                                    </Outcome>
                                                                </QuestionNode>
                                                            </Outcome>
                                                        </QuestionNode>
                                                    </Outcome>
                                                </QuestionNode>
                                            </Outcome>
                                        </PredeterminingFactorsNode>
                                    </Outcome>
                                </QuestionNode>

                            </Outcome>
                        </FindActionNode>
                    </Outcome>
                </QuestionNode>
            </ThoughtBranch>
            <ThoughtBranch type="bool" _alias="strict"
                _RU_description="вычислению ${val('X','р')} ${result ? 'не' : ''} мешают операторы со строгим порядком операндов"
                _RU_nextStepQuestion="С чего надо начать при определении того, мешают ли вычислению ${val('X','р')} операторы со строгим порядком операндов?"
                _RU_nextStepExplanation="Это неверно. Прежде всего необходимо найти все подобные операторы, которые могут помешать вычислению ${val('X','р')}"
                _EN_description="${result ? 'no' : 'some'} operators with strict operand order should be considered before ${val('X','и')} can be evaluated"
                _EN_nextStepQuestion="What is the first step when considering operators with strict operand order?"
                _EN_nextStepExplanation="That's incorrect. One should first find all such operators and check if they really hinder the evaluation of ${val('X', 'и')."
            >
                <CycleAggregationNode operator="AND"
                    _alias="Для всех операторов со строгим порядком - T"
                    _RU_description="вычислению ${val('X','р')} ${result ? 'не' : ''} мешают операторы со строгим порядком операндов"
                    _RU_question="Выберите все операторы со строгим порядком операндов, которые могут помешать вычислению ${val('X','р')}"
                    _EN_description="${result ? 'no' : 'some'} operators with strict operand order should be considered before ${val('X','и')} can be evaluated"
                    _EN_question="Choose all operators with strict operand order that can influence the evaluation of ${val('X','р')}"
                >
                    <SelectorExpression>
                        <!-- Patch: операторы строгого порядка не обязательно должны быть
                        невычисленными-->
                        <Boolean value="true" />
                    </SelectorExpression>
                    <FindError priority="1" type="operator" _alias="T_notStrict"
                        _RU_explanation="${obj(checked, 'и')} не является оператором со строгим порядком операндов"
                        _EN_explanation="${obj(checked, 'и')} is not an operator with a strict operand order."
                    >
                        <Expression>
                            <LogicalAnd>
                                <Compare operator="NOT_EQUAL">
                                    <DecisionTreeVar name="X" />
                                    <Variable name="checked" />
                                </Compare>
                                <LogicalNot>
                                    <CheckClass>
                                        <Variable name="checked" />
                                        <Class name="StrictOrderOperator" />
                                    </CheckClass>
                                </LogicalNot>
                            </LogicalAnd>
                        </Expression>
                    </FindError>
                    <DecisionTreeVarDecl name="T" type="StrictOrderOperator" />
                    <Outcome value="True">
                        <BranchResultNode value="true"
                            _skill="expression_strict_order_operators_present"
                            _RU_explanation="в выражении нет операторов со строгим порядком вычисления операндов."
                            _EN_explanation="the expression does not contain operators with strict order of operand evaluation."
                        />
                    </Outcome>
                    <Outcome value="False">
                        <BranchResultNode value="false" />
                    </Outcome>
                    <ThoughtBranch type="bool" paramName="T" _alias="strict.Tcycle"
                        _RU_description="${val('T','и')} ${result ? 'не' : ''} мешает вычислению ${val('X','р')} как оператор со строгим порядком операндов"
                        _RU_nextStepQuestion="С чего надо начать, чтобы определить, мешают ли ${val('T','и')} вычислению ${val('X','р')}?"
                        _RU_nextStepExplanation="Это неверно. Прежде всего необходимо определить, вычислен ли уже левый операнд ${val('T','р')}."
                        _EN_description="${val('T','и')} does ${result ? 'not' : ''} hinder evaluation of ${val('X','р')} as an operator with strict order of operands"
                        _EN_nextStepQuestion="What is the first step to determine if ${val('T','и')} hinders the evaluation of ${val('X','р')}?"
                        _EN_nextStepExplanation="That's incorrect. We should first determine, if the left operand of ${val('T','р')} is fully evaluated."
                    >
                        <QuestionNode _alias="X не в операнде Т"
                            type="bool" isSwitch="false"
                        >
                            <Expression>
                                <LogicalNot>
                                    <CheckRelationship>
                                        <Relationship name="isInOperandOf" />
                                        <DecisionTreeVar name="X" />
                                        <DecisionTreeVar name="T" />
                                    </CheckRelationship>
                                </LogicalNot>
                            </Expression>
                            <Outcome value="True">
                                <BranchResultNode value="true"
                                    _skill="is_current_operator_strict_order"
                                    _RU_explanation="${val('X','и')} не находится в операнде ${val('T','п')} который имеет строгий порядок вычисления операндов."
                                    _EN_explanation="${val('X','и')} is not a part of any operand of ${val('T','и')} which has a strict order of operand evaluation"
                                />
                            </Outcome>
                            <Outcome value="False">
                                <QuestionNode _alias="X в его первом операнде"
                                    type="bool" isSwitch="false">
                                    <Expression>
                                        <LogicalOr>
                                            <LogicalOr>
                                                <LogicalAnd>
                                                    <Compare operator="EQUAL">
                                                        <GetPropertyValue>
                                                            <DecisionTreeVar name="T" />
                                                            <Property name="firstOperandPosition" />
                                                        </GetPropertyValue>
                                                        <Enum owner="OperandPosition" value="left" />
                                                    </Compare>
                                                    <LogicalOr>
                                                        <CheckRelationship>
                                                            <Relationship name="isLeftOperandOf" />
                                                            <DecisionTreeVar name="X" />
                                                            <DecisionTreeVar name="T" />
                                                        </CheckRelationship>
                                                        <ExistenceQuantifier varName="l"
                                                            type="operator">
                                                            <CheckRelationship>
                                                                <Relationship name="isLeftOperandOf" />
                                                                <Variable name="l" />
                                                                <DecisionTreeVar name="T" />
                                                            </CheckRelationship>
                                                            <CheckRelationship>
                                                                <Relationship name="isInOperandOf" />
                                                                <DecisionTreeVar name="X" />
                                                                <Variable name="l" />
                                                            </CheckRelationship>
                                                        </ExistenceQuantifier>
                                                    </LogicalOr>
                                                </LogicalAnd>
                                                <LogicalAnd>
                                                    <Compare operator="EQUAL">
                                                        <GetPropertyValue>
                                                            <DecisionTreeVar name="T" />
                                                            <Property name="firstOperandPosition" />
                                                        </GetPropertyValue>
                                                        <Enum owner="OperandPosition" value="center" />
                                                    </Compare>
                                                    <LogicalOr>
                                                        <CheckRelationship>
                                                            <Relationship name="isCenterOperandOf" />
                                                            <DecisionTreeVar name="X" />
                                                            <DecisionTreeVar name="T" />
                                                        </CheckRelationship>
                                                        <ExistenceQuantifier varName="c"
                                                            type="operator">
                                                            <CheckRelationship>
                                                                <Relationship
                                                                    name="isCenterOperandOf" />
                                                                <Variable name="c" />
                                                                <DecisionTreeVar name="T" />
                                                            </CheckRelationship>
                                                            <CheckRelationship>
                                                                <Relationship name="isInOperandOf" />
                                                                <DecisionTreeVar name="X" />
                                                                <Variable name="c" />
                                                            </CheckRelationship>
                                                        </ExistenceQuantifier>
                                                    </LogicalOr>
                                                </LogicalAnd>
                                            </LogicalOr>
                                            <LogicalAnd>
                                                <Compare operator="EQUAL">
                                                    <GetPropertyValue>
                                                        <DecisionTreeVar name="T" />
                                                        <Property name="firstOperandPosition" />
                                                    </GetPropertyValue>
                                                    <Enum owner="OperandPosition" value="right" />
                                                </Compare>
                                                <LogicalOr>
                                                    <CheckRelationship>
                                                        <Relationship name="isRightOperandOf" />
                                                        <DecisionTreeVar name="X" />
                                                        <DecisionTreeVar name="T" />
                                                    </CheckRelationship>
                                                    <ExistenceQuantifier varName="r" type="operator">
                                                        <CheckRelationship>
                                                            <Relationship name="isRightOperandOf" />
                                                            <Variable name="r" />
                                                            <DecisionTreeVar name="T" />
                                                        </CheckRelationship>
                                                        <CheckRelationship>
                                                            <Relationship name="isInOperandOf" />
                                                            <DecisionTreeVar name="X" />
                                                            <Variable name="r" />
                                                        </CheckRelationship>
                                                    </ExistenceQuantifier>
                                                </LogicalOr>
                                            </LogicalAnd>
                                        </LogicalOr>
                                    </Expression>
                                    <Outcome value="True">
                                        <BranchResultNode value="true"
                                            _skill="strict_order_first_operand_to_be_evaluated_while_solving"
                                            _RU_explanation="${val('X','и')} должен быть вычислен первым в ${val('T','п')}."
                                            _EN_explanation="${val('X','и')} must be evaluated first in ${val('T','п')}."
                                        />
                                    </Outcome>
                                    <Outcome value="False">
                                        <QuestionNode
                                            _alias="Есть ли в первом операнде T невычисленный оператор (u)?"
                                            type="bool" isSwitch="false"
                                            _RU_asNextStep="Необходимо проверить, остались ли в левом операнде ${val('T','р')} невычисленные операторы."
                                            _RU_question="Остались ли в левом операнде ${val('T','р')} невычисленные операторы?"
                                            _RU_endingCause="Поскольку в левом операнде ${val('T','р')} не осталось невычисленных операторов"
                                            _EN_asNextStep="We need to check if there are any unevaluated operators in the left operand of ${val('T','р')}."
                                            _EN_question="Are there any unevaluated operators in the left operand of ${val('T','р')}?"
                                            _EN_endingCause="Because there are no unevaluated operators in the left operand of ${val('T','р')}"
                                        >
                                            <Expression>
                                                <ExistenceQuantifier varName="u">
                                                    <CheckClass>
                                                        <Variable name="u" />
                                                        <Class name="operator" />
                                                    </CheckClass>
                                                    <LogicalAnd>
                                                        <Compare operator="EQUAL">
                                                            <GetPropertyValue>
                                                                <Variable name="u" />
                                                                <Property name="state" />
                                                            </GetPropertyValue>
                                                            <Enum owner="state" value="unevaluated" />
                                                        </Compare>
                                                        <LogicalOr>
                                                            <LogicalOr>
                                                                <LogicalAnd>
                                                                    <Compare operator="EQUAL">
                                                                        <GetPropertyValue>
                                                                            <DecisionTreeVar
                                                                                name="T" />
                                                                            <Property
                                                                                name="firstOperandPosition" />
                                                                        </GetPropertyValue>
                                                                        <Enum
                                                                            owner="OperandPosition"
                                                                            value="left" />
                                                                    </Compare>
                                                                    <LogicalOr>
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="isLeftOperandOf" />
                                                                            <Variable name="u" />
                                                                            <DecisionTreeVar
                                                                                name="T" />
                                                                        </CheckRelationship>
                                                                        <ExistenceQuantifier
                                                                            varName="l"
                                                                            type="operator">
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isLeftOperandOf" />
                                                                                <Variable name="l" />
                                                                                <DecisionTreeVar
                                                                                    name="T" />
                                                                            </CheckRelationship>
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isInOperandOf" />
                                                                                <Variable name="u" />
                                                                                <Variable name="l" />
                                                                            </CheckRelationship>
                                                                        </ExistenceQuantifier>
                                                                    </LogicalOr>
                                                                </LogicalAnd>
                                                                <LogicalAnd>
                                                                    <Compare operator="EQUAL">
                                                                        <GetPropertyValue>
                                                                            <DecisionTreeVar
                                                                                name="T" />
                                                                            <Property
                                                                                name="firstOperandPosition" />
                                                                        </GetPropertyValue>
                                                                        <Enum
                                                                            owner="OperandPosition"
                                                                            value="center" />
                                                                    </Compare>
                                                                    <LogicalOr>
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="isCenterOperandOf" />
                                                                            <Variable name="u" />
                                                                            <DecisionTreeVar
                                                                                name="T" />
                                                                        </CheckRelationship>
                                                                        <ExistenceQuantifier
                                                                            varName="c"
                                                                            type="operator">
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isCenterOperandOf" />
                                                                                <Variable name="c" />
                                                                                <DecisionTreeVar
                                                                                    name="T" />
                                                                            </CheckRelationship>
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isInOperandOf" />
                                                                                <Variable name="u" />
                                                                                <Variable name="c" />
                                                                            </CheckRelationship>
                                                                        </ExistenceQuantifier>
                                                                    </LogicalOr>
                                                                </LogicalAnd>
                                                            </LogicalOr>
                                                            <LogicalAnd>
                                                                <Compare operator="EQUAL">
                                                                    <GetPropertyValue>
                                                                        <DecisionTreeVar name="T" />
                                                                        <Property
                                                                            name="firstOperandPosition" />
                                                                    </GetPropertyValue>
                                                                    <Enum owner="OperandPosition"
                                                                        value="right" />
                                                                </Compare>
                                                                <LogicalOr>
                                                                    <CheckRelationship>
                                                                        <Relationship
                                                                            name="isRightOperandOf" />
                                                                        <Variable name="u" />
                                                                        <DecisionTreeVar name="T" />
                                                                    </CheckRelationship>
                                                                    <ExistenceQuantifier varName="r"
                                                                        type="operator">
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="isRightOperandOf" />
                                                                            <Variable name="r" />
                                                                            <DecisionTreeVar
                                                                                name="T" />
                                                                        </CheckRelationship>
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="isInOperandOf" />
                                                                            <Variable name="u" />
                                                                            <Variable name="r" />
                                                                        </CheckRelationship>
                                                                    </ExistenceQuantifier>
                                                                </LogicalOr>
                                                            </LogicalAnd>
                                                        </LogicalOr>
                                                    </LogicalAnd>
                                                </ExistenceQuantifier>
                                            </Expression>
                                            <Outcome value="True"
                                                _RU_explanation="Это неверно, поскольку такие операторы все еще есть."
                                                _RU_nextStepQuestion="Какой вывод можно сделать, если у оператора со строгим порядком операндов не вычислен левый операнд?"
                                                _RU_nextStepBranchResult="Левый операнд ${val('T','р')} ${branchResult ? 'опускается' : 'должен быть вычислен первым'}, а значит ${val('T','и')} ${branchResult ? 'не' : ''} мешает вычислению ${val('X','р')}."
                                                _RU_nextStepExplanation="Это неверно. В операторах со строгим порядком операндов левый операнд всегда должен вычисляться первым, и значит ${val('X','и')} пока не может быть вычислен."
                                                _EN_explanation="That's incorrect, because there are still unevaluated operators."
                                                _EN_nextStepQuestion="What can we decide if an operator with a strict order of operands has yet-unevaluated operand?"
                                                _EN_nextStepBranchResult="Left operand of ${val('T','р')} ${branchResult ? 'is omitted' : 'should be evaluated first'}, and so ${val('T','и')} does ${branchResult ? 'not' : ''} hinder the evaluation of ${val('X','р')}."
                                                _EN_nextStepExplanation="That's incorrect. In operators with strict operand order, the left operand must always be evaluated first, and so ${val('X','и')} cannot be evaluated yet."
                                            >
                                                <BranchResultNode value="false"
                                                    _skill="is_first_operand_of_strict_order_operator_fully_evaluated"
                                                    _law="error_base_student_error_strict_operands_order"
                                                    _error="strict.leftShouldBeEvaluatedFirst"
                                                    _RU_explanation="сначала должен быть полностью вычислен левый операнд ${val('T','р')} - потому что это оператор со строгим порядком операндов"
                                                    _EN_explanation="left operand of ${val('T','р')} should be fully evaluated first because ${val('T','р')} is an operator with a strict operand order"
                                                />
                                            </Outcome>
                                            <Outcome value="False"
                                                _RU_explanation="Это неверно, поскольку таких операторов нет - все вычислены."
                                                _RU_nextStepQuestion="Какие дальнейшие шаги нужны при рассмотрении операторов со строгим порядком операндов?"
                                                _RU_nextStepExplanation="Это неверно. Большинство операторов со строгим порядком операндов также предполагают, 
                                что в некоторых ситуациях их операнды могут быть опущены. Поэтому далее нужно проверить, применимо ли это в данном случае."
                                                _EN_explanation="This is incorrect, because there are no such operators - they are all evaluated."
                                                _EN_nextStepQuestion="What further steps are needed when considering operators with strict operand order?"
                                                _EN_nextStepExplanation="This is incorrect. Most operators with strict operand ordering also involve their operands
                                 being omitted in some situations. So next we need to check whether that applies in this case."
                                            >
                                                <QuestionNode
                                                    _alias="Может ли опускать операнд, в котором X"
                                                    type="bool" isSwitch="false"
                                                    _RU_asNextStep="Нужно проверить, могут ли операнды ${class('T','р')} быть опущены."
                                                    _RU_question="Могут ли операнды ${class('T','р')} быть опущены?"
                                                    _RU_endingCause="Поскольку ${class('T','и')} не предполагает опущения своих операндов"
                                                    _EN_asNextStep="We need to check if the operands of ${class('T','p')} can be omitted."
                                                    _EN_question="Can the operands of ${class('T','p')} be omitted?"
                                                    _EN_endingCause="Because ${class('T','и')} does not involve the omission of its operands"
                                                >
                                                    <Expression>
                                                        <LogicalOr>
                                                            <LogicalOr>
                                                                <LogicalAnd>
                                                                    <Compare operator="NOT_EQUAL">
                                                                        <GetPropertyValue>
                                                                            <DecisionTreeVar
                                                                                name="T" />
                                                                            <Property
                                                                                name="requiredFirstValForLeft" />
                                                                        </GetPropertyValue>
                                                                        <Enum owner="ExpectedValue"
                                                                            value="any" />
                                                                    </Compare>
                                                                    <LogicalOr>
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="isLeftOperandOf" />
                                                                            <DecisionTreeVar
                                                                                name="X" />
                                                                            <DecisionTreeVar
                                                                                name="T" />
                                                                        </CheckRelationship>
                                                                        <ExistenceQuantifier
                                                                            type="operator"
                                                                            varName="l">
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isLeftOperandOf" />
                                                                                <Variable name="l" />
                                                                                <DecisionTreeVar
                                                                                    name="T" />
                                                                            </CheckRelationship>
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isInOperandOf" />
                                                                                <DecisionTreeVar
                                                                                    name="X" />
                                                                                <Variable name="l" />
                                                                            </CheckRelationship>
                                                                        </ExistenceQuantifier>
                                                                    </LogicalOr>
                                                                </LogicalAnd>
                                                                <LogicalAnd>
                                                                    <Compare operator="NOT_EQUAL">
                                                                        <GetPropertyValue>
                                                                            <DecisionTreeVar
                                                                                name="T" />
                                                                            <Property
                                                                                name="requiredFirstValForCenter" />
                                                                        </GetPropertyValue>
                                                                        <Enum owner="ExpectedValue"
                                                                            value="any" />
                                                                    </Compare>
                                                                    <LogicalOr>
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="isCenterOperandOf" />
                                                                            <DecisionTreeVar
                                                                                name="X" />
                                                                            <DecisionTreeVar
                                                                                name="T" />
                                                                        </CheckRelationship>
                                                                        <ExistenceQuantifier
                                                                            type="operator"
                                                                            varName="c">
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isCenterOperandOf" />
                                                                                <Variable name="c" />
                                                                                <DecisionTreeVar
                                                                                    name="T" />
                                                                            </CheckRelationship>
                                                                            <CheckRelationship>
                                                                                <Relationship
                                                                                    name="isInOperandOf" />
                                                                                <DecisionTreeVar
                                                                                    name="X" />
                                                                                <Variable name="c" />
                                                                            </CheckRelationship>
                                                                        </ExistenceQuantifier>
                                                                    </LogicalOr>
                                                                </LogicalAnd>
                                                            </LogicalOr>
                                                            <LogicalAnd>
                                                                <Compare operator="NOT_EQUAL">
                                                                    <GetPropertyValue>
                                                                        <DecisionTreeVar name="T" />
                                                                        <Property
                                                                            name="requiredFirstValForRight" />
                                                                    </GetPropertyValue>
                                                                    <Enum owner="ExpectedValue"
                                                                        value="any" />
                                                                </Compare>
                                                                <LogicalOr>
                                                                    <CheckRelationship>
                                                                        <Relationship
                                                                            name="isRightOperandOf" />
                                                                        <DecisionTreeVar name="X" />
                                                                        <DecisionTreeVar name="T" />
                                                                    </CheckRelationship>
                                                                    <ExistenceQuantifier
                                                                        type="operator"
                                                                        varName="r">
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="isRightOperandOf" />
                                                                            <Variable name="r" />
                                                                            <DecisionTreeVar
                                                                                name="T" />
                                                                        </CheckRelationship>
                                                                        <CheckRelationship>
                                                                            <Relationship
                                                                                name="isInOperandOf" />
                                                                            <DecisionTreeVar
                                                                                name="X" />
                                                                            <Variable name="r" />
                                                                        </CheckRelationship>
                                                                    </ExistenceQuantifier>
                                                                </LogicalOr>
                                                            </LogicalAnd>
                                                        </LogicalOr>
                                                    </Expression>
                                                    <Outcome value="False"
                                                        _RU_explanation="Это неверно. Хотя ${class('T','и')} и задает строгий порядок своих операндов, он не подразумевает их пропуска."
                                                        _RU_nextStepQuestion="Какой вывод можно сделать, в таком случае?"
                                                        _RU_nextStepExplanation="Это неверно. Поскольку ${class('T','и')} не опускает свои операнды, и его левый операнд уже полностью вычислен, 
                                        то и вычислению ${val('X','и')} он не мешает."
                                                        _EN_explanation="This is incorrect. Although ${class('T','р')} defines a strict order for its operands, it does not involve their omission."
                                                        _EN_nextStepQuestion="What can we decide in this case?"
                                                        _EN_nextStepExplanation="This is incorrect. Since ${class('T','и')} does not omit its operands, and its left operand is already fully evaluated,
                                         it does not interfere with the evaluation of ${val('X','and')}."
                                                    >
                                                        <BranchResultNode value="true"
                                                            _skill="no_omitted_operands_despite_strict_order_while_solving"
                                                            _RU_explanation="В ${val('T','п')} нет операндов, вычисление которых можно было бы опустить."
                                                            _EN_explanation="In ${val('T','п')} there are no operands whose evaluation could be omitted."
                                                        />
                                                    </Outcome>
                                                    <Outcome value="True"
                                                        _RU_explanation="Это неверно. В ${class('T','п')} может быть опущен операнд, в котором находится ${val('X', 'и')}."
                                                        _RU_nextStepQuestion="Какие дальнейшие шаги нужны при рассмотрении операторов со строгим порядком операндов?"
                                                        _RU_nextStepExplanation="Это неверно. Сначала необходимо определить, в каком операнде ${val('T','р')} находится ${val('X','и')},
                                         а уже затем проверять, не должен ли он быть пропущен в данной ситуации."
                                                        _EN_explanation="This is incorrect. Although ${class('T','р')} defines a strict order for its operands, it does not involve their omission."
                                                        _EN_nextStepQuestion="What further steps are needed when considering operators with strict operand order?"
                                                        _EN_nextStepExplanation="This is incorrect. First, we need to determine which operand of ${val('T','р')} contains ${val('X','и')}, 
                                        and only then check whether it should be omitted in this situation."
                                                    >
                                                        <TupleQuestionNode
                                                            _alias="опускается ли Х (кортеж)"
                                                            _RU_asNextStep="Необходимо проверить, опускается ли правый операнд ${val('T','р')} в данном случае."
                                                            _RU_endingCause="Поскольку ${val('X','и')} опускается как правый операнд ${class('T','р')}."
                                                            _EN_asNextStep="We need to check whether the right operand of ${class('T','р')} should be omitted."
                                                            _EN_endingCause="Because ${val('X','и')} is omitted as the right operand of ${class('T','р')}."
                                                        >
                                                            <Part
                                                                _alias="Какое значение должно быть у левого чтобы правый вычислился"
                                                                _RU_question="При каком значении левого операнда в ${class('T','п')} вычисляется правый операнд?"
                                                                _EN_question="What value should the left operand of ${class('T','п')} have in order for its right operand to be evaluated?"
                                                            >
                                                                <Expression>
                                                                    <LogicalOr>
                                                                        <LogicalOr>
                                                                            <LogicalAnd>
                                                                                <Compare
                                                                                    operator="EQUAL">
                                                                                    <GetPropertyValue>
                                                                                        <DecisionTreeVar
                                                                                            name="T" />
                                                                                        <Property
                                                                                            name="requiredFirstValForLeft" />
                                                                                    </GetPropertyValue>
                                                                                    <Enum
                                                                                        owner="ExpectedValue"
                                                                                        value="true" />
                                                                                </Compare>
                                                                                <LogicalOr>
                                                                                    <CheckRelationship>
                                                                                        <Relationship
                                                                                            name="isLeftOperandOf" />
                                                                                        <DecisionTreeVar
                                                                                            name="X" />
                                                                                        <DecisionTreeVar
                                                                                            name="T" />
                                                                                    </CheckRelationship>
                                                                                    <ExistenceQuantifier
                                                                                        type="operator"
                                                                                        varName="l">
                                                                                        <CheckRelationship>
                                                                                            <Relationship
                                                                                                name="isLeftOperandOf" />
                                                                                            <Variable
                                                                                                name="l" />
                                                                                            <DecisionTreeVar
                                                                                                name="T" />
                                                                                        </CheckRelationship>
                                                                                        <CheckRelationship>
                                                                                            <Relationship
                                                                                                name="isInOperandOf" />
                                                                                            <DecisionTreeVar
                                                                                                name="X" />
                                                                                            <Variable
                                                                                                name="l" />
                                                                                        </CheckRelationship>
                                                                                    </ExistenceQuantifier>
                                                                                </LogicalOr>
                                                                            </LogicalAnd>
                                                                            <LogicalAnd>
                                                                                <Compare
                                                                                    operator="EQUAL">
                                                                                    <GetPropertyValue>
                                                                                        <DecisionTreeVar
                                                                                            name="T" />
                                                                                        <Property
                                                                                            name="requiredFirstValForCenter" />
                                                                                    </GetPropertyValue>
                                                                                    <Enum
                                                                                        owner="ExpectedValue"
                                                                                        value="true" />
                                                                                </Compare>
                                                                                <LogicalOr>
                                                                                    <CheckRelationship>
                                                                                        <Relationship
                                                                                            name="isCenterOperandOf" />
                                                                                        <DecisionTreeVar
                                                                                            name="X" />
                                                                                        <DecisionTreeVar
                                                                                            name="T" />
                                                                                    </CheckRelationship>
                                                                                    <ExistenceQuantifier
                                                                                        type="operator"
                                                                                        varName="c">
                                                                                        <CheckRelationship>
                                                                                            <Relationship
                                                                                                name="isCenterOperandOf" />
                                                                                            <Variable
                                                                                                name="c" />
                                                                                            <DecisionTreeVar
                                                                                                name="T" />
                                                                                        </CheckRelationship>
                                                                                        <CheckRelationship>
                                                                                            <Relationship
                                                                                                name="isInOperandOf" />
                                                                                            <DecisionTreeVar
                                                                                                name="X" />
                                                                                            <Variable
                                                                                                name="c" />
                                                                                        </CheckRelationship>
                                                                                    </ExistenceQuantifier>
                                                                                </LogicalOr>
                                                                            </LogicalAnd>
                                                                        </LogicalOr>
                                                                        <LogicalAnd>
                                                                            <Compare
                                                                                operator="EQUAL">
                                                                                <GetPropertyValue>
                                                                                    <DecisionTreeVar
                                                                                        name="T" />
                                                                                    <Property
                                                                                        name="requiredFirstValForRight" />
                                                                                </GetPropertyValue>
                                                                                <Enum
                                                                                    owner="ExpectedValue"
                                                                                    value="true" />
                                                                            </Compare>
                                                                            <LogicalOr>
                                                                                <CheckRelationship>
                                                                                    <Relationship
                                                                                        name="isRightOperandOf" />
                                                                                    <DecisionTreeVar
                                                                                        name="X" />
                                                                                    <DecisionTreeVar
                                                                                        name="T" />
                                                                                </CheckRelationship>
                                                                                <ExistenceQuantifier
                                                                                    type="operator"
                                                                                    varName="r">
                                                                                    <CheckRelationship>
                                                                                        <Relationship
                                                                                            name="isRightOperandOf" />
                                                                                        <Variable
                                                                                            name="r" />
                                                                                        <DecisionTreeVar
                                                                                            name="T" />
                                                                                    </CheckRelationship>
                                                                                    <CheckRelationship>
                                                                                        <Relationship
                                                                                            name="isInOperandOf" />
                                                                                        <DecisionTreeVar
                                                                                            name="X" />
                                                                                        <Variable
                                                                                            name="r" />
                                                                                    </CheckRelationship>
                                                                                </ExistenceQuantifier>
                                                                            </LogicalOr>
                                                                        </LogicalAnd>
                                                                    </LogicalOr>
                                                                </Expression>
                                                                <Outcome value="true"
                                                                    _RU_text="true"
                                                                    _RU_explanation="Это неверно. ${class('T','и')} вычисляет правый операнд только в случае, если левый имеет значение true.
                                                            В ином случае правый операнд опускается."
                                                                    _EN_text="true"
                                                                    _EN_explanation="That's incorrect. ${class('T','и')} only evaluates its right operand, if the left evaluates as 'true'.
                                                            Otherwise the right operand is omitted."
                                                                />
                                                                <Outcome value="false"
                                                                    _RU_text="false"
                                                                    _RU_explanation="Это неверно. ${class('T','и')} вычисляет правый операнд только в случае, если левый имеет значение false.
                                                            В ином случае правый операнд опускается."
                                                                    _EN_text="false"
                                                                    _EN_explanation="That's incorrect. ${class('T','и')} only evaluates its right operand, if the left evaluates as 'false'.
                                                            Otherwise the right operand is omitted."
                                                                />
                                                            </Part>
                                                    <Part
                                                                _alias="Какое значение у первого"
                                                                _RU_question="Какое значение имеет первый операнд ${val('T','р')} в данном случае?"
                                                                _EN_question="What is the value of first operand of ${val('T','р')} in this case?"
                                                            >
                                                                <Expression>
                                                                    <IfThen>
                                                                        <Compare operator="EQUAL">
                                                                            <GetPropertyValue>
                                                                                <DecisionTreeVar
                                                                                    name="T" />
                                                                                <Property
                                                                                    name="firstOperandPosition" />
                                                                            </GetPropertyValue>
                                                                            <Enum
                                                                                owner="OperandPosition"
                                                                                value="left" />
                                                                        </Compare>
                                                                        <GetPropertyValue>
                                                                            <GetByRelationship
                                                                                varName="">
                                                                                <DecisionTreeVar
                                                                                    name="T" />
                                                                                <Relationship
                                                                                    name="hasLeftOperand" />
                                                                            </GetByRelationship>
                                                                            <Property
                                                                                name="evaluatesTo" />
                                                                        </GetPropertyValue>
                                                                        <IfThen>
                                                                            <Compare
                                                                                operator="EQUAL">
                                                                                <GetPropertyValue>
                                                                                    <DecisionTreeVar
                                                                                        name="T" />
                                                                                    <Property
                                                                                        name="firstOperandPosition" />
                                                                                </GetPropertyValue>
                                                                                <Enum
                                                                                    owner="OperandPosition"
                                                                                    value="right" />
                                                                            </Compare>
                                                                            <GetPropertyValue>
                                                                                <GetByRelationship
                                                                                    varName="">
                                                                                    <DecisionTreeVar
                                                                                        name="T" />
                                                                                    <Relationship
                                                                                        name="hasRightOperand" />
                                                                                </GetByRelationship>
                                                                                <Property
                                                                                    name="evaluatesTo" />
                                                                            </GetPropertyValue>
                                                                            <GetPropertyValue>
                                                                                <GetByCondition
                                                                                    type="operand"
                                                                                    varName="c">
                                                                                    <CheckRelationship>
                                                                                        <Relationship
                                                                                            name="hasCenterOperand" />
                                                                                        <DecisionTreeVar
                                                                                            name="T" />
                                                                                        <Variable
                                                                                            name="c" />
                                                                                    </CheckRelationship>
                                                                                </GetByCondition>
                                                                                <Property
                                                                                    name="evaluatesTo" />
                                                                            </GetPropertyValue>
                                                                        </IfThen>
                                                                    </IfThen>
                                                                </Expression>
                                                                <Outcome value="true"
                                                                    _RU_text="true"
                                                                    _EN_text="'true'"
                                                                    _RU_explanation="Это неверно. Левый операнд в данном случае имеет значение true.
                                                             Помните, что мы предполагаем, что все переменные и не-логические операции вычисляются как true."
                                                                    _EN_explanation="That's incorrect. In this case the left operand evaluates as 'true'.
                                                             Remember that we assume that all variables and non-boolean operators evaluate as 'true'."
                                                                />
                                                                <Outcome value="false"
                                                                    _RU_text="false"
                                                                    _EN_text="'false'"
                                                                    _RU_explanation="Это неверно. Левый операнд в данном случае имеет значение false.
                                                            Помните, что мы предполагаем, что все переменные и не-логические операции вычисляются как true."
                                                                    _EN_explanation="That's incorrect. In this case the left operand evaluates as 'false'.
                                                            Remember that we assume that all variables and non-boolean operators evaluate as 'true'."
                                                                />
                                                            </Part>
                                                    <Outcome
                                                                value="(true;true)"
                                                                _RU_nextStepQuestion="Какой вывод можно сделать в таком случае?"
                                                                _RU_nextStepBranchResult="${val('X','и')} ${branchResult ? 'может быть вычислен' : 'опускается'}."
                                                                _RU_nextStepExplanation="Это неверно. С учетом сказанного выше, ${val('X','и')} не опускается, и может быть свободно вычислен."
                                                                _EN_nextStepQuestion="What can we conclude in this case?"
                                                                _EN_nextStepBranchResult="${val('X','и')} ${branchResult ? 'can be evaluated' : 'is omitted'}."
                                                                _EN_nextStepExplanation="This is incorrect. Given the above, ${val('X','и')} is not omitted, and can be evaluated."
                                                            >
                                                                <BranchResultNode value="true"
                                                                    _skill="should_strict_order_current_operand_be_omitted_while_solving"
                                                                    _RU_explanation="${val('X','и')} не должен быть опущен в ${val('T','п')}."
                                                                    _EN_explanation="${val('X','и')} should not be omitted in ${val('T','п')}."
                                                                />
                                                            </Outcome>
                                                    <Outcome
                                                                value="(false;false)"
                                                                _RU_nextStepQuestion="Какой вывод можно сделать в таком случае?"
                                                                _RU_nextStepBranchResult="${val('X','и')} ${branchResult ? 'может быть вычислен' : 'опускается'}."
                                                                _RU_nextStepExplanation="Это неверно. С учетом сказанного выше, ${val('X','и')} не опускается, и может быть свободно вычислен."
                                                                _EN_nextStepQuestion="What can we conclude in this case?"
                                                                _EN_nextStepBranchResult="${val('X','и')} ${branchResult ? 'can be evaluated' : 'is omitted'}."
                                                                _EN_nextStepExplanation="This is incorrect. Given the above, ${val('X','и')} is not omitted, and can be evaluated."
                                                            >
                                                                <BranchResultNode value="true"
                                                                    _skill="should_strict_order_current_operand_be_omitted_while_solving"
                                                                    _RU_explanation="${val('X','и')} не должен быть опущен в ${val('T','п')}."
                                                                    _EN_explanation="${val('X','и')} should not be omitted in ${val('T','п')}."
                                                                />
                                                            </Outcome>
                                                    <Outcome
                                                                value="(true;false)"
                                                                _RU_nextStepQuestion="Какой вывод можно сделать в таком случае?"
                                                                _RU_nextStepBranchResult="${val('X','и')} ${branchResult ? 'может быть вычислен' : 'опускается'}."
                                                                _RU_nextStepExplanation="Это неверно. С учетом сказанного выше, ${val('X','и')} опускается, а значит не может быть вычислен."
                                                                _EN_nextStepQuestion="What can we conclude in this case?"
                                                                _EN_nextStepBranchResult="${val('X','и')} ${branchResult ? 'can be evaluated' : 'is omitted'}."
                                                                _EN_nextStepExplanation="This is incorrect. Given the above, ${val('X','и')} is omitted, and so cannot be evaluated now."
                                                            >
                                                                <BranchResultNode
                                                                    _alias="X опускается"
                                                                    _skill="should_strict_order_current_operand_be_omitted_while_solving"
                                                                    _law="error_base_student_error_strict_operands_order"
                                                                    value="false"
                                                                    _error="strict.leftShouldBeTrue_omittedInRight"
                                                                    _RU_explanation="${val('X','и')} опускается оператором со строгим порядком операндов (${val('T','и')})"
                                                                    _EN_explanation="${val('X','и')} is omitted by an operator with a strict operand order (${val('T','и')})"
                                                                >
                                                                    <Expression>
                                                                        <AssignToProperty>
                                                                            <DecisionTreeVar
                                                                                name="X" />
                                                                            <Property name="state" />
                                                                            <Enum owner="state"
                                                                                value="omitted" />
                                                                        </AssignToProperty>
                                                                    </Expression>
                                                                </BranchResultNode>
                                                            </Outcome>
                                                            ` <Outcome
                                                                value="(false;true)"
                                                                _RU_nextStepQuestion="Какой вывод можно сделать в таком случае?"
                                                                _RU_nextStepBranchResult="${val('X','и')} ${branchResult ? 'может быть вычислен' : 'опускается'}."
                                                                _RU_nextStepExplanation="Это неверно. С учетом сказанного выше, ${val('X','и')} опускается, а значит не может быть вычислен."
                                                                _EN_nextStepQuestion="What can we conclude in this case?"
                                                                _EN_nextStepBranchResult="${val('X','и')} ${branchResult ? 'can be evaluated' : 'is omitted'}."
                                                                _EN_nextStepExplanation="This is incorrect. Given the above, ${val('X','и')} is omitted, and so cannot be evaluated now."
                                                            >
                                                                <BranchResultNode
                                                                    _alias="X опускается"
                                                                    value="false"
                                                                    _skill="should_strict_order_current_operand_be_omitted_while_solving"
                                                                    _law="error_base_student_error_strict_operands_order"
                                                                    _error="strict.leftShouldBeFalse_omittedInRight"
                                                                    _RU_explanation="${val('X','и')} опускается оператором со строгим порядком операндов (${val('T','и')})"
                                                                    _EN_explanation="${val('X','и')} is omitted by an operator with a strict operand order (${val('T','и')})"
                                                                >
                                                                    <Expression>
                                                                        <AssignToProperty>
                                                                            <DecisionTreeVar
                                                                                name="X" />
                                                                            <Property name="state" />
                                                                            <Enum owner="state"
                                                                                value="omitted" />
                                                                        </AssignToProperty>
                                                                    </Expression>
                                                                </BranchResultNode>
                                                            </Outcome>
                                                        </TupleQuestionNode>
                                                    </Outcome>
                                                </QuestionNode>
                                            </Outcome>
                                        </QuestionNode>
                                    </Outcome>
                                </QuestionNode>
                            </Outcome>
                        </QuestionNode>
                    </ThoughtBranch>
                </CycleAggregationNode>
            </ThoughtBranch>
            <Outcome value="true">
                <BranchResultNode value="true"> <!-- X вычисляется, A, B, C становятся
                    использованными-->
                    <Expression>
                        <Block>
                            <AssignToProperty>
                                <DecisionTreeVar name="X" />
                                <Property name="state" />
                                <Enum owner="state" value="evaluated" />
                            </AssignToProperty>
                            <IfThen>
                                <ExistenceQuantifier varName="a" type="operand">
                                    <Compare operator="NOT_EQUAL">
                                        <GetPropertyValue>
                                            <Variable name="a" />
                                            <Property name="state" />
                                        </GetPropertyValue>
                                        <Enum owner="state" value="omitted" />
                                    </Compare>
                                    <CheckRelationship>
                                        <Relationship name="hasLeftOperand" />
                                        <DecisionTreeVar name="X" />
                                        <Variable name="a" />
                                    </CheckRelationship>
                                </ExistenceQuantifier>
                                <AssignToProperty>
                                    <GetByRelationship varName="a">
                                        <DecisionTreeVar name="X" />
                                        <Relationship name="hasLeftOperand" />
                                    </GetByRelationship>
                                    <Property name="state" />
                                    <Enum owner="state" value="used" />
                                </AssignToProperty>
                            </IfThen>
                            <IfThen>
                                <ExistenceQuantifier varName="b" type="operand">
                                    <Compare operator="NOT_EQUAL">
                                        <GetPropertyValue>
                                            <Variable name="b" />
                                            <Property name="state" />
                                        </GetPropertyValue>
                                        <Enum owner="state" value="omitted" />
                                    </Compare>
                                    <CheckRelationship>
                                        <Relationship name="hasRightOperand" />
                                        <DecisionTreeVar name="X" />
                                        <Variable name="b" />
                                    </CheckRelationship>
                                </ExistenceQuantifier>
                                <AssignToProperty>
                                    <GetByRelationship varName="b">
                                        <DecisionTreeVar name="X" />
                                        <Relationship name="hasRightOperand" />
                                    </GetByRelationship>
                                    <Property name="state" />
                                    <Enum owner="state" value="used" />
                                </AssignToProperty>
                            </IfThen>
                            <ForAllQuantifier varName="c" type="operand">
                                <LogicalAnd>
                                    <CheckRelationship>
                                        <Relationship name="hasCenterOperand" />
                                        <DecisionTreeVar name="X" />
                                        <Variable name="c" />
                                    </CheckRelationship>
                                    <Compare operator="NOT_EQUAL">
                                        <GetPropertyValue>
                                            <Variable name="c" />
                                            <Property name="state" />
                                        </GetPropertyValue>
                                        <Enum owner="state" value="omitted" />
                                    </Compare>
                                </LogicalAnd>
                                <AssignToProperty>
                                    <Variable name="c" />
                                    <Property name="state" />
                                    <Enum owner="state" value="used" />
                                </AssignToProperty>
                            </ForAllQuantifier>
                        </Block>
                    </Expression>
                    <!-- <Expression>
                        <Block>
                            <IfThen>
                                <GetPropertyValue>
                                    <DecisionTreeVar name="X" />
                                    <Property name="needsInnerOperand" />
                                </GetPropertyValue>
                                <With varName="c">
                                    <GetByCondition varName="c">
                                        <LogicalAnd>
                                            <LogicalAnd>
                                                <CheckClass>
                                                    <Variable name="c" />
                                                    <Class name="operand" />
                                                </CheckClass>
                                                <CheckRelationship>
                                                    <Relationship name="isBetween" />
                                                    <Variable name="c" />
                                                    <DecisionTreeVar name="X1" />
                                                    <GetByCondition varName="x2">
                                                        <LogicalAnd>
                                                            <LogicalAnd>
                                                                <CheckClass>
                                                                    <Variable name="x2" />
                                                                    <Class name="token" />
                                                                </CheckClass>
                                                                <CheckRelationship>
                                                                    <Relationship name="belongsTo" />
                                                                    <Variable name="x2" />
                                                                    <DecisionTreeVar name="X" />
                                                                </CheckRelationship>
                                                            </LogicalAnd>
                                                            <CheckRelationship>
                                                                <Relationship name="rightOf" />
                                                                <Variable name="x2" />
                                                                <DecisionTreeVar name="X1" />
                                                            </CheckRelationship>
                                                        </LogicalAnd>
                                                    </GetByCondition>
                                                </CheckRelationship>
                                            </LogicalAnd>
                                            <Compare operator="EQUAL">
                                                <GetPropertyValue>
                                                    <Variable name="c" />
                                                    <Property name="state" />
                                                </GetPropertyValue>
                                                <Enum owner="state" value="evaluated" />
                                            </Compare>
                                        </LogicalAnd>
                                    </GetByCondition>
                                    <Block>
                                        <AddRelationshipLink>
                                            <Relationship name="isOperandOf" />
                                            <Variable name="c" />
                                            <DecisionTreeVar name="X" />
                                        </AddRelationshipLink>
                                        <AddRelationshipLink>
                                            <Relationship name="isCenterOperandOf" />
                                            <Variable name="c" />
                                            <DecisionTreeVar name="X" />
                                        </AddRelationshipLink>
                                        <AssignToProperty>
                                            <Variable name="c" />
                                            <Property name="state" />
                                            <Enum owner="state" value="used"/>
                                        </AssignToProperty>
                                    </Block>
                                </With>
                            </IfThen>
                            <IfThen>
                                <GetPropertyValue>
                                    <DecisionTreeVar name="X" />
                                    <Property name="needsLeftOperand" />
                                </GetPropertyValue>
                                <With varName="a">
                                    <GetExtreme varName="a" extremeVarName="a_ex">
                                        <LogicalNot>
                                            <ExistenceQuantifier varName="a">
                                                <LogicalAnd>
                                                    <LogicalAnd>
                                                        <CheckClass>
                                                            <Variable name="a" />
                                                            <Class name="operand" />
                                                        </CheckClass>
                                                        <Compare operator="EQUAL">
                                                            <GetPropertyValue>
                                                                <Variable name="a" />
                                                                <Property name="state" />
                                                            </GetPropertyValue>
                                                            <Enum owner="state" value="evaluated" />
                                                        </Compare>
                                                    </LogicalAnd>
                                                    <CheckRelationship>
                                                        <Relationship name="leftOf" />
                                                        <Variable name="a" />
                                                        <DecisionTreeVar name="X" />
                                                    </CheckRelationship>
                                                </LogicalAnd>
                                                <CheckRelationship>
                                                    <Relationship name="isBetween" />
                                                    <Variable name="a" />
                                                    <Variable name="a_ex" />
                                                    <DecisionTreeVar name="X" />
                                                </CheckRelationship>
                                            </ExistenceQuantifier>
                                        </LogicalNot>
                                        <LogicalAnd>
                                            <LogicalAnd>
                                                <CheckClass>
                                                    <Variable name="a" />
                                                    <Class name="operand" />
                                                </CheckClass>
                                                <Compare operator="EQUAL">
                                                    <GetPropertyValue>
                                                        <Variable name="a" />
                                                        <Property name="state" />
                                                    </GetPropertyValue>
                                                    <Enum owner="state" value="evaluated" />
                                                </Compare>
                                            </LogicalAnd>
                                            <CheckRelationship>
                                                <Relationship name="leftOf" />
                                                <Variable name="a" />
                                                <DecisionTreeVar name="X" />
                                            </CheckRelationship>
                                        </LogicalAnd>
                                    </GetExtreme>
                                    <Block>
                                        <AddRelationshipLink>
                                            <Relationship name="isOperandOf" />
                                            <Variable name="a" />
                                            <DecisionTreeVar name="X" />
                                        </AddRelationshipLink>
                                        <AddRelationshipLink>
                                            <Relationship name="isLeftOperandOf" />
                                            <Variable name="a" />
                                            <DecisionTreeVar name="X" />
                                        </AddRelationshipLink>
                                        <AssignToProperty>
                                            <Variable name="a" />
                                            <Property name="state" />
                                            <Enum owner="state" value="used"/>
                                        </AssignToProperty>
                                    </Block>
                                </With>
                            </IfThen>
                            <IfThen>
                                <GetPropertyValue>
                                    <DecisionTreeVar name="X" />
                                    <Property name="needsRightOperand" />
                                </GetPropertyValue>
                                <With varName = "b">
                                    <GetExtreme varName="b" extremeVarName="b_ex">
                                        <LogicalNot>
                                            <ExistenceQuantifier varName="b">
                                                <LogicalAnd>
                                                    <LogicalAnd>
                                                        <CheckClass>
                                                            <Variable name="b" />
                                                            <Class name="operand" />
                                                        </CheckClass>
                                                        <Compare operator="EQUAL">
                                                            <GetPropertyValue>
                                                                <Variable name="b" />
                                                                <Property name="state" />
                                                            </GetPropertyValue>
                                                            <Enum owner="state" value="evaluated" />
                                                        </Compare>
                                                    </LogicalAnd>
                                                    <CheckRelationship>
                                                        <Relationship name="rightOf" />
                                                        <Variable name="b" />
                                                        <DecisionTreeVar name="X" />
                                                    </CheckRelationship>
                                                </LogicalAnd>
                                                <CheckRelationship>
                                                    <Relationship name="isBetween" />
                                                    <Variable name="b" />
                                                    <Variable name="b_ex" />
                                                    <DecisionTreeVar name="X" />
                                                </CheckRelationship>
                                            </ExistenceQuantifier>
                                        </LogicalNot>
                                        <LogicalAnd>
                                            <LogicalAnd>
                                                <CheckClass>
                                                    <Variable name="b" />
                                                    <Class name="operand" />
                                                </CheckClass>
                                                <Compare operator="EQUAL">
                                                    <GetPropertyValue>
                                                        <Variable name="b" />
                                                        <Property name="state" />
                                                    </GetPropertyValue>
                                                    <Enum owner="state" value="evaluated" />
                                                </Compare>
                                            </LogicalAnd>
                                            <CheckRelationship>
                                                <Relationship name="rightOf" />
                                                <Variable name="b" />
                                                <DecisionTreeVar name="X" />
                                            </CheckRelationship>
                                        </LogicalAnd>
                                    </GetExtreme>
                                    <Block>
                                        <AddRelationshipLink>
                                            <Relationship name="isOperandOf" />
                                            <Variable name="b" />
                                            <DecisionTreeVar name="X" />
                                        </AddRelationshipLink>
                                        <AddRelationshipLink>
                                            <Relationship name="isRightOperandOf" />
                                            <Variable name="b" />
                                            <DecisionTreeVar name="X" />
                                        </AddRelationshipLink>
                                        <AssignToProperty>
                                            <Variable name="b" />
                                            <Property name="state" />
                                            <Enum owner="state" value="used"/>
                                        </AssignToProperty>
                                    </Block>
                                </With>
                            </IfThen>
                            <AssignToProperty>
                                <DecisionTreeVar name="X" />
                                <Property name="state" />
                                <Enum owner="state" value="evaluated"/>
                            </AssignToProperty>
                        </Block>
                    </Expression> -->
                </BranchResultNode>
            </Outcome>
            <Outcome value="false">
                <BranchResultNode value="false" />
            </Outcome>
        </LogicAggregationNode>
    </ThoughtBranch>
</StartNode>