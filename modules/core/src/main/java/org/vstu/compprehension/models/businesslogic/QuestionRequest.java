package org.vstu.compprehension.models.businesslogic;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.NoArgsConstructor;
import org.vstu.compprehension.models.entities.EnumData.SearchDirections;
import org.vstu.compprehension.models.entities.ExerciseAttemptEntity;
import lombok.Data;
import org.vstu.compprehension.models.entities.QuestionRequestLogEntity;

import java.util.List;
import java.util.stream.Collectors;

@Builder
@NoArgsConstructor
@AllArgsConstructor
@Data
public class QuestionRequest {
    
    private List<Concept> deniedConcepts;

    private List<Concept> targetConcepts;
    private List<Concept> targetConceptsInPlan;

    /** Question Storage can treat this as "optional targets" or "preferred" */
    private List<Concept> allowedConcepts;

    private List<Law> targetLaws;
    private List<Law> targetLawsInPlan;

    private List<Law> deniedLaws;

    private List<Law> allowedLaws;

    long conceptsTargetedBitmask;  // set to 0 if traceConceptsTargetedBitmask set
    long conceptsTargetedInPlanBitmask;
    @Builder.Default
    long traceConceptsTargetedBitmask = 0;  // set if required for search
    long conceptsDeniedBitmask;
    long lawsTargetedInPlanBitmask;
    long lawsTargetedBitmask;
    long lawsDeniedBitmask;

    private List<String> deniedQuestionNames;

    // see also: QuestionEntity.options.metadata
    @Builder.Default
    private List<Integer> deniedQuestionTemplateIds = List.of(0);
    @Builder.Default
    private List<Integer> deniedQuestionMetaIds = List.of(0);  // same as deniedQuestionNames but using ids instead of names

    /**
     * Условная единица, показывающая долго или быстро решается вопрос
     * 1 - быстро, 10 - очень долго
     */
    private int solvingDuration;


    /**
     * Сложность задания [0..1]
     */
    private float complexity;

    /** минимум шагов в решении */
    private int stepsMin;
    /** максимум шагов в решении */
    private int stepsMax;

    /**
     * Направление поиска по сложности
     */
    private SearchDirections complexitySearchDirection;

    /**
     * Направление поиска по сложности
     */
    private SearchDirections lawsSearchDirection;

    /**
     * Probability of choosing an auto-generated question
     * Вероятность выбора авто-сгенерированного вопроса
     * range: [0..1]
     * 0: always pick manual question
     * 1: always pick auto-generated question
     */
    @Builder.Default
    private double chanceToPickAutogeneratedQuestion = 1;

    String domainShortname;

    public boolean getIsDraft() {
        return isDraft;
    }

    public void setIsDraft(boolean draft) {
        isDraft = draft;
    }

    @Builder.Default
    private boolean isDraft = false;

    ExerciseAttemptEntity exerciseAttempt;


    public QuestionRequestLogEntity getLogEntity() {
        return QuestionRequestLogEntity.builder()
                // .id(0L)
                .exerciseAttemptId(exerciseAttempt.getId())
                .domainShortname(domainShortname)
                .targetConceptNames(targetConcepts.stream().map(Concept::getName).collect(Collectors.toList()))
                .targetConceptNamesInPlan(targetConceptsInPlan.stream().map(Concept::getName).collect(Collectors.toList()))
                .deniedConceptNames(deniedConcepts.stream().map(Concept::getName).collect(Collectors.toList()))
                .allowedConceptNames(allowedConcepts.stream().map(Concept::getName).collect(Collectors.toList()))
                .targetLawNames(targetLaws.stream().map(Law::getName).collect(Collectors.toList()))
                .targetLawNamesInPlan(targetLawsInPlan.stream().map(Law::getName).collect(Collectors.toList()))
                .deniedLawNames(deniedLaws.stream().map(Law::getName).collect(Collectors.toList()))
                .allowedLawNames(allowedLaws.stream().map(Law::getName).collect(Collectors.toList()))
                .conceptsTargetedBitmask(conceptsTargetedBitmask)
                .traceConceptsTargetedBitmask(traceConceptsTargetedBitmask)
                .conceptsDeniedBitmask(conceptsDeniedBitmask)
                .lawsTargetedBitmask(lawsTargetedBitmask)
                .lawsDeniedBitmask(lawsDeniedBitmask)
                .deniedQuestionNames(deniedQuestionNames)
                .deniedQuestionTemplateIds(deniedQuestionTemplateIds.isEmpty()? List.of(0) : deniedQuestionTemplateIds)
                .deniedQuestionMetaIds(deniedQuestionMetaIds.isEmpty()? List.of(0) : deniedQuestionMetaIds)
                .solvingDuration(solvingDuration)
                .complexity(complexity)
                .stepsMin(stepsMin)
                .stepsMax(stepsMax)
                .complexitySearchDirection(complexitySearchDirection)
                .lawsSearchDirection(lawsSearchDirection)
                .chanceToPickAutogeneratedQuestion(chanceToPickAutogeneratedQuestion)
                .foundCount(-1)
                .createdDate(null)
        .build();
    }

    public static QuestionRequest fromLogEntity(QuestionRequestLogEntity other) {
        return QuestionRequest.builder()
                // .id(0L)
                // .exerciseAttempt(getAttempt(other.getExerciseAttemptId()))
                .domainShortname(other.getDomainShortname())
                // .targetConcepts(other.getTargetConceptNames().stream().map(Domain::getConcept).collect(Collectors.toList()))
                // .targetConceptNamesInPlan(other.targetConceptsInPlan.stream().map(Domain::getConcept).collect(Collectors.toList()))
                // .deniedConceptNames(other.getDeniedConceptNames().stream().map(Domain::getConcept.collect(Collectors.toList()))
                // .allowedConcepts(other.getAllowedConceptNames().stream().map(Domain::getConcept).collect(Collectors.toList()))
                // .targetLaws(other.getTargetLawNames().stream().map(Domain::getLaw).collect(Collectors.toList()))
                // .targetLawNamesInPlan(other.targetLawsInPlan.stream().map(Domain::getLaw).collect(Collectors.toList()))
                // .deniedLawNames(other.deniedLaws.stream().map(Domain::getLaw).collect(Collectors.toList()))
                // .allowedLawNames(other.allowedLaws.stream().map(Domain::getLaw).collect(Collectors.toList()))
                .conceptsTargetedBitmask(other.getConceptsTargetedBitmask())
                .traceConceptsTargetedBitmask(other.getTraceConceptsTargetedBitmask())
                .conceptsDeniedBitmask(other.getConceptsDeniedBitmask())
                .lawsTargetedBitmask(other.getLawsTargetedBitmask())
                .lawsDeniedBitmask(other.getLawsDeniedBitmask())
                .deniedQuestionNames(other.getDeniedQuestionNames())
                .deniedQuestionTemplateIds(other.getDeniedQuestionTemplateIds().isEmpty()? List.of(0) : other.getDeniedQuestionTemplateIds())
                .deniedQuestionMetaIds(other.getDeniedQuestionMetaIds().isEmpty()? List.of(0) : other.getDeniedQuestionMetaIds())
                .solvingDuration(other.getSolvingDuration())
                .complexity(other.getComplexity())
                .stepsMin(other.getStepsMin())
                .stepsMax(other.getStepsMax())
                .complexitySearchDirection(other.getComplexitySearchDirection())
                .lawsSearchDirection(other.getLawsSearchDirection())
                .chanceToPickAutogeneratedQuestion(other.getChanceToPickAutogeneratedQuestion())
        .build();
    }
}

