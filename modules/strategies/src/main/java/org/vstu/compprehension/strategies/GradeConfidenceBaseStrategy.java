package org.vstu.compprehension.strategies;

import lombok.Getter;
import lombok.extern.log4j.Log4j2;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.springframework.data.util.Pair;
import org.vstu.compprehension.dto.ExerciseLawDto;
import org.vstu.compprehension.models.businesslogic.Law;
import org.vstu.compprehension.models.businesslogic.NegativeLaw;
import org.vstu.compprehension.models.businesslogic.QuestionRequest;
import org.vstu.compprehension.models.businesslogic.domains.Domain;
import org.vstu.compprehension.models.businesslogic.domains.DomainFactory;
import org.vstu.compprehension.models.businesslogic.strategies.AbstractStrategy;
import org.vstu.compprehension.models.businesslogic.strategies.StrategyOptions;
import org.vstu.compprehension.models.entities.*;
import org.vstu.compprehension.models.entities.EnumData.*;
import org.vstu.compprehension.models.entities.exercise.ExerciseEntity;
import org.vstu.compprehension.models.entities.exercise.ExerciseStageEntity;

import java.util.*;

@Log4j2
public class GradeConfidenceBaseStrategy implements AbstractStrategy {

    private final DomainFactory domainFactory;
    protected StrategyOptions options;

    protected static int WINDOW_TO_GRADE = 3 /*7*/;
    protected static float TARGET_GRADE = 0.6f /*(float)0.8*/;
    protected static float CONFIDENCE_MULTIPLIER = 1.0f /*(float)1.2*/;
    protected static int DEFAULT_LAW_COUNT = 2 /*5*/;

    public GradeConfidenceBaseStrategy(DomainFactory domainFactory) {
        this.domainFactory = domainFactory;
        this.options = StrategyOptions.builder()
                .multiStagesEnabled(false)
                .visibleToUser(true)
                .build();
    }

    @NotNull
    @Override
    public String getStrategyId() {
        return "GradeConfidenceBaseStrategy";
    }

    @NotNull
    @Override
    public String getDisplayName(Language language) {
        if (language == Language.RUSSIAN) {
            return "Адаптивная стратегия";
        }
        return "Adaptive strategy";
    }

    @Nullable
    @Override
    public String getDescription(Language language) {
        if (language == Language.RUSSIAN) {
            return "Адаптивная стратегия адаптирует сложность вопросов под уровень знаний студента";
        }
        return "Adaptive strategy adapts the difficulty of questions to the student's level of knowledge";
    }

    @NotNull
    @Override
    public StrategyOptions getOptions() {
        return options;
    }

    @Override
    public QuestionRequest generateQuestionRequest(ExerciseAttemptEntity exerciseAttempt) {

        ExerciseEntity exercise = exerciseAttempt.getExercise();
        Domain domain = domainFactory.getDomain(exercise.getDomain().getName());


        ExerciseStageEntity exerciseStage = exercise.getStages().get(0);
        QuestionRequest qr = initQuestionRequest(exerciseAttempt, exerciseStage, domain);

//        qr.setAllowedConcepts(List.of());
//        qr.setAllowedLaws(List.of());

        HashMap<String, List<Boolean>> allLaws = getTargetLawsInteractions(exerciseAttempt, 0);
        HashMap<String, List<Boolean>> allLawsBeforeLastQuestion = getTargetLawsInteractions(exerciseAttempt, 1);

        HashMap<String, List<Boolean>> difference = countDifference(allLaws, allLawsBeforeLastQuestion);

        boolean isFirstQuestion = exerciseAttempt.getQuestions().size() == 0;


        qr.setComplexity(grade(exerciseAttempt));//TODO
        //qr.setComplexity(1);//TODO
        qr.setSolvingDuration(5);
        qr.setExerciseAttempt(exerciseAttempt);
        qr.setChanceToPickAutogeneratedQuestion(1.0);

        SearchDirections lawsDirections = isFirstQuestion ? SearchDirections.TO_SIMPLE: countLawsSearchDirections(difference);
        qr.setLawsSearchDirection(lawsDirections);
        qr.setAllowedConcepts(new ArrayList<>());

        //Вычислить количество законов в следующем вопросе

        //Вычислить тип студента: начинающий = -1, средний = 0, знаток = +1
        //        Для начинающего требуется высокая скорость уменьшения количества законов, низкая сложность
        //        Для среднего пытаться увеличить количество шагов на вопрос, небольшой или никакой рост количества законов
        //        Для знатока взрывной рост количества законов в вопросе
        int studentType = classifyStudent(exerciseAttempt);

        //оценка прохождения прошлого вопроса -1, 0, 1
        //Мера того, как справляется студент на текущем уровне сложности (-1 - сложность слишком велика, 0 - граничная сложность, 1 - слишком легко)
        int studentsComplexity = isFirstQuestion ? 0: countComplexityByDifference(difference);

        ArrayList<QuestionEntity> questions = new ArrayList<>(exerciseAttempt.getQuestions());
        questions.sort(QuestionOrderComparator.getInstance());

        int lastLawCount = 0;
        int summarizedABSLawDeltaCount = 0;
        int summarizedLawDeltaCount = 0;
        int lastLawDeltaCount = 0;
        for (QuestionEntity qe : questions) {
            int currentLawCount = countQuestionLaws(qe).size();
            lastLawDeltaCount = currentLawCount - lastLawCount;
            summarizedABSLawDeltaCount += Math.abs(lastLawDeltaCount);
            summarizedLawDeltaCount += lastLawDeltaCount;

            lastLawCount = currentLawCount;
        }


        int countOfLaw = nextLawCount(studentType, studentsComplexity, lastLawCount,
                                        summarizedLawDeltaCount, lastLawDeltaCount, questions.size());
        if (studentsComplexity == -1) {
            //Директивное упрощение
            ArrayList<InteractionEntity> inters = new ArrayList<>();
            inters.addAll(questions.get(questions.size()-1).getInteractions());
            HashMap<String, List<Boolean>> allLawsError = new HashMap<>();

            for (InteractionEntity inter: inters) {
                for (ViolationEntity vio: inter.getViolations()) {
                    allLawsError.put(
                            vio.getLawName(),
                            Optional.ofNullable(allLaws.get(vio.getLawName())).orElse(new ArrayList<>()));
                }
            }

            allLaws = allLawsError;
        }

        // Remove explicitly denied laws from the set of considered laws.
        for (var law : qr.getDeniedLaws()) {
            allLaws.remove(law.getName()); // remove if exists
        }

        qr.setTargetLaws(countNextTargetLaws(allLaws, domain, countOfLaw));

        loggingParams(studentType, studentsComplexity, lawsDirections);
        loggingRequest(qr);

        return adjustQuestionRequest(qr, exerciseAttempt);
    }

    @Override
    public DisplayingFeedbackType determineDisplayingFeedbackType(QuestionEntity question) {
        return null;
    }

    @Override
    public FeedbackType determineFeedbackType(QuestionEntity question) {
        return null;
    }

    @Override
    public float grade(ExerciseAttemptEntity exerciseAttempt) {

        HashMap<String, List<Boolean>> allLaws = getTargetLawsInteractions(exerciseAttempt, 0);

        List<String> targetLaws = new ArrayList<>(basicLawsUsage(exerciseAttempt));

        float resultGrade = 0;

        for (String currentLaw : targetLaws) {
            //laws.addAll(allLaws.get(currentLaw.getLawName()));
            List<Boolean> laws = new ArrayList<>(allLaws.get(currentLaw));
            Collections.reverse(laws);

            resultGrade += countGradeByUsage(laws, CONFIDENCE_MULTIPLIER * countConfidence(laws));
        }

//        if(targetLaws.size() == 0){
//            return 0;
//        }
        resultGrade = resultGrade / targetLaws.size();

        return resultGrade;
    }

    @Override
    public Decision decide(ExerciseAttemptEntity exerciseAttempt) {

        if(grade(exerciseAttempt) >= countTargetGrade() && isAllLawsUsedWindowCount(exerciseAttempt)){
            return Decision.FINISH;
        }
        return Decision.CONTINUE;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    private void loggingRequest(QuestionRequest result) {

        log.info("Законы из домена в запросе:");
        ArrayList<Law> printOutLaws = new ArrayList<>(result.getTargetLaws());
        printOutLaws.sort(Comparator.comparing(Law::getName));
        for(Law str : printOutLaws){
            log.info("\t{}", str.getName());
        }
    }

    private void loggingParams(int studentType, int studentsComplexity, SearchDirections lawsDirections) {

        log.info("Параметры при расчёте стратегии:");
        log.info("\tТип студента: {}", (studentType == -1 ? "начинающий" : studentType == 0 ? "средний" : "знаток"));
        log.info("\tСложность прошлого вопроса: {}", (studentsComplexity == -1 ? "слишком сложно" : studentType == 0 ? "норма" : "слишком легко"));
        log.info("\tРекомендованное направление поиска для домена: {}", (lawsDirections == SearchDirections.TO_SIMPLE ? "упрощение" : "усложнение"));

    }

    private int nextLawCount(int studentType, int studentsComplexity, int lastLawCount,
                             int summarizedLawDeltaCount, int lastLawDeltaCount,
                             int questionsCount) {

        if(questionsCount == 0){
            return getDefaultLawCount();
        }

        int lawCount = lastLawCount <= 0 ? 1 : lastLawCount;
        if(studentsComplexity == 0){

            if(studentType == 1){
                lawCount = lawCount + Math.abs(lastLawDeltaCount/2) + 1;
            }else if(studentType == 0){
                lawCount = lawCount + 1;
            }else if(studentType == -1){
                lawCount = lawCount - 1;
            }

        }

        if(studentsComplexity == -1){

            if(studentType == 1){
                lawCount = lawCount - Math.abs(lastLawDeltaCount/2) + 1;
            }else if(studentType == 0){
                lawCount = lawCount - Math.abs(lastLawDeltaCount/2);
            }else if(studentType == -1){
                lawCount = lawCount - Math.abs(lastLawDeltaCount);
            }

        }

        if(studentsComplexity == 1){

            if(studentType == 1){
                lawCount = lawCount + Math.abs(lastLawDeltaCount + summarizedLawDeltaCount/questionsCount) + 1;
            }else if(studentType == 0){
                lawCount = lawCount + Math.abs(lastLawDeltaCount + 1);
            }else if(studentType == -1){
                lawCount = lawCount + Math.abs(lastLawDeltaCount + 1);
            }

        }
        return lawCount <= 0 ? 1 : lawCount;
    }

    private int getDefaultLawCount() {
        return DEFAULT_LAW_COUNT;
    }


    private int classifyStudent(ExerciseAttemptEntity exerciseAttempt){
        int result = 0;

        HashMap<String, List<Boolean>> targetLawsInteractions = getTargetLawsInteractions(exerciseAttempt, 0);
        int errorCount = 0;
        int correctCount = 0;

        for(Map.Entry<String, List<Boolean>> entry : targetLawsInteractions.entrySet()) {
            String key = entry.getKey();
            List<Boolean> valueFirst = entry.getValue();

            for(Boolean currentVal : valueFirst){
                if(currentVal == Boolean.TRUE){
                    correctCount++;
                } else{
                    errorCount++;
                }
            }
        }


        //В зависимости от частости ошибок студента выбирается его тип (условный начинающий, средний, знаток)
        if((correctCount + errorCount) == 0){
            result = 0;
        } else {

            if ((float)correctCount / (correctCount + errorCount) <= 0.6) {
                result = -1;
            } else if ((float)correctCount / (correctCount + errorCount) <= 0.9) {
                result = 0;
            } else {
                result = 1;
            }
        }

        return result;
    }

    private List<String> countQuestionLaws(QuestionEntity questionEntity){

        List<String> result = new ArrayList<>();
        ArrayList<InteractionEntity> interactions = new ArrayList<>();
        interactions.addAll(questionEntity.getInteractions());
        for(int i = 0; i < interactions.size(); i++){

            ArrayList<CorrectLawEntity> correctLaws = new ArrayList<>();
            correctLaws.addAll(interactions.get(i).getCorrectLaw());
            for(int j = 0; j < correctLaws.size(); j++){
                if(!result.contains(correctLaws.get(j).getLawName())){
                    result.add(correctLaws.get(j).getLawName());
                }
            }
        }

        return result;

    }

    private List<Law> countNextTargetLaws(HashMap<String, List<Boolean>> allLaws, Domain domain, int countOfLaws) {
        // proxy to overloaded method
        return countNextTargetLaws(allLaws, new ArrayList<>(domain.getNegativeLaws()), countOfLaws);
    }

    private List<Law> countNextTargetLaws(HashMap<String, List<Boolean>> allLaws, List<Law> targetLaws, int countOfLaws) {
        ArrayList<Law> result = new ArrayList<>();

        float meanOfUsage = 0;

        //Подсчитать оценку каждого закона
        ArrayList<Pair<String, Float>> allLawsGrade = new ArrayList<>();
        for(Map.Entry<String, List<Boolean>> entry : allLaws.entrySet()) {

            String key = entry.getKey();
            List<Boolean> valueFirst = entry.getValue();

            List<Boolean> laws = new ArrayList<>();

            if (valueFirst != null) {
                meanOfUsage += valueFirst.size();
                laws.addAll(valueFirst);
            }

            allLawsGrade.add(0, Pair.of(key, countGradeByUsage(laws, CONFIDENCE_MULTIPLIER * countConfidence(laws))));
        }

        meanOfUsage = meanOfUsage / allLaws.keySet().size();

        allLawsGrade.sort(LawGradeComparator.getInstance());
        //////Проверить в каком порядке сортируется

        //Выбрать минимально изученные законы в количестве countOfLaws
        ArrayList<String> targetLawsName = new ArrayList<>();
        for (int i = 0; i < allLawsGrade.size() && i < countOfLaws; i++){
            targetLawsName.add(allLawsGrade.get(i).getFirst());
        }

        for(String lName : targetLawsName){
            Law lawToAdd = targetLaws.stream()
                    .filter(law -> lName.equals(law.getName()))
                    .findFirst()
                    .orElse(null);

            if(lawToAdd != null && (meanOfUsage == 0 || allLaws.get(lName).size() < (meanOfUsage / 2))) {
                result.add(lawToAdd);
            }
        }

        if(result.size() == 0){
            for(String lName : targetLawsName){
                targetLaws.stream()
                        .filter(law -> lName.equals(law.getName()))
                        .findFirst().ifPresent(result::add);
            }
        }


        return result;
    }

    private boolean isAllLawsUsedWindowCount(ExerciseAttemptEntity exerciseAttempt) {

        HashMap<String, List<Boolean>> allLawsUsage = getTargetLawsInteractions(exerciseAttempt, 0);


        List<String> targetLaws = new ArrayList<>(basicLawsUsage(exerciseAttempt));

        Integer minimumLawUsageCount = null;
        for (String currentTargetLaw : targetLaws) {
            if(minimumLawUsageCount == null){
                //minimumLawUsageCount = allLawsUsage.get(currentTargetLaw.getLawName()).size();
                minimumLawUsageCount = allLawsUsage.get(currentTargetLaw).size();
            }else{
                //minimumLawUsageCount = Math.min(minimumLawUsageCount, allLawsUsage.get(currentTargetLaw.getLawName()).size());
                minimumLawUsageCount = Math.min(minimumLawUsageCount, allLawsUsage.get(currentTargetLaw).size());
            }
        }

        return minimumLawUsageCount == null || minimumLawUsageCount >= countGradeWindow();
    }

    protected HashMap<String, List<Boolean>> getTargetLawsInteractions(ExerciseAttemptEntity exerciseAttempt, int removeLastCount){

        var allLawsUsage = basicLawsUsage(exerciseAttempt);

        List<QuestionEntity> allQuestions = new ArrayList<>(exerciseAttempt.getQuestions());
        allQuestions.sort(QuestionOrderComparator.getInstance());
        if (removeLastCount > 0 && allQuestions.size() >= removeLastCount) {
            allQuestions = allQuestions.subList(0, allQuestions.size() - removeLastCount);
        }

        return getQuestionsLawConceptUsage(allQuestions, allLawsUsage);
    }

    private HashSet<String> basicLawsUsage(ExerciseAttemptEntity exerciseAttempt) {
        HashSet<String> allLawsUsage = new HashSet<>();

        var exercise = exerciseAttempt.getExercise();
        var exerciseStages = exercise.getStages();
        if (exerciseStages.isEmpty())
            throw new RuntimeException("Invalid exercise stages");
        var stage = exerciseStages.getFirst();  // используем первый (скорее всего, единственный) этап упражнения

        if (!stage.getLaws().isEmpty()) {
            // получить целевые (target) законы из упражнения
            for (ExerciseLawDto currentLaw : stage.getLaws()) {
                if (currentLaw.getKind() == RoleInExercise.TARGETED)
                    allLawsUsage.add(currentLaw.getName());
            }
        }
        if (allLawsUsage.isEmpty()) {
            // получить законы из домена (все подряд)
            Domain domain = domainFactory.getDomain(exercise.getDomain().getName());

            Collection<NegativeLaw> targetLaws = domain.getNegativeLaws();
            for (NegativeLaw currentTargetLaw : targetLaws) {
                allLawsUsage.add(currentTargetLaw.getName());
            }
        }

        return allLawsUsage;
    }

    private HashMap<String, List<Boolean>> getQuestionsLawConceptUsage(List<QuestionEntity> allQuestions, Set<String> allLawsUsage) {
        var result = new HashMap<String, List<Boolean>>(allLawsUsage.size());
        for (var law : allLawsUsage) {
            result.put(law, new ArrayList<>());
        }

        for (var currentQuestion : allQuestions) {
            var allInteractions = currentQuestion.getInteractions();
            allInteractions.sort(InteractionOrderComparator.getInstance());

            for (var currentInteraction : allInteractions) {

                var allViolations = currentInteraction.getViolations();
                for (var currentViolation : allViolations) {
                    if(result.containsKey(currentViolation.getLawName())){
                        result.get(currentViolation.getLawName()).add(Boolean.FALSE);
                    }
                }

                var allLaws = currentInteraction.getCorrectLaw();
                for (var currentLaw : allLaws) {
                    if(result.containsKey(currentLaw.getLawName())){
                        result.get(currentLaw.getLawName()).add(Boolean.TRUE);
                    }
                }
            }
        }

        return result;
    }

    private HashMap<String, List<Boolean>> countDifference(HashMap<String, List<Boolean>> first, HashMap<String, List<Boolean>>second){
        HashMap<String, List<Boolean>> result = new HashMap<>();

        for(Map.Entry<String, List<Boolean>> entry : first.entrySet()) {
            String key = entry.getKey();
            List<Boolean> valueFirst = entry.getValue();
            List<Boolean> valueSecond = second.get(key);

            List<Boolean> resValue = new ArrayList<>();

            if(valueFirst.size() == valueSecond.size()){
                result.put(key, resValue);
                continue;
            }

            List<Boolean> longestArray = new ArrayList<>();
            List<Boolean> shortestArray = new ArrayList<>();
            if(valueFirst.size() > valueSecond.size()){
                longestArray.addAll(valueFirst);
                shortestArray.addAll(valueSecond);
            }else {
                longestArray.addAll(valueSecond);
                shortestArray.addAll(valueFirst);
            }

            for(int i = shortestArray.size(); i < longestArray.size(); i++){
                resValue.add(longestArray.get(i));
            }

            result.put(key, resValue);

        }

        return result;
    }



    protected SearchDirections countLawsSearchDirections(HashMap<String, List<Boolean>> difference){

        Pair<Integer, Integer> counts = countMaximumCountOfErrorAndErrorCount(difference);
        int maximumCountOfError = counts.getFirst();
        int errorCount = counts.getSecond();

        if(maximumCountOfError > 2 || errorCount > 4){
            return SearchDirections.TO_SIMPLE;
        }
        return SearchDirections.TO_COMPLEX;
    }

    protected int countComplexityByDifference(HashMap<String, List<Boolean>> difference){

        Pair<Integer, Integer> counts = countMaximumCountOfErrorAndErrorCount(difference);
        int maximumCountOfError = counts.getFirst();
        int errorCount = counts.getSecond();

        if(maximumCountOfError > 2 || errorCount > 4){
            return -1;
        }

        if(errorCount > 2){
            return 0;
        }

        return 1;
    }

    protected Pair<Integer, Integer> countMaximumCountOfErrorAndErrorCount(HashMap<String, List<Boolean>> difference){
        int maximumCountOfError = 0;
        int errorCount = 0;

        for(Map.Entry<String, List<Boolean>> entry : difference.entrySet()) {
            String key = entry.getKey();
            List<Boolean> valueFirst = entry.getValue();

            int currentErrorCount = 0;
            for (Boolean currentAnswer : valueFirst) {
                if(currentAnswer == Boolean.FALSE){
                    currentErrorCount++;
                    errorCount++;
                }
            }

            maximumCountOfError = Math.max(maximumCountOfError, currentErrorCount);

        }

        return Pair.of(maximumCountOfError, errorCount);
    }

    protected int countGradeWindow(){
        return WINDOW_TO_GRADE;
    }

    protected float countTargetGrade(){ return TARGET_GRADE; }

    //List отсортированных по времени (от последних до первых) верных и неверных применений концепта
    private float countGradeByUsage(List<Boolean> conceptUsageResult, float k){
        float maximumGrade = 0;
        float realGrade = 0;

        ArrayList<Boolean> conceptUsageToAnalise = convertConceptUsageResultBeforeAnalise(conceptUsageResult);
        Collections.reverse(conceptUsageToAnalise);
        for (int i = 0; i < conceptUsageToAnalise.size(); i++) {
            float weightOfElement = (i * k)+ 1;
            maximumGrade += weightOfElement;

            if(conceptUsageToAnalise.get(i) == Boolean.TRUE){
                realGrade += weightOfElement;
            }
        }

        return realGrade / maximumGrade;
    }

    //Рассчитывает меру уверенности стратегии в оценке знаний по концепту
    //List отсортированных по времени (от последних до первых) верных и неверных применений концепта
    //Уверенность - мера однородности массива. Чем более однороден массив, тем выше уверенность
    private float countConfidence(List<Boolean> conceptUsageResult){

        int componentCount = 2;

        ArrayList<Boolean> conceptUsageToAnalise = convertConceptUsageResultBeforeAnalise(conceptUsageResult);
        ArrayList<Integer> reducedUsage = reduceUsage(conceptUsageToAnalise);

        int numberOfChanges = reducedUsage.size();
        int numberOfConceptUsage = conceptUsageToAnalise.size();
        int countOfMaxAnswer = 0;

        for (Boolean currentElement : conceptUsageToAnalise) {
            if (currentElement == Boolean.TRUE) {
                countOfMaxAnswer++;
            }
        }

        countOfMaxAnswer = Math.max(countOfMaxAnswer, numberOfConceptUsage - countOfMaxAnswer);

        int maxLenInReduce = 0;
        for (Integer currentLen : reducedUsage) {
            maxLenInReduce = Math.max(maxLenInReduce, currentLen);
        }

        return (((float)countOfMaxAnswer / numberOfConceptUsage)
                + (((float)maxLenInReduce / numberOfConceptUsage) / (float)numberOfChanges)) / componentCount;

    }

    private ArrayList<Integer> reduceUsage(ArrayList<Boolean> conceptUsageToAnalise){
        ArrayList<Integer> reducedUsage = new ArrayList<>();

        Boolean lastElement = null;

        for (Boolean currentElement : conceptUsageToAnalise) {
            if(currentElement != lastElement){
                reducedUsage.add(1);
                lastElement = currentElement;
            } else {
                reducedUsage.set(reducedUsage.size() - 1, reducedUsage.get(reducedUsage.size() - 1) + 1);
            }
        }

        return reducedUsage;
    }

    private ArrayList<Boolean> convertConceptUsageResultBeforeAnalise(List<Boolean> conceptUsageResult){
        int countToCheck = countGradeWindow();
        ArrayList<Boolean> conceptUsageToAnalise = new ArrayList<>();

        int i = 0;
        for (i = 0; i < countToCheck && i < conceptUsageResult.size(); i++) {
            conceptUsageToAnalise.add(conceptUsageResult.get(i));
        }

        for (; i < countToCheck; i++) {
            conceptUsageToAnalise.add(Boolean.FALSE);
        }

        return conceptUsageToAnalise;
    }

    static class QuestionOrderComparator implements Comparator<QuestionEntity> {
        @Getter
        private static final QuestionOrderComparator instance = new QuestionOrderComparator();

        private QuestionOrderComparator() {}

        @Override
        public int compare(QuestionEntity a, QuestionEntity b) {
            return a.getId().compareTo(b.getId());
        }
    }

    static class InteractionOrderComparator implements Comparator<InteractionEntity> {
        @Getter
        private static final InteractionOrderComparator instance = new InteractionOrderComparator();

        private InteractionOrderComparator() {}

        @Override
        public int compare(InteractionEntity a, InteractionEntity b) {
            return Integer.compare(a.getOrderNumber(), b.getOrderNumber());
        }
    }

    static class LawGradeComparator implements Comparator<Pair<String, Float>> {
        @Getter
        private static final LawGradeComparator instance = new LawGradeComparator();

        private LawGradeComparator() {}

        @Override
        public int compare(Pair<String, Float> a, Pair<String, Float> b) {
            return a.getSecond().compareTo(b.getSecond());
        }
    }


}
